# Hypertext Transfer Protocol -- HTTP/1.1

## 此备忘录状态

此文档为因特网通信指定了一个标准追踪协议，同时希望与大家讨论并得到建议以不断改进。请将 “因特网官方协议标准” 的当前版本作为本协议的状态和标准化状态。任何人都可以不受限制地分发此文档。

## 摘要

超文本传输协议 HTTP 是一个应用层协议，用于分布式、协作的、异构的信息系统。它是一个通用的、无状态的协议。通过扩展他的请求方法，错误码和协议首部，还可以完成超文本传输之外的更多其它任务。比如命名服务器和分布式对象管理系统等。HTTP 的一大特征就是类型和数据表示协商，这将允许相互传递数据的系统可以互不依赖地创建。

从1990年开始，HTTP 就已经被用于 World-Wide Web 全球信息系统。此规范定义的协议被称为 "HTTP/1.1" ，同时也是 RFC 2068 的升级版本。

# 目录

* 1 介绍

  * 1.1 目的

  * 1.2 需求
  * 1.3 术语
  * 1.4 整体运作

* 2 符号约定和一般语法
  * 2.1 扩展的 BNF
  * 2.2 基本规则

* 3 协议参数

  * 3.1 HTTP 版本
  * 3.2 统一资源标识符
    * 3.2.1 通用语法
    * 3.2.2 http URL
    * 3.2.3 URI 对比
  * 3.3 日期/时间格式
    * 3.3.1 完整日期
    * 3.3.2 时间差秒数
  * 3.4 字符集
    * 3.4.1 遗漏字符集
  * 3.5 内容编码
  * 3.6 传输编码
    * 3.6.1 分块传输编码
  * 3.7 媒体类型
    * 3.7.1 标准化和默认文本
    * 3.7.2 多中成分类型
  * 3.8 产品标识
  * 3.9 质量值
  * 3.10 语言标签
  * 3.11 实体标签
  * 3.12 范围单元

* 4 HTTP 消息

  * 4.1 消息类型
  * 4.2 消息首部
  * 4.3 消息体
  * 4.4 消息长度
  * 4.5 通用首部字段

* 5 请求

  * 5.1 请求行
    * 5.1.1 方法
    * 5.1.2 请求 URI
  * 5.2 由请求标识的资源
  * 5.3 请求首部字段

* 6 响应

  * 6.1 状态行
    * 6.1.1 状态码和原因信息
  * 6.2 响应首部字段

* 7 实体

  * 7.1 实体首部字段
  * 7.2 实体主体
    * 7.2.1 类型
    * 7.2.2 实体长度

* 8 连接

  * 8.1 持久化连接
    * 8.1.1 目的
    * 8.1.2 综述
    * 8.1.3 代理服务器
    * 8.1.4 现实考量
  * 8.2 信息传输需求
    * 8.2.1 持久化连接和流量控制
    * 8.2.2 为错误状态消息进行连接监控
    * 8.2.3 100 状态码使用
    * 8.2.4 服务端过早关闭连接时客户端行为

* 9 方法定义

  * 9.1 安全和幂等方法
    * 9.1.1 安全方法
    * 9.1.2 幂等方法
  * 9.2 OPTIONS
  * 9.3 GET
  * 9.4 HEAD
  * 9.5 POST
  * 9.6 PUT
  * 9.7 DELETE
  * 9.8 TRACE
  * 9.9 CONNECT

* 10 状态码定义

  * 10.1 信息 1xx
    * 10.1.1 100 继续
    * 10.1.2 101 切换协议
  * 10.2 成功 2xx
    * 10.2.1 200 OK
    * 10.2.2 201 创建
    * 10.2.3 202 接受
    * 10.2.4 203 无授权信息
    * 10.2.5 204 无内容
    * 10.2.6 205 重置内容
    * 10.2.7 206 部分内容
  * 10.3 重定向 3xx
    * 10.3.1 300 多种选择
    * 10.3.2 301 永久迁移
    * 10.3.3 302 找到
    * 10.3.4 303 看看别的
    * 10.3.5 304 没有修改
    * 10.3.6 305 使用代理
    * 10.3.7 306 （尚未使用）
    * 10.3.8 307 临时重定向
  * 10.4 客户端错误 4xx
    * 10.4.1 400 错误请求
    * 10.4.2 401 未授权
    * 10.4.3 402 需要支付
    * 10.4.4 403 禁止
    * 10.4.5 404 没有找到
    * 10.4.6 405 不允许的方法
    * 10.4.7 406 不可接受
    * 10.4.8 407 代理认证需求
    * 10.4.9 408 请求超时
    * 10.4.10 409 冲突
    * 10.4.11 410 过去的
    * 10.4.12 411 长度需求
    * 10.4.13 412 预处理失败
    * 10.4.14 413 请求体太大
    * 10.4.15 414 请求 URI 太长
    * 10.4.16 415 不支持的媒体类型
    * 10.4.17 416 请求范围不满足
    * 10.4.18 417 预期失败
  * 10.5 服务端错误 5xx
    * 10.5.1 500 服务器内部错误
    * 10.5.2 501 未实现
    * 10.5.3 502 网管错误
    * 10.5.4 503 服务不可用
    * 10.5.5 504 网关超时
    * 10.5.6 505 HTTP 版本不支持

* 11 访问认证

* 12 内容协商

  * 12.1 服务端驱动协商
  * 12.2 客户端驱动协商
  * 12.3 传输协商

* 13 HTTP 中的缓存

  * 13.1 缓存
    * 13.1.1 缓存正确性
    * 13.1.2 警告
    * 13.1.3 缓存控制机制
    * 13.1.4 显式用户端警告
    * 13.1.5 规则和警告异常
    * 13.1.6 客户端控制行为
  * 13.2 超时模型
    * 13.2.1 服务端指定超时
    * 13.2.2 启发式超时
    * 13.2.3 生存时间计算
    * 13.2.4 超时时间计算
    * 13.2.5 超时时间消除歧义性
    * 13.2.6 多个响应消除歧义性
  * 13.3 校验模型
    * 13.3.1 最近一次修改日期
    * 13.3.2 实体标签缓存校验器
    * 13.3.3 强校验器和弱校验器
    * 13.3.4 实体标签和最近修改日期使用时机规则
    * 13.3.5 条件性无校验
  * 13.4 响应可缓存性
  * 13.5 由缓存构建响应
    * 13.5.1 端到端首部和跳到跳首部
    * 13.5.2 不可修改的首部
    * 13.5.3 联合首部
    * 13.5.4 组合字节范围
  * 13.6 缓存协商的响应
  * 13.7 共享和非共享缓存
  * 13.8 错误或者不完整响应缓存行为
  * 13.9 GET 和 HEAD 的副作用
  * 13.10 升级或者删除后的实效
  * 13.11 强制写穿透
  * 13.12 缓存替换
  * 13.13 历史列表

* 14 首部字段定义

  * 14.1 Accept
  * 14.2 Accept-Charset
  * 14.3 Accept-Encoding
  * 14.4 Accept-Language
  * 14.5 Accept-Ranges
  * 14.6 Age
  * 14.7 Allow
  * 14.8 Authorization
  * 14.9 Cache-Control
    * 14.9.1 可缓存性是什么意思
    * 14.9.2 哪些数据可以被缓存
    * 14.9.3 基本的超时机制的修改
    * 14.9.4 缓存重校验和重新加载控制
    * 14.9.5 No-Transform 命令
    * 14.9.6 缓存控制扩展
  * 14.10 Connection
  * 14.11 Content-Encoding
  * 14.12 Content-Language
  * 14.13 Content-Length
  * 14.14 Content-Location
  * 14.15 Content-MD5
  * 14.16 Content-Range
  * 14.17 Content-Type
  * 14.18 Date
    * 14.18.1 无时钟的原始服务器操作
  * 14.19 ETag
  * 14.20 Expect
  * 14.21 Expires
  * 14.22 From
  * 14.23 Host
  * 14.24 If-Match
  * 14.25 If-Modified-Since
  * 14.26 If-None-Match
  * 14.27 If-Range
  * 14.28 If-Unmodified-Since
  * 14.29 Last-Modified
  * 14.30 Location
  * 14.31 Max-Forwards
  * 14.32 Pragma
  * 14.33 Proxy-Authenticate
  * 14.34 Proxy-Authorization
  * 14.35 Range
    * 14.35.1 Byte Ranges
    * 14.35.2 Range Retrieval Requests
  * 14.36 Referer
  * 14.37 Retry-After
  * 14.38 Server
  * 14.39 TE
  * 14.40 Trailer
  * 14.41 Transfer-Encoding
  * 14.42 Upgrade
  * 14.43 User-Agent
  * 14.44 Vary
  * 14.45 Via
  * 14.46 Warning
  * 14.47 WWW-Authenticate

* 15 安全考量

  * 15.1 个人信息
    * 15.1.1 服务端日志信息的滥用
    * 15.1.2 敏感信息传输
    * 15.1.3 将 URI 中的敏感信息编码
    * 15.1.4 隐私问题与 Accept Headers
  * 15.2 基于文件名和路径名的攻击
  * 15.3 DNS 欺骗
  * 15.4 位置首部和欺骗
  * 15.5 Content-Disposition 问题
  * 15.6 身份凭证和懒客户端
  * 15.7 代理和缓存
    * 15.7.1 代理上的拒绝服务攻击

# 1 介绍

## 1.1 目标

超文本传输协议 HTTP 是一个应用层协议，用于分布式异构协作信息系统。从1990年开始就已经被用于 World-Wide Web 全球信息系统。HTTP 的首个版本，称为 HTTP/0.9，是一个用于在因特网上传输原始数据的简单的协议。由 RFC 1945 定义的 HTTP/1.0 改进了该协议。它允许传输类 MIME 格式的消息，包含被传输数据的元信息以及请求/响应语义上的修饰词。然而，HTTP/1.0 并为充分考虑层级代理、缓存、持久化连接需求以及虚拟主机等因素的影响。更重要的是，随着越来越多的应用宣称它们支持 HTTP/1.0 的情况也使得更新协议版本成为必要。唯有如此，相互通信的应用才能确定对方真实的兼容性。

本规范定义的协议称为 HTTP/1.1 。此协议相比 HTTP/1.0 包含更多迫切需求，保证其宣称特性的可靠实现。

实用性的信息系统需要简单检索之外的更多功能，包括搜索、前端更新以及注解。HTTP 允许无限制的方法和首部集合用于表达请求目标。它构建在一系列规范基础之上，包括统一资源定位符、表示位置的 URL、表示名称的 URN，都用于表示请求方法将要应用于其上的资源。传递的消息格式类似于电子邮件，由多用途因特网邮件扩展 MIME 规范定义。

HTTP 也被作为通用协议用于用户代理程序与其它网路系统代理或者网关之间的通信。这些网路系统可能支持 SMTP、NNTP、FTP、Gopher 或者 WAIS 协议。这种情况下，HTTP 允许对各种应用中的可用资源进行超媒体访问。

## 1.2 必要条件

此文档中 "必须"、“必须不”、“需要”、“应该“、”不应该“、"推荐的"、“可以” 以及 “可选的” 等关键词的含义在 RFC 2119 中描述。

如果一个实现没能满足它所实现协议的一个或者多个 “必须” 或者 “需要” 级别的需求，则它就是不符合规范的。如果一个实现完全满足它所实现协议的所有 “必须” 或者 “需要” 级别需求，同时还有 “应该” 级别需求，则该实现就是所谓 “无条件符合” 协议规范的。如果一个实现完全满足它所实现协议的所有 “必须” 或者 “需要” 级别需求，但是不满足所有 “应该” 级别需求，则该实现就是所谓 “条件符合” 协议规范的。

## 1.3 术语

此规范使用一系列术语用于表示 HTTP 通信中相互通信的双方角色，以及相关对象。

连接：一个运输层虚拟回路，为了通信目的建立在两个程序之间。

消息：HTTP 通信的基本数据单元，由遵循第四章中定义的语法的结构化八位位组序列构成，通过连接传输。

请求：一个 HTTP 请求消息，在第五章中定义。

响应：一个 HTTP 响应消息，在第六章中定义。

资源：可以被一个 URI 定位的一个网路数据对象或者服务，在3.2章节定义。资源可以以多种表现形式和多种方式被访问。

实体：作为请求或者响应的载荷被传输的信息。一个实体由两部分构成，实体首部字段形式的元信息，实体主体形式的内容，就像第七章中描述的那样。

表现：响应包含的实体，受内容协商的支配，在12章中描述。关于一个特定响应状态可以存在多种表现。

内容协商：在服务一个请求时选择合适表现的机制，在12章中描述。任何响应中包含的实体表现都可以协商，包括错误响应。

变体：在任何给定时刻，一个资源可以有一种或者多种相关联的表现。每个此种表现有个术语 “变体” 表达。该术语的使用在描述受内容协商支配的资源时是不必要的。

客户端：以发送请求为目的而建立连接的程序。

用户代理：发起初始请求的客户端。通常是浏览器、编辑器、蜘蛛（网络遍历机器人）或者其它终端用户工具。

服务器：接受连接用于通过回送响应来服务请求的应用程序。任何给定程序可以同时觉有作为客户端和服务器的能力，我们私用这些术语表达某个特定连接中的程序的角色，而不是该程序的通用功能。同样的，任何服务器的行为可以是一个原始的服务器、代理、网关或者隧道，可以根据每个请求的具体特性随时切换行为。

原始服务器：提供所包含的资源或者由自身创建的资源的服务器。

代理：一个中间人程序，同时具有服务器和客户端的行为，代表其他客户端产生请求。请求被它们内部处理或者传递，同时进行可能的转换，给其他服务器。一个代理必须同时实现本规范要求的客户端和服务器特性。所谓的透明代理指的是除了必要的代理身份认证之外不对请求和响应进行任何修改的代理。相对的，不透明代理为了完成更过功能会对请求或者响应进行某些修改，比如群组注解服务、媒体类型转化、协议降级或者匿名过滤等。除了这两种行为明确说明的情况，HTTP 代理需求应用于这两种类型的代理。

网关：作为其它服务器中间人的服务器。与代理不同，网关就像原始服务器那样接收请求。发送请求的客户端可能都感觉不到它正在跟网关通信。

隧道：一个中间人程序用于在两个连接之前进行隐蔽传输。一旦激活，隧道就不会被认为是 HTTP 通信的一部分，尽管隧道可能本来就是由一个 HTTP 请求初始化的。当隐蔽传输两端的连接都被关闭时隧道也就不存在了。

缓存：一个程序中对响应消息的本地存储，以及控制它的消息存储、检索以及删除的子系统。缓存可以存储可缓存的响应以缩短随后相同请求的响应时间和网络带宽消耗。任何客户端或者服务器都可以包含缓存，但是作为隧道的服务器不能使用缓存。

可缓存性：一个响应是可缓存的，如果允许缓存存储响应消息的副本用于回应后续的请求。HTTP 响应的可缓存性规则在第13章中定义。即使一个资源是可缓存的，可能还有些附加的约束以确定缓存能否对特定请求使用缓存的响应数据副本。

第一手：一个响应是第一手的，如果它直接来自原始服务器，而没有被不必要地延误过，可能是通过一个或者多个代理服务器。如果响应的合法性只是直接被原始服务器验证过的响应同样也是第一手的。

明确的超时时间：原始服务器在该时间之后就认为实体不应该再继续从缓存中返回，而不需要进行更多的校验。

隐含的超时时间：当没有显式设置超时时间的情况下缓存默认配置的超时时间。

年龄：响应的年龄是从它被发送以来经历的时间，或者被原始服务器成功校验过以来经历的时间。

新鲜生存时间：响应产生到超时时间点之间的时间长度。

新鲜的：响应是新鲜的，如果它的年龄尚未超过它的新鲜生存时间。

陈旧的：响应是陈旧的，如果它的年龄已经超过了它的新鲜生存时间。

语义透明：缓存以 “语义透明” 的方式工作，对于特定的响应，当使用缓存时既不会影响发送请求的客户端，也不会影响原始服务器，除了对性能的改善。当一个缓存是语义透明的，客户端收到的响应与它发送的请求直接被原始服务器处理时返回的响应完全一样（除了逐跳首部）。

校验器：一个协议元素，比如实体标签或者最近修改时间，用于确认缓存实体是否确实是原始实体的全等副本。

上游/下游：描述消息流方向，所有的消息流都是从上游流向下游。

入/出：表示请求和响应的消息路径，“入” 表示 “消息向着原始服务器而来”，“出” 表示 “消息向着用户代理而去”。

## 1.4 整体运作

HTTP 协议是一个请求/响应协议。客户端以请求方法、URI、协议版本、连同一个包含请求修饰词、客户端信息以及可能的内容体的类 MIME 消息，通过连接向服务器发送一个请求。服务器响应携带一个状态行，包含消息协议版本和成功或者错误编码，连同一个包含服务器信息、实体元信息以及可能存在的实体主体内容的类 MIME 消息。HTTP 和 MIME 之间的关系在附录19.4中描述。

大部分 HTTP 通信都是由用户代理发起，由一个应用于原始服务器上的资源的请求组成。最简单的情况下，这个过程可以通过一个位于用户代理 UA 和原始服务器 O 之间的连接 v 完成。

````
    request chain  --------------------------------->
UA  -------------------------v---------------------->  O
    <--------------------------------  response chain
````

更复杂的情况，在请求/响应链上存在一个或者多个中间人。存在三种中间人形式：代理、网关和隧道。代理是一个转发代理，按照 URI 绝对形式接收请求，重写全部或者部分消息，然后将重新格式化后的请求转发给 URI 指定的服务器。网关是一个接收代理，工作在其他服务器更高的逻辑层次上，同时，如果有必要，转换请求为目标服务器协议。隧道时两个连接之间的隐蔽点，它不会改变消息。当通信必须通过某些中间人，比如防火墙，而该中间人无法理解消息内容的情况下，就可以使用隧道。

````
    request chain  --------------------------------------------->
UA  --------v-------A--------v-------B------v-----C------v------>  O
    <--------------------------------------------  response chain
````

上图展示了用户代理和原始服务器之间存在三个中间人的情况。一个请求或者响应消息需要穿过四个单独的连接才能通过整个链路。这种区别是很重要的，因为一些 HTTP 通信选项只能应用与跟最近的、无隧道的邻居之间的连接，或者只能应用于链路的端点，或者只能应用于链路上的所有连接。尽管上图是线性的，每个参与者可以参与多路并发的通信。比如，B 可能正在接收来自除了 A 之外多个客户端的请求，并且/或者向除了 C 之外的多个服务器转发请求，同时它还在处理 A 的请求。

以上通信过程中的任何部分，只要不是作为隧道，都可以采用内部缓存用于处理请求。缓存的作用是可能缩短图中的请求/响应链路，如果其中某个参与者缓存的响应数据匹配到了某个请求。下图展示了当 B 拥有早先通过 C 从原始服务器 O 获取的响应的缓存，而 UA 和 A 都没有缓存此响应时的结果链

````
    request chain  ----------------->
UA  --------v-------A--------v-------B------v-----C------v------>  O
    <----------------  response chain
````

不是所有响应都需要缓存，某些请求可能包含修饰词指定了对缓存行为的特殊需求。更多细节参见13章。

事实上，在目前的 World Wide Web 上存在多种多样的缓存和代理的体系结构和配置，有些还处于试验阶段。这些系统包含国家级的层级结构的代理缓存以节约跨海通信带宽，广播系统或者组播缓存入口，通过 CD-ROM 分发缓存数据的分布式组织，等等。HTTP 系统被用于通过高带宽链路来协同内联网，或者通过个人数字助手使用低能耗且不稳定的的广播链路访问数据。HTTP/1.1 的目标就是支持这种已经部署的宽泛的差异性系统，这些系统和协议同时被构建起来，协议始终追随 web 应用创建者的各种需求，比如，高可用需求，或者至少是可靠的失败提示。

HTTP 通信通常采用 TCP/IP 连接。默认端口是 TCP 80，但是也可以使用其他端口。并未阻止 HTTP 在任何其他因特网协议之上实现，或者在任何其他网络上实现。HTTP 仅仅预先假定了可靠传输，任何协议只要可以提供可靠传输保证即可被 HTTP 使用。HTTP/1.1 请求和响应数据结构映射到传输层协议数据单元不在此规范讨论范围。

在 HTTP/1.0 中，大多数实现都为每个请求/响应交互使用一个新的连接。在 HTTP/1.1 中，一个连接可以被用于一个或者多个请求/响应交互，尽管连接可能由于各种原因被关闭。

# 2 符号约定和一般语法

## 2.1 扩展的 BNF

本规范中所有的机制都被用自然语言和扩展的 BNF 两种形式同时描述，扩展的 BNF 类似于 RFC 822 中使用的那样。实现者们需要熟悉这种符号以便于理解本规范。扩展的 BNF 包含以下结构：

````name = definition````

​	规则的名称就是简单的名字本身，与它的定义以````=````分隔。空格只是在通过行首缩进表示规则定义延续到多行的情况下才是有意义的。某些基本规则都是大写字母命名，比如 SP、LWS、HT、CRLF、DIGIT、ALPHA 等等。尖括号被用在规则定义中为了便于识别出所使用的规则名称。

````"literal"````

​	引号标记包围的字面文本。除非特别规定，该文本是大小写敏感的。

````rule1 | rule2````

​	以竖线````|````分隔的元素是可供选择的，比如````yes | no````表示可接受````yes````或者````no````。

````(rule1 rule2)````

​	括号包围的多个元素被作为单一元素对待。因此````(elem (foo | bar) elem)````允许记号序列````elem foo elem````和````elem bar elem````。

````*rule````

​	元素之前的````*````号表示重复。完整的形式是````<n>*<m>element````表示元素出现最少````<n>````次最多````<m>````次。默认值是0和无限大，因此````*(element)````允许元素出现任意次，包含0次。````1*element````需要元素至少出现一次。````1*2element````允许元素出现一次或者两次。

````[rule]````

​	方括号包围的是可选元素。````[foo bar]````等价于````*1(foo bar)````。

````N rule````

​	指定元素重复出现次数。````<n>(element)````等价于````<n>*<n>(element)````，表示````(element)````精确出现````<n>````次。因此````2DIGIT````表示一个两位数字，````3ALPHA````表示三个字母字符的字符串。

````# rule````

​	````#````定义的结构类似于````*````，用于定义元素列表。其完整形式为````<n>#<m>element````，表示最少````<n>````个最多````<m>````个元素，元素之间由一个或者多个````,````字符或者可选的线性空白````LWS````分隔。这就可以很方便地表示列表。

如下规则：

​	````( *LWS element * ( * LWS "," *LWS element ))````

可以显示为：

​	````1#element````

使用此结构的地方，空元素是允许的，不过空元素并不会被算作一个存在的元素。也就是说，````(element),  , (element)````是允许的，但是只算是两个元素。因此，需要至少一个元素的地方，必须存在至少一个非空元素。基于默认值0和无限大````#element````允许任意数量的元素，包括0个。````1#element````需要至少一个元素，````1#2element````允许一个或者两个。

````; comment````

​	分号与右边的文字之间留一段距离，注释一直延续的该行末尾。这种方式可以很方便地为规范添加额外的有用说明信息。

````implied *LWS````

​	此语法在本规范中以基于词汇的方法描述。除非特别说明，线性空白````LWS````可以被包含在任何相邻的两个词汇之间，或者相邻的词汇和分隔符之间，而不会改变字段的含义。至少一个分隔符````LWS````或者````separators````必须出现在任意两个记号之间，以免它们被误以为是一个记号。

## 2.2 基本规则

下列规则贯穿整个规范文档，用于描述基本的语法结构。其中的 US-ASCII 编码字符集在 ANSI X3.4-1986 中定义。

````xml
OCTET		= <any 8-bit sequence of data>
CHAR		= <any US-ASCII character (octets 0-127)>
UPALPHA		= <any US-ASCII uppercase letter "A".."Z">
LOALPHA		= <any US-ASCII lowercase letter "a".."z">
ALPHA		= UPALPHA | LOALPHA
DIGIT		= <any US-ASCII digit "0".."9">
CTL			= <any US-ASCII control character (octets 0-31) and DEL (127)>
CR			= <US-ASCII CR, carriage return (13)>
LF			= <US-ASCII LF, linefeed (10)>
SP			= <US-ASCII SP, space (32)>
HT			= <US-ASCII HT, horizontal-tab (9)>
<''>		= <US-ASCII double-quote mark (34)>
````

HTTP/1.1 定义````CR LF````序列为除了实体主体之外所有协议元素的行结束标志。而实体主体的行结束标志取决于它对应的媒体类型，在3.7章节中介绍。

​	````CRLF	= CR LF````

HTTP/1.1 协议首部字段值当连续行以空格或者水平制表符开头时可以被折行。所有的线性空白，包括折行，都有相同语义````SP````。一个可取的方案是在将解读字段值或者将消息向下游转发之前将所有线性空白替换为单个````SP````。

​	````LWS		= [CRLF] 1*( SP | HT)````

````TEXT````规则仅仅被用来描述字段内容和值，这些内容和值不会被消息解析器解释。````*TEXT````可以包含 ISO-8859-1 字符集之外的字符，仅仅当它根据 RFC 2047 的规则进行编码时。

​	````TEXT	= <any OCTET except CTLs, but including LWS>````

CRLF 只有作为首部字段的连词符时才允许出现在 TEXT 定义中。例外的情况，用于折行的 LWS 在 TEXT 值被解释之前将被一个单一的 SP 替换。

十六进制的数字字符可以用在若干种协议元素中。

````xml
HEX	        = "A" | "B" | "C" | "D" | "E" | "F"   

			| "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
````

许多 HTTP/1.1 协议首部字段值由 LWS 或者其它特殊字符分隔的词语组成。这些特殊字符必须由引号包围，用于表示参数值。

````
token			= 1*<any CHAR except CTLs or separators>

separators		= "(" | ")" | "<" | ">" | "@"

				| "," | ";" | ":" | "\" | <">

				| "/" | "[" | "]" | "?" | "="

				| "{" | "}" | SP | HT`
````

一些 HTTP 首部字段都可以包含注释，用括号包围注释文本。注释仅仅允许用在包含````comment````作为字段值一部分的定义中。在其它所有字段中，括号都会被认为是字段值的一部分。

​	````comment	= "(" *( ctext | quoted-pair | comment ) ")"````

​	````ctext	= <any TEXT excluding "(" and ")">````

如果被双引号包围，则文本字符串会被当作单一一个词语。

​	````quoted-string	= ( <"> * ( qdtext | quoted-pair ) <"> )````

​	````qdtext		= <any TEXT except <">>````

反斜杠字符````\````可以被作为一个单字符引号机制，仅仅用在包围字符串和注释结构。

​	````quoted-pair		= "\" CHAR````

# 3 协议参数

## 3.1 HTTP 版本

HTTP 使用````<major>.<minor>````数字体系表示协议的版本。协议版本化策略目的是允许消息发送方说明消息格式和它自身理解后续 HTTP 通信的能力，而不是通过通信过程获取这些特性。附加消息组件不会影响通信行为，只是增加一些可扩展字段值，这种情况协议版本号不需要变化。当修改协议，添加特性在不改变通用消息解析算法前提下，添加消息语义和增加发送方附加能力时，````<minor>````数字需要增加。当协议消息格式发生变化时````<major>````值也需要增加。进一步解释参见 RFC 2145 。

HTTP 消息版本通过消息第一行中的````HTTP-Version````字段表示。

​	````HTTP-Version	= "HTTP" "/" 1*DIGIT "." 1*DIGIT````

注意这里的 major 和 minor 版本号必须被视为独立的整数，而且都可以增加任意整数数量。因此，HTTP/2.4 是比 HTTP/2.13 更低的版本号，而 HTTP/12.3 版本号更高。版本号开头的0必须被忽略，绝对不能被发送出去。

一个发送的请求或者响应消息中包含 HTTP/1.1 协议的````HTTP-Version````首部字段的应用必须是至少条件兼容与本规范的。至少条件兼容此规范的应用应该在它们的消息中使用 HTTP/1.1 协议的````HTTP-Version````首部字段，而且必须对所有不兼容 HTTP/1.0 协议的消息也这么做。关于何时发送指定````HTTP-Version````值的细节可以参考 RFC 2145 。

应用的 HTTP 版本是该应用至少条件兼容的 HTTP 协议规范版本。

代理和网关应用在转发那些协议版本与应用本身协议版本不一致的消息时需要当心。因为消息的协议版本表示的是发送者的协议处理能力，代理和网关绝对不能发送携带协议版本超过它们本来版本的消息。如果接收到高于自身支持协议版本的请求，代理或者网关必须要么将请求版本降级，要么响应一个错误，或者干脆切换到隧道模式。

自从 RFC 2068 发布以来，由于 HTTP/1.0 代理在互操作性方面被发现的问题，缓存代理必须、网关可以、隧道绝不能升级请求的版本到它们支持自身支持的更高协议版本。代理或者网关的响应必须与请求是同一个主要版本。

注意：HTTP 协议版本的切换可能牵涉到协议首部字段的修改需求，也可能被相关版本禁止。

## 3.2 统一资源标识符

URIs 已经以许多名称为人们熟知：WWW 地址、通用文件标识符、通用资源标识符等，最终演化成为统一资源定位符 URL 和统一资源名称 URN 的结合。在跟 HTTP 扯上关系之前，统一资源标识符知识简单地用名称、位置或者任何其他字符来标识资源的字符串而已。

### 3.2.1 通用语法

HTTP 中的 URIs 可以被表示为绝对路径形式或者相对于某些周知基本 URI 的相对路径形式，取决于它们所使用的上下文。两种形式的主要区别在于绝对 URIs 永远都会以一个后面跟着冒号的协议名称开头。更多有关 URI 语法定义的信息参见 RFC 2396 。本规范吸收了该规范中相关定义，诸如````URI-reference````、````absoluteURI````、````relativeURI````、````port````、````host````、````abs_path````、````rel_path````以及````authority````等。

HTTP 协议并没有对 URI 长度进行任何限制。服务器必须能够处理任何它所提供的资源对应的 URI，同时应该能够处理无限长度的 URIs ，如果它们提供了基于 GET 的接口服务，这种请求就有可能产生无限长度的 URIs。如果 URI 长度超过了服务器的处理能力，服务器应该返回 414 请求 URI 过长状态响应。

注意：服务器使用长度超过 255 字节的 URI 时要格外小心，因为一些老版本的客户端或者代理服务器的实现可能不能支持这样的长度。

### 3.2.2 http URL

HTTP 协议使用````http````体系来定位网络资源。本章节定义该体系特定的 http URLs 的语法和语义。

````http_URL = "http:" "//" host [ ":" port ] [ abs_path [ "?" query ] ]````

如果````port````是空或者没有给出，则假定使用 80 端口。上面表达式的语义是访问的资源正位于服务器上，在````host````主机的````port````端口上监听着 TCP 连接，同时指向该资源的````Request-URI````就是````abs_path````。根据 RFC 1900 应该尽可能避免在 URLs 中使用 IP 地址。如果 URL 中没有````abs_path````，则当被用作指向某资源的````Request-URI````时必须给定其值为````/````。如果代理接收到的主机名不是完整的全限定域名，它就可以将自己的域名添加到它接收到的主机名中。如果代理接收到的主机名是完整的全限定域名，则它绝对不能改变该主机名。

### 3.2.3 URI 对比

当比较两个 URIs 以确定它们是否匹配时，客户端应该使用大小写敏感的方式逐字符比较整个 URIs，不过存在以下例外：

* 对````URI-reference````来说端口号为空或者未给出等价于默认端口；
* 主机名比较必须是大小写不敏感的；
* 体系名称比较必须是大小写不敏感的；
* 空````abs_path````等价于值为````/````的````abs_path````。

不在保留字符集合或者不安全字符集中的其它字符都等价于它们各自的````"%" HEX HEX````编码。

例如，下面几个 URIs 都是等价的：

````
http://abc.com:80/~smith/home.html
http://ABC.com/%7Esmith/home.html
http://ABC.com:/%7Esmith/home.html
````

## 3.3 日期时间格式

### 3.3.1 完整日期

HTTP 应用传统上允许使用三种不同的格式表示日期和时间戳：

````xml
Sun, 06 Nov 1994 08:49:37 GMT	; RFC 822, updated by RFC 1123
Sunday, 06-Nov-94 08:49:37 GMT	; RFC 850, obsoleted by RFC 1036
Sun Nov 6 08:49:37 1994			; ANSI C's asctime() format
````

第一种格式被广泛作为互联网标准，表示为一个固定长度的子集，由 RFC 1123 定义。第二种格式应用也很广泛，但是它基于已经淘汰的 RFC 850 日期格式，缺少四位数字的年份表示。HTTP/1.1 客户端和服务器必须接受所有这三种日期时间格式，保证兼容 HTTP/1.0 。然而它们必须只产生 RFC 1123 格式的 HTTP 日期值用于协议首部字段。更多细节参见 19.3 章节。

注意：日期值的接收者被鼓励对接收来自非 HTTP 协议应用的日期值保持足够的鲁棒性。比如通过 SMTP 或者 NNTP 代理或者网关收发消息的情况。

所有 HTTP 日期时间戳必须表示为格林威治标准时间 GMT ，没有例外。为了用于 HTTP ，GMT 完全等价于 UTC ( 协调世界时间 )。这就表示在前两种时间格式中结尾的 GMT 是作为时区的缩写。当阅读标准时间格式时必须假定该时区。HTTP 时间是大小写敏感的，除了语法定义中的 SP 绝对不能包含多余的线性空白。

````xml
HTTP-date 		= rfc1123-date | rfc850-date | asctime-date
rfc1123-date 	= wkday "," SP date1 SP time SP "GMT"
rfc850-date 	= weekday "," SP date2 SP time SP "GMT"
asctime-date 	= wkday SP date3 SP time SP 4DIGIT
date1 			= 2DIGIT SP month SP 4DIGIT
				  ; day month year (e.g., 02 Jun 1982)
date2 			= 2DIGIT "-" month "-" 2DIGIT
				  ; day-month-year (e.g., 02-Jun-82)
date3 			= month SP ( 2DIGIT | ( SP 1DIGIT ))
				  ; month day (e.g., Jun 2)
time 			= 2DIGIT ":" 2DIGIT ":" 2DIGIT
 				  ; 00:00:00 - 23:59:59
wkday 			= "Mon" | "Tue" | "Wed"
				| "Thu" | "Fri" | "Sat" | "Sun"
weekday 		= "Monday" | "Tuesday" | "Wednesday"
				| "Thursday" | "Friday" | "Saturday" | "Sunday"
month 			= "Jan" | "Feb" | "Mar" | "Apr"
				| "May" | "Jun" | "Jul" | "Aug"
				| "Sep" | "Oct" | "Nov" | "Dec"
````

注意：HTTP 对时间格式的要求仅仅当时间用在协议数据流中时才起作用。客户端和服务器在进行用户数据展现或者请求日志记录时并不需要遵循此格式。

### 3.3.2 时差秒数

某些 HTTP 协议首部字段允许以十进制的整数秒数的形式表示从消息被接收到以来经过的时间：

````delta-seconds = 1*DIGIT````

## 3.4 字符集

HTTP 中使用的术语“字符集”定义与 MIME 中的描述一样。

术语“字符集”在此文档中用来表示一种方法，该方法基于一张或者若干张表将一个记号序列转化成为一个字符序列。注意，无条件的可逆转化不是必须的，因为在给定的字符集中并不是所有的字符都是可用的，同时，字符集可能会提供多个记号序列来表示同一个特定的字符。此定义试图允许多种字符编码，从诸如 US-ASCII 之类简单的单表映射到复杂的诸如 ISO-2022 中使用的表切换方法等技术。不过，此定义涉及到的 MIME 字符集名称必须仅仅表示应用与记号到字符的映射。特别地，使用额外的配置信息企图增加额外的映射是不允许的。

注意：术语“字符集”的使用相较于“字符编码”要更广泛。然而，由于 HTTP 和 MIME 共享了相同的注册，则当然也应该共享该术语。

HTTP 字符集表示为一系列大小写不敏感的记号。完整记号集合由 IANA 字符集注册定义。

````
charset = token
````

尽管 HTTP 允许字符集的值为任意记号，任何在 IANA 字符集注册中有预定义值的记号都必须表示该注册定义的字符集。应用应该限制它们对 IANA 注册中定义的字符集的使用。

实现者应该注意 IETF 字符集必要条件。

### 3.4.1 遗漏字符集

某些 HTTP 软件解释那些没有字符集参数的````Content-Type````首部字段时没有做到“参与者应该尽力猜测”。消息发送方希望防御这种行为的话，就可以而且应该在首部中包含明确的字符集参数，即使字符集就是 ISO-8859-1，这样就可以避免通信参与者的困惑。

不幸的是，某些老版本 HTTP/1.0 客户端却不能对明确的字符集参数进行正确处理。HTTP/1.1 参与者必须尊重消息发送方提供的字符集标签，那些拥有猜测字符集机制的用户代理在显示文档时必须使用````Content-Type````首部包含的字符集，如果它们支持该字符集，而不是参与者自身的喜好。

## 3.5 内容编码

内容编码值表示一种编码转换，已经被或者能够被应用于一个数据实体。内容编码主要用于允许文档被压缩或者进行其它有用的转化，但是不丢失其潜在的媒体类型名称，也不丢失任何信息。通常，数据实体以编码后的形式被存储，直接被传输，而只是被通信参与者解码。

````
content-coding = token
````

所有的内容编码值都是大小写不敏感的。HTTP/1.1 在````Accept-Encoding````和````Content-Encoding````首部字段中使用该值。尽管该值描述了内容编码，但是实际上更重要的是它表明了内容的解码机制。

因特网编号管理局 IANA 注册了内容编码值记号。最初，该注册信息包含了以下几种内容编码记号：

````gzip````

由文件压缩程序````gzip ( GNU zip )````产生的一种编码格式，在 RFC 1952 中描述。该搁置时一种 Lempel-Ziv 编码，同时经过了 32 位的 CRC 校验。

````compress````

此编码格式由通用的 UNIX 文件压缩程序 "compress" 产生，是一种自适应的 Lempel-Ziv-Welch 编码。

以程序名称作为编码格式的标识符并不合适，这些用法只是某些历史遗留，并不是好的设计。为了保持对早期版本的 HTTP 实现，应用应该将"x-gzip"和"x-compress"分别作为“gzip”和"compress"处理。

````deflate````

RFC 1950 定义的”zlib“格式与 RFC 1951 定义的“deflate”压缩机制相结合的产物。

````identity````

默认编码。表示没有进行任何转化。这种内容编码仅仅用于````Accept-Encoding````首部字段，而不应该用于````Content-Encoding````首部字段。

新的内容编码值记号都应该被注册，为了允许客户端和服务端之间的互操作性，实现一种新的内容编码值的内容编码算法规范需要公开并可以各自独立实现，还要符合本章节定义的内容编码目标。

## 3.6 传输编码

传输编码被用于表示一种编码转换，该转换已经被、能够被、或者可能需要被用于实体数据以保证在网络中进行所谓的“安全传输”。它与内容编码的区别在于，传输编码时消息的属性，而不是初始数据实体的属性。

````xml 
transfer-coding     = "chunked" | transfer-extension
transfer-extension  = token * ( ";" parameter )
````

参数表示为 参数/值 对形式。

````xml 
parameter  = attribute "=" value
attribute  = token
value      = token | quoted-string
````

所有的传输编码值都是大小写不敏感的。HTTP/1.1 使用传输编码值在````TE````首部字段和````Transfer-Encoding````首部字段中。

无论何时当传输编码被用于消息体，传输编码集合必须包含````chunked````，除非消息通过关闭连接被终止。当传输编码````chunked````被使用时，它必须是最后一个被应用于消息体的传输编码。该传输编码绝对不能对同一个消息体应用两次。这些规则允许通信参与者确定消息的传输长度。

传输编码类似于 MIME 的````Content-Transfer-Encoding````值，是设计来保证在一个7比特传输服务上进行二进制数据安全传输。然而，安全传输对纯净的8位传输协议来说有完全不同的关注点。在 HTTP 中，消息体中唯一的不安全特征就是很难确定消息体的准确长度，或者在共享传输中的数据加密需求。

因特网编码管理局作为传输编码值记号的注册机构。最初，注册的传输编码包括````chunked````、````identity````、````gzip````、````compress````和````deflate````。

新的传输编码值记号应该像新的内容编码值记号那样以同样的方式注册。

接收到实体主体的服务器，如果该数据的传输编码是它无法理解的，则应该返回501（未实现），然后关闭连接。服务器绝对不能发送传输编码给一个 HTTP/1.0 客户端。

### 3.6.1 分块传输编码

分块编码改变消息体，以分开序列形式传输它，每个分块都携带自己的尺寸指示器，跟随着一个可选的尾部包含实体首部字段。这就可以在传输的同时动态生成内容数据，同时数据携带必要的信息以使得通信参与者可以校验它们是否已经收到了完整的消息。

````xml
Chunked-Body	= *chunk
				  last-chunk
				  trailer
				  CRLF
chunk			= chunk-size [ chunk-extension ] CRLF
				  chunk-data CRLF
chunk-size		= 1*HEX
last-chunk		= 1*("0") [ chunk-extension ] CRLF

chunk-extension	= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
chunk-ext-name	= token
chunk-ext-val	= token | quoted-string
chunk-data		= chunk-size(OCTET)
trailer			= *(entiry-header CRLF)
````

````chunk-size````字段是一个十六进制数字字符串，表示数据分块的尺寸。分块编码过程当分块大小为0时就会结束，跟随着的尾部，由一个空行结束。

该尾部允许发送方在消息尾部包含额外的 HTTP 首部字段。````Trailer````首部字段可以被用于表示尾部包含的首部字段。

服务端在响应中使用分块传输编码时绝对不能对任何首部字段使用尾部，除非下列条件至少有一条是真的：

a. 请求中包含一个````TE````首部字段，表示````trailers````在响应的传输编码中是可接受的；

b. 该服务器是该响应的初始服务器，该尾部字段完全由可选的元数据组成，通信参与者可以在不接收该元数据的情况	下使用消息。换句话说，初始服务器可以接受该尾部字段可能在向客户端传输的路径上被静默地丢弃掉的可能性。

这种强制需求防止了当消息被一个 HTTP/1.1 或更高版本的代理然后转发给一个 HTTP/1.0 版本的通信参与者的情况下的互操作失败。它避免了一种情况，当遵循协议时可能会使得代理服务器上存在一个无限大小的缓冲区。

附录19.4.6中给出了一个````Chunked-Body````编码过程的例子。

所有的 HTTP/1.1 应用都必须能够接收和解码````chunked````传输编码，同时必须忽略它们无法理解的````chunk-extension````扩展。

## 3.7 媒体类型

HTTP 使用因特网媒体类型在````Content-Type````和````Accept````首部字段中，提供开放可扩展的数据类型和类型协商。

````xml
media-type	= type "/" subtype *( ";" parameter )
type		= token
subtype		= token
````

参数可以跟随类型或者子类型，以 属性/值 对的形式出现。

类型、子类型和参数属性名都是大小写敏感的。参数值可能是也可能不是大小写敏感的，取决于参数名称的语义。线性空白````LWS````绝对不能出现在类型和子类型之间，也不能出现在属性和它的值之间。一个参数的出现与否可能对媒体类型的处理过程意义重大，具体影响取决于它在媒体类型注册数据中的定义。

注意，一些老版本的 HTTP 应用并不认识媒体类型参数。向老版本 HTTP 应用发送数据时，发送方应该只有在类型或者子类型定义需要时才使用媒体类型参数。

媒体类型值注册在因特网编号管理局。媒体类型注册过程详见 RFC 1590 。不鼓励使用未注册的媒体类型。

### 3.7.1 标准化和默认文本

因特网媒体类型以标准化形式注册。通过 HTTP 消息传输的实体主体在传输之前必须以相应的标准化形式表示，除了下面将要提到的````text````类型。

当以标准化形式出现时，媒体类型````text````的子类型使用````CRLF````作为文本换行符。HTTP 放松了这个限制，允许传输用纯文本的````CR````或者````LF````单独作为换行符的文本媒体类型数据，当实体主体完全由该数据构成。HTTP 应用必须接受````CRLF````、````CR````或者````LF````作为换行符在通过 HTTP 接收到的文本媒体。另外，如果该文本是以并不是分别使用 13 和 10 表示````CR````和````LF````的字符集表示，就像使用一些多字节字符集的情形，HTTP 允许使用由该字符集定义的等价于````CR````和````LF````的任何字符序列表示换行符。这种换行符灵活性仅仅应用于实体主体中的文本媒体。在任何 HTTP 控制结构中单独的````CR````或者````LF````绝对不能替代````CRLF````，比如首部字段和多部分分隔符。

如果一个实体主体通过内容编码进行了编码，则其中的数据必须以上述格式被编码。

````charset````参数和某些媒体类型共同使用用来定义数据的字符集。如果发送方没有明确提供字符集参数，通过 HTTP 接受到的数据的媒体类型````text````的子类型被定义为拥有一个默认字符集值````ISO-8859-1````。默认字符集之外的数据，或者该字符集的子集都必须标明为适当的字符集值。通用性问题参见 3.4.1 章节。

### 3.7.2 多部分类型

MIME 提供了大量````multipart````类型，用来将一个或者多个实体封包进入单独一个消息体中。所有的多部分类型公用一种通用语法，定义在 RFC 2046 的 5.1.1 章节中，同时必须包含一个作为媒体类型值一部分的范围参数。消息体本身是一个协议元素，因而必须仅仅在消息体部分中使用````CRLF````来表示换行符。不像 RFC 2046 ，任何多部分消息的后记必须是空。HTTP 应用绝对不能传输消息后记，即使原始的多部分消息包含后记。这些限制存在的目的是保持多部分消息体的自定界特性，消息体的结尾由多部分边界来表示。

通常，HTTP 对待多部分消息体的方式与其它任何媒体类型没有什么不同，严格地称为有效载荷。一个例外是````multipart/byteranges````类型，当它出现在 206 部分内容 响应中，将被某些 HTTP 缓存机制解释，就像 13.5.4 章节和 14.16 章节中描述的那样。在所有其它情况下，HTTP 用户代理在接收到一个多部分类型的消息时应该遵循与 MIME 用户代理相同或者相似的行为。多部分消息主体的每个主体部分中包含的 MIME 首部字段对 HTTP 来说并没有它们在 MIME 语法中的定义之外的任何意义。

一般来说，HTTP 用户代理在接收到一个多部分类型的消息时应该遵循与 MIME 用户代理相同或者相似的行为。如果应用收到一个不认识的多部分子类型消息，它必须将该消息作为````multiparg/mixed````类型进行处理。

注意：````multipart/form-data````类型已经被专门定义为用于携带表单数据，因而适合用于通过````POST````请求方法提交表单数据，就像在 RFC 1867 中描述的那样。

## 3.8 产品标识

产品标识被相互通信的应用通过软件名称和版本来实现自我标识。大多数使用产品标识的字段也都可以同时使用子产品标识，该子产品构成了应用的主要部分，以空格分隔。方便起见，各个产品按照它们在标识应用中的重要性依次排列。

````xml
product			= token ["/" product-version]
product-version	= token
````

例子：

````xml
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
Server: Apache/0.8.4
````

产品标识应该简明扼要。它们不应该被用于广告或者其它非必要信息。尽管任何记号字符都可以出现在````product-version````中，该标识应该仅仅被用于版本标识（比如，同一个产品先行后继的版本应该仅仅在````product````值的````product-version````部分）。

## 3.9 质量值

HTTP 内容协商使用简短的浮点数字来表示不同协商参数的相对权重。权重值规范化为0到1之间的实数，0表示最小值，1表示最大值。如果一个参数的质量值为0，则拥有此参数的内容对客户端来说就是不可接受的。HTTP／1.1 应用绝对不能产生超过三位小数的质量值。该值的用户配置也应该遵循此限制。

````xml
qvalue		= ( "0" [ "." 0*3DIGIT ] )
			| ( "1" [ "." 0*3("0") ] )
````

质量值其实是一个误称，因为这些值仅仅表示期待中的质量的相对恶化程度。

## 3.10 语言标签

语言标签标示一种自然语言的读、写或者其它人类交流信息的方式。计算机语言是明确排除在外的。HTTP 使用语言标签在````Accept-language````和````Content-Language````首部字段中。

HTTP 语言标签的语法和注册信息定义在 RFC 1766 中。简单来说，一个语言标签由一个或者多个部分组成：一个主语言标签和一个可能存在的字标签序列。

````xml
language-tag	= primary-tag *( "-" subtag )
primary-tag		= 1*8ALPHA
subtag			= 1*8ALPHA
````

空格不允许出现在语言标签中，而且所有的语言标签都是大小写敏感的。语言标签的命名空间由因特网编号管理局管理。语言标签包含语言的例子：

````xml
en, en-US, en-cockney, i-cherokee, x-pig-latin
````

任何两字母的主语言标签都是一个 ISO-639 语言缩写，任何两字母初始字标签都是一个 ISO-3166 国家编码。上面最后3个标签是尚未注册的标签，但是除了最后一个标签，另外两个可能将来会被注册。

## 3.11 实体标签

实体标签用于比较来自相同请求资源的两个或者多个实体。HTTP/1.1 使用实体标签在````ETag````、````If-Match````、````If-None-Match````以及````If-Range````首部字段中。13.3.3 章节中描述了它们的使用和比较方法以及缓存验证等。实体标签由晦涩的引号字符串构成，可能由弱指示器开头。

````xml
entity-tag	= [ weak ] opaque-tag
weak		= "W/"
opaque-tag	= quoted-string
````

一个强实体标签可能被一个资源的两个实体共享，仅当它们是字节层面等价的。

一个弱实体标签，由````W/````前缀表示，可以被一个资源的两个实体共享，仅当它们是等价的，而且相互替换并不会对语义造成显著影响。弱实体标签只能被用于弱比较。

关于特定资源的所有版本的所有实体的实体标签必须都是唯一的。一个给定的实体标签值可以被用于从不同 URIs 的请求中获取的实体。关联到由不同 URIs 的请求中获取的实体的实体标签的值并不表示这些实体的等价性。