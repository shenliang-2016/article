# Hypertext Transfer Protocol -- HTTP/1.1

## 此备忘录状态

此文档为因特网通信指定了一个标准追踪协议，同时希望与大家讨论并得到建议以不断改进。请将 “因特网官方协议标准” 的当前版本作为本协议的状态和标准化状态。任何人都可以不受限制地分发此文档。

## 摘要

超文本传输协议 HTTP 是一个应用层协议，用于分布式、协作的、异构的信息系统。它是一个通用的、无状态的协议。通过扩展他的请求方法，错误码和协议首部，还可以完成超文本传输之外的更多其它任务。比如命名服务器和分布式对象管理系统等。HTTP 的一大特征就是类型和数据表示协商，这将允许相互传递数据的系统可以互不依赖地创建。

从1990年开始，HTTP 就已经被用于 World-Wide Web 全球信息系统。此规范定义的协议被称为 "HTTP/1.1" ，同时也是 RFC 2068 的升级版本。

# 目录

* 1 介绍

  * 1.1 目的

  * 1.2 需求
  * 1.3 术语
  * 1.4 整体运作

* 2 符号约定和一般语法
  * 2.1 扩展的 BNF
  * 2.2 基本规则

* 3 协议参数

  * 3.1 HTTP 版本
  * 3.2 统一资源标识符
    * 3.2.1 通用语法
    * 3.2.2 http URL
    * 3.2.3 URI 对比
  * 3.3 日期/时间格式
    * 3.3.1 完整日期
    * 3.3.2 时间差秒数
  * 3.4 字符集
    * 3.4.1 遗漏字符集
  * 3.5 内容编码
  * 3.6 传输编码
    * 3.6.1 分块传输编码
  * 3.7 媒体类型
    * 3.7.1 标准化和默认文本
    * 3.7.2 多中成分类型
  * 3.8 产品标识
  * 3.9 质量值
  * 3.10 语言标签
  * 3.11 实体标签
  * 3.12 范围单元

* 4 HTTP 消息

  * 4.1 消息类型
  * 4.2 消息首部
  * 4.3 消息体
  * 4.4 消息长度
  * 4.5 通用首部字段

* 5 请求

  * 5.1 请求行
    * 5.1.1 方法
    * 5.1.2 请求 URI
  * 5.2 由请求标识的资源
  * 5.3 请求首部字段

* 6 响应

  * 6.1 状态行
    * 6.1.1 状态码和原因信息
  * 6.2 响应首部字段

* 7 实体

  * 7.1 实体首部字段
  * 7.2 实体主体
    * 7.2.1 类型
    * 7.2.2 实体长度

* 8 连接

  * 8.1 持久化连接
    * 8.1.1 目的
    * 8.1.2 综述
    * 8.1.3 代理服务器
    * 8.1.4 现实考量
  * 8.2 信息传输需求
    * 8.2.1 持久化连接和流量控制
    * 8.2.2 为错误状态消息进行连接监控
    * 8.2.3 100 状态码使用
    * 8.2.4 服务端过早关闭连接时客户端行为

* 9 方法定义

  * 9.1 安全和幂等方法
    * 9.1.1 安全方法
    * 9.1.2 幂等方法
  * 9.2 OPTIONS
  * 9.3 GET
  * 9.4 HEAD
  * 9.5 POST
  * 9.6 PUT
  * 9.7 DELETE
  * 9.8 TRACE
  * 9.9 CONNECT

* 10 状态码定义

  * 10.1 信息 1xx
    * 10.1.1 100 继续
    * 10.1.2 101 切换协议
  * 10.2 成功 2xx
    * 10.2.1 200 OK
    * 10.2.2 201 创建
    * 10.2.3 202 接受
    * 10.2.4 203 无授权信息
    * 10.2.5 204 无内容
    * 10.2.6 205 重置内容
    * 10.2.7 206 部分内容
  * 10.3 重定向 3xx
    * 10.3.1 300 多种选择
    * 10.3.2 301 永久迁移
    * 10.3.3 302 找到
    * 10.3.4 303 看看别的
    * 10.3.5 304 没有修改
    * 10.3.6 305 使用代理
    * 10.3.7 306 （尚未使用）
    * 10.3.8 307 临时重定向
  * 10.4 客户端错误 4xx
    * 10.4.1 400 错误请求
    * 10.4.2 401 未授权
    * 10.4.3 402 需要支付
    * 10.4.4 403 禁止
    * 10.4.5 404 没有找到
    * 10.4.6 405 不允许的方法
    * 10.4.7 406 不可接受
    * 10.4.8 407 代理认证需求
    * 10.4.9 408 请求超时
    * 10.4.10 409 冲突
    * 10.4.11 410 过去的
    * 10.4.12 411 长度需求
    * 10.4.13 412 预处理失败
    * 10.4.14 413 请求体太大
    * 10.4.15 414 请求 URI 太长
    * 10.4.16 415 不支持的媒体类型
    * 10.4.17 416 请求范围不满足
    * 10.4.18 417 预期失败
  * 10.5 服务端错误 5xx
    * 10.5.1 500 服务器内部错误
    * 10.5.2 501 未实现
    * 10.5.3 502 网管错误
    * 10.5.4 503 服务不可用
    * 10.5.5 504 网关超时
    * 10.5.6 505 HTTP 版本不支持

* 11 访问认证

* 12 内容协商

  * 12.1 服务端驱动协商
  * 12.2 客户端驱动协商
  * 12.3 传输协商

* 13 HTTP 中的缓存

  * 13.1 缓存
    * 13.1.1 缓存正确性
    * 13.1.2 警告
    * 13.1.3 缓存控制机制
    * 13.1.4 显式用户端警告
    * 13.1.5 规则和警告异常
    * 13.1.6 客户端控制行为
  * 13.2 超时模型
    * 13.2.1 服务端指定超时
    * 13.2.2 启发式超时
    * 13.2.3 生存时间计算
    * 13.2.4 超时时间计算
    * 13.2.5 超时时间消除歧义性
    * 13.2.6 多个响应消除歧义性
  * 13.3 校验模型
    * 13.3.1 最近一次修改日期
    * 13.3.2 实体标签缓存校验器
    * 13.3.3 强校验器和弱校验器
    * 13.3.4 实体标签和最近修改日期使用时机规则
    * 13.3.5 条件性无校验
  * 13.4 响应可缓存性
  * 13.5 由缓存构建响应
    * 13.5.1 端到端首部和跳到跳首部
    * 13.5.2 不可修改的首部
    * 13.5.3 联合首部
    * 13.5.4 组合字节范围
  * 13.6 缓存协商的响应
  * 13.7 共享和非共享缓存
  * 13.8 错误或者不完整响应缓存行为
  * 13.9 GET 和 HEAD 的副作用
  * 13.10 升级或者删除后的实效
  * 13.11 强制写穿透
  * 13.12 缓存替换
  * 13.13 历史列表

* 14 首部字段定义

  * 14.1 Accept
  * 14.2 Accept-Charset
  * 14.3 Accept-Encoding
  * 14.4 Accept-Language
  * 14.5 Accept-Ranges
  * 14.6 Age
  * 14.7 Allow
  * 14.8 Authorization
  * 14.9 Cache-Control
    * 14.9.1 可缓存性是什么意思
    * 14.9.2 哪些数据可以被缓存
    * 14.9.3 基本的超时机制的修改
    * 14.9.4 缓存重校验和重新加载控制
    * 14.9.5 No-Transform 命令
    * 14.9.6 缓存控制扩展
  * 14.10 Connection
  * 14.11 Content-Encoding
  * 14.12 Content-Language
  * 14.13 Content-Length
  * 14.14 Content-Location
  * 14.15 Content-MD5
  * 14.16 Content-Range
  * 14.17 Content-Type
  * 14.18 Date
    * 14.18.1 无时钟的原始服务器操作
  * 14.19 ETag
  * 14.20 Expect
  * 14.21 Expires
  * 14.22 From
  * 14.23 Host
  * 14.24 If-Match
  * 14.25 If-Modified-Since
  * 14.26 If-None-Match
  * 14.27 If-Range
  * 14.28 If-Unmodified-Since
  * 14.29 Last-Modified
  * 14.30 Location
  * 14.31 Max-Forwards
  * 14.32 Pragma
  * 14.33 Proxy-Authenticate
  * 14.34 Proxy-Authorization
  * 14.35 Range
    * 14.35.1 Byte Ranges
    * 14.35.2 Range Retrieval Requests
  * 14.36 Referer
  * 14.37 Retry-After
  * 14.38 Server
  * 14.39 TE
  * 14.40 Trailer
  * 14.41 Transfer-Encoding
  * 14.42 Upgrade
  * 14.43 User-Agent
  * 14.44 Vary
  * 14.45 Via
  * 14.46 Warning
  * 14.47 WWW-Authenticate

* 15 安全考量

  * 15.1 个人信息
    * 15.1.1 服务端日志信息的滥用
    * 15.1.2 敏感信息传输
    * 15.1.3 将 URI 中的敏感信息编码
    * 15.1.4 隐私问题与 Accept Headers
  * 15.2 基于文件名和路径名的攻击
  * 15.3 DNS 欺骗
  * 15.4 位置首部和欺骗
  * 15.5 Content-Disposition 问题
  * 15.6 身份凭证和懒客户端
  * 15.7 代理和缓存
    * 15.7.1 代理上的拒绝服务攻击

# 1 介绍

## 1.1 目标

超文本传输协议 HTTP 是一个应用层协议，用于分布式异构协作信息系统。从1990年开始就已经被用于 World-Wide Web 全球信息系统。HTTP 的首个版本，称为 HTTP/0.9，是一个用于在因特网上传输原始数据的简单的协议。由 RFC 1945 定义的 HTTP/1.0 改进了该协议。它允许传输类 MIME 格式的消息，包含被传输数据的元信息以及请求/响应语义上的修饰词。然而，HTTP/1.0 并为充分考虑层级代理、缓存、持久化连接需求以及虚拟主机等因素的影响。更重要的是，随着越来越多的应用宣称它们支持 HTTP/1.0 的情况也使得更新协议版本成为必要。唯有如此，相互通信的应用才能确定对方真实的兼容性。

本规范定义的协议称为 HTTP/1.1 。此协议相比 HTTP/1.0 包含更多迫切需求，保证其宣称特性的可靠实现。

实用性的信息系统需要简单检索之外的更多功能，包括搜索、前端更新以及注解。HTTP 允许无限制的方法和首部集合用于表达请求目标。它构建在一系列规范基础之上，包括统一资源定位符、表示位置的 URL、表示名称的 URN，都用于表示请求方法将要应用于其上的资源。传递的消息格式类似于电子邮件，由多用途因特网邮件扩展 MIME 规范定义。

HTTP 也被作为通用协议用于用户代理程序与其它网路系统代理或者网关之间的通信。这些网路系统可能支持 SMTP、NNTP、FTP、Gopher 或者 WAIS 协议。这种情况下，HTTP 允许对各种应用中的可用资源进行超媒体访问。

## 1.2 必要条件

此文档中 "必须"、“必须不”、“需要”、“应该“、”不应该“、"推荐的"、“可以” 以及 “可选的” 等关键词的含义在 RFC 2119 中描述。

如果一个实现没能满足它所实现协议的一个或者多个 “必须” 或者 “需要” 级别的需求，则它就是不符合规范的。如果一个实现完全满足它所实现协议的所有 “必须” 或者 “需要” 级别需求，同时还有 “应该” 级别需求，则该实现就是所谓 “无条件符合” 协议规范的。如果一个实现完全满足它所实现协议的所有 “必须” 或者 “需要” 级别需求，但是不满足所有 “应该” 级别需求，则该实现就是所谓 “条件符合” 协议规范的。

## 1.3 术语

此规范使用一系列术语用于表示 HTTP 通信中相互通信的双方角色，以及相关对象。

连接：一个运输层虚拟回路，为了通信目的建立在两个程序之间。

消息：HTTP 通信的基本数据单元，由遵循第四章中定义的语法的结构化八位位组序列构成，通过连接传输。

请求：一个 HTTP 请求消息，在第五章中定义。

响应：一个 HTTP 响应消息，在第六章中定义。

资源：可以被一个 URI 定位的一个网路数据对象或者服务，在3.2章节定义。资源可以以多种表现形式和多种方式被访问。

实体：作为请求或者响应的载荷被传输的信息。一个实体由两部分构成，实体首部字段形式的元信息，实体主体形式的内容，就像第七章中描述的那样。

表现：响应包含的实体，受内容协商的支配，在12章中描述。关于一个特定响应状态可以存在多种表现。

内容协商：在服务一个请求时选择合适表现的机制，在12章中描述。任何响应中包含的实体表现都可以协商，包括错误响应。

变体：在任何给定时刻，一个资源可以有一种或者多种相关联的表现。每个此种表现有个术语 “变体” 表达。该术语的使用在描述受内容协商支配的资源时是不必要的。

客户端：以发送请求为目的而建立连接的程序。

用户代理：发起初始请求的客户端。通常是浏览器、编辑器、蜘蛛（网络遍历机器人）或者其它终端用户工具。

服务器：接受连接用于通过回送响应来服务请求的应用程序。任何给定程序可以同时觉有作为客户端和服务器的能力，我们私用这些术语表达某个特定连接中的程序的角色，而不是该程序的通用功能。同样的，任何服务器的行为可以是一个原始的服务器、代理、网关或者隧道，可以根据每个请求的具体特性随时切换行为。

原始服务器：提供所包含的资源或者由自身创建的资源的服务器。

代理：一个中间人程序，同时具有服务器和客户端的行为，代表其他客户端产生请求。请求被它们内部处理或者传递，同时进行可能的转换，给其他服务器。一个代理必须同时实现本规范要求的客户端和服务器特性。所谓的透明代理指的是除了必要的代理身份认证之外不对请求和响应进行任何修改的代理。相对的，不透明代理为了完成更过功能会对请求或者响应进行某些修改，比如群组注解服务、媒体类型转化、协议降级或者匿名过滤等。除了这两种行为明确说明的情况，HTTP 代理需求应用于这两种类型的代理。

网关：作为其它服务器中间人的服务器。与代理不同，网关就像原始服务器那样接收请求。发送请求的客户端可能都感觉不到它正在跟网关通信。

隧道：一个中间人程序用于在两个连接之前进行隐蔽传输。一旦激活，隧道就不会被认为是 HTTP 通信的一部分，尽管隧道可能本来就是由一个 HTTP 请求初始化的。当隐蔽传输两端的连接都被关闭时隧道也就不存在了。

缓存：一个程序中对响应消息的本地存储，以及控制它的消息存储、检索以及删除的子系统。缓存可以存储可缓存的响应以缩短随后相同请求的响应时间和网络带宽消耗。任何客户端或者服务器都可以包含缓存，但是作为隧道的服务器不能使用缓存。

可缓存性：一个响应是可缓存的，如果允许缓存存储响应消息的副本用于回应后续的请求。HTTP 响应的可缓存性规则在第13章中定义。即使一个资源是可缓存的，可能还有些附加的约束以确定缓存能否对特定请求使用缓存的响应数据副本。

第一手：一个响应是第一手的，如果它直接来自原始服务器，而没有被不必要地延误过，可能是通过一个或者多个代理服务器。如果响应的合法性只是直接被原始服务器验证过的响应同样也是第一手的。

明确的超时时间：原始服务器在该时间之后就认为实体不应该再继续从缓存中返回，而不需要进行更多的校验。

隐含的超时时间：当没有显式设置超时时间的情况下缓存默认配置的超时时间。

年龄：响应的年龄是从它被发送以来经历的时间，或者被原始服务器成功校验过以来经历的时间。

新鲜生存时间：响应产生到超时时间点之间的时间长度。

新鲜的：响应是新鲜的，如果它的年龄尚未超过它的新鲜生存时间。

陈旧的：响应是陈旧的，如果它的年龄已经超过了它的新鲜生存时间。

语义透明：缓存以 “语义透明” 的方式工作，对于特定的响应，当使用缓存时既不会影响发送请求的客户端，也不会影响原始服务器，除了对性能的改善。当一个缓存是语义透明的，客户端收到的响应与它发送的请求直接被原始服务器处理时返回的响应完全一样（除了逐跳首部）。

校验器：一个协议元素，比如实体标签或者最近修改时间，用于确认缓存实体是否确实是原始实体的全等副本。

上游/下游：描述消息流方向，所有的消息流都是从上游流向下游。

入/出：表示请求和响应的消息路径，“入” 表示 “消息向着原始服务器而来”，“出” 表示 “消息向着用户代理而去”。

## 1.4 整体运作

HTTP 协议是一个请求/响应协议。客户端以请求方法、URI、协议版本、连同一个包含请求修饰词、客户端信息以及可能的内容体的类 MIME 消息，通过连接向服务器发送一个请求。服务器响应携带一个状态行，包含消息协议版本和成功或者错误编码，连同一个包含服务器信息、实体元信息以及可能存在的实体主体内容的类 MIME 消息。HTTP 和 MIME 之间的关系在附录19.4中描述。

大部分 HTTP 通信都是由用户代理发起，由一个应用于原始服务器上的资源的请求组成。最简单的情况下，这个过程可以通过一个位于用户代理 UA 和原始服务器 O 之间的连接 v 完成。

````
    request chain  --------------------------------->
UA  -------------------------v---------------------->  O
    <--------------------------------  response chain
````

更复杂的情况，在请求/响应链上存在一个或者多个中间人。存在三种中间人形式：代理、网关和隧道。代理是一个转发代理，按照 URI 绝对形式接收请求，重写全部或者部分消息，然后将重新格式化后的请求转发给 URI 指定的服务器。网关是一个接收代理，工作在其他服务器更高的逻辑层次上，同时，如果有必要，转换请求为目标服务器协议。隧道时两个连接之间的隐蔽点，它不会改变消息。当通信必须通过某些中间人，比如防火墙，而该中间人无法理解消息内容的情况下，就可以使用隧道。

````
    request chain  --------------------------------------------->
UA  --------v-------A--------v-------B------v-----C------v------>  O
    <--------------------------------------------  response chain
````

上图展示了用户代理和原始服务器之间存在三个中间人的情况。一个请求或者响应消息需要穿过四个单独的连接才能通过整个链路。这种区别是很重要的，因为一些 HTTP 通信选项只能应用与跟最近的、无隧道的邻居之间的连接，或者只能应用于链路的端点，或者只能应用于链路上的所有连接。尽管上图是线性的，每个参与者可以参与多路并发的通信。比如，B 可能正在接收来自除了 A 之外多个客户端的请求，并且/或者向除了 C 之外的多个服务器转发请求，同时它还在处理 A 的请求。

以上通信过程中的任何部分，只要不是作为隧道，都可以采用内部缓存用于处理请求。缓存的作用是可能缩短图中的请求/响应链路，如果其中某个参与者缓存的响应数据匹配到了某个请求。下图展示了当 B 拥有早先通过 C 从原始服务器 O 获取的响应的缓存，而 UA 和 A 都没有缓存此响应时的结果链

````
    request chain  ----------------->
UA  --------v-------A--------v-------B------v-----C------v------>  O
    <----------------  response chain
````

不是所有响应都需要缓存，某些请求可能包含修饰词指定了对缓存行为的特殊需求。更多细节参见13章。

事实上，在目前的 World Wide Web 上存在多种多样的缓存和代理的体系结构和配置，有些还处于试验阶段。这些系统包含国家级的层级结构的代理缓存以节约跨海通信带宽，广播系统或者组播缓存入口，通过 CD-ROM 分发缓存数据的分布式组织，等等。HTTP 系统被用于通过高带宽链路来协同内联网，或者通过个人数字助手使用低能耗且不稳定的的广播链路访问数据。HTTP/1.1 的目标就是支持这种已经部署的宽泛的差异性系统，这些系统和协议同时被构建起来，协议始终追随 web 应用创建者的各种需求，比如，高可用需求，或者至少是可靠的失败提示。

HTTP 通信通常采用 TCP/IP 连接。默认端口是 TCP 80，但是也可以使用其他端口。并未阻止 HTTP 在任何其他因特网协议之上实现，或者在任何其他网络上实现。HTTP 仅仅预先假定了可靠传输，任何协议只要可以提供可靠传输保证即可被 HTTP 使用。HTTP/1.1 请求和响应数据结构映射到传输层协议数据单元不在此规范讨论范围。

在 HTTP/1.0 中，大多数实现都为每个请求/响应交互使用一个新的连接。在 HTTP/1.1 中，一个连接可以被用于一个或者多个请求/响应交互，尽管连接可能由于各种原因被关闭。

# 2 符号约定和一般语法

## 2.1 扩展的 BNF

本规范中所有的机制都被用自然语言和扩展的 BNF 两种形式同时描述，扩展的 BNF 类似于 RFC 822 中使用的那样。实现者们需要熟悉这种符号以便于理解本规范。扩展的 BNF 包含以下结构：

````name = definition````

​	规则的名称就是简单的名字本身，与它的定义以````=````分隔。空格只是在通过行首缩进表示规则定义延续到多行的情况下才是有意义的。某些基本规则都是大写字母命名，比如 SP、LWS、HT、CRLF、DIGIT、ALPHA 等等。尖括号被用在规则定义中为了便于识别出所使用的规则名称。

````"literal"````

​	引号标记包围的字面文本。除非特别规定，该文本是大小写敏感的。

````rule1 | rule2````

​	以竖线````|````分隔的元素是可供选择的，比如````yes | no````表示可接受````yes````或者````no````。

````(rule1 rule2)````

​	括号包围的多个元素被作为单一元素对待。因此````(elem (foo | bar) elem)````允许记号序列````elem foo elem````和````elem bar elem````。

````*rule````

​	元素之前的````*````号表示重复。完整的形式是````<n>*<m>element````表示元素出现最少````<n>````次最多````<m>````次。默认值是0和无限大，因此````*(element)````允许元素出现任意次，包含0次。````1*element````需要元素至少出现一次。````1*2element````允许元素出现一次或者两次。

````[rule]````

​	方括号包围的是可选元素。````[foo bar]````等价于````*1(foo bar)````。

````N rule````

​	指定元素重复出现次数。````<n>(element)````等价于````<n>*<n>(element)````，表示````(element)````精确出现````<n>````次。因此````2DIGIT````表示一个两位数字，````3ALPHA````表示三个字母字符的字符串。

````# rule````

​	````#````定义的结构类似于````*````，用于定义元素列表。其完整形式为````<n>#<m>element````，表示最少````<n>````个最多````<m>````个元素，元素之间由一个或者多个````,````字符或者可选的线性空白````LWS````分隔。这就可以很方便地表示列表。

如下规则：

​	````( *LWS element * ( * LWS "," *LWS element ))````

可以显示为：

​	````1#element````

使用此结构的地方，空元素是允许的，不过空元素并不会被算作一个存在的元素。也就是说，````(element),  , (element)````是允许的，但是只算是两个元素。因此，需要至少一个元素的地方，必须存在至少一个非空元素。基于默认值0和无限大````#element````允许任意数量的元素，包括0个。````1#element````需要至少一个元素，````1#2element````允许一个或者两个。

````; comment````

​	分号与右边的文字之间留一段距离，注释一直延续的该行末尾。这种方式可以很方便地为规范添加额外的有用说明信息。

````implied *LWS````

​	此语法在本规范中以基于词汇的方法描述。除非特别说明，线性空白````LWS````可以被包含在任何相邻的两个词汇之间，或者相邻的词汇和分隔符之间，而不会改变字段的含义。至少一个分隔符````LWS````或者````separators````必须出现在任意两个记号之间，以免它们被误以为是一个记号。

## 2.2 基本规则

下列规则贯穿整个规范文档，用于描述基本的语法结构。其中的 US-ASCII 编码字符集在 ANSI X3.4-1986 中定义。

````xml
OCTET		= <any 8-bit sequence of data>
CHAR		= <any US-ASCII character (octets 0-127)>
UPALPHA		= <any US-ASCII uppercase letter "A".."Z">
LOALPHA		= <any US-ASCII lowercase letter "a".."z">
ALPHA		= UPALPHA | LOALPHA
DIGIT		= <any US-ASCII digit "0".."9">
CTL			= <any US-ASCII control character (octets 0-31) and DEL (127)>
CR			= <US-ASCII CR, carriage return (13)>
LF			= <US-ASCII LF, linefeed (10)>
SP			= <US-ASCII SP, space (32)>
HT			= <US-ASCII HT, horizontal-tab (9)>
<''>		= <US-ASCII double-quote mark (34)>
````

HTTP/1.1 定义````CR LF````序列为除了实体主体之外所有协议元素的行结束标志。而实体主体的行结束标志取决于它对应的媒体类型，在3.7章节中介绍。

​	````CRLF	= CR LF````

HTTP/1.1 协议首部字段值当连续行以空格或者水平制表符开头时可以被折行。所有的线性空白，包括折行，都有相同语义````SP````。一个可取的方案是在将解读字段值或者将消息向下游转发之前将所有线性空白替换为单个````SP````。

​	````LWS		= [CRLF] 1*( SP | HT)````

````TEXT````规则仅仅被用来描述字段内容和值，这些内容和值不会被消息解析器解释。````*TEXT````可以包含 ISO-8859-1 字符集之外的字符，仅仅当它根据 RFC 2047 的规则进行编码时。

​	````TEXT	= <any OCTET except CTLs, but including LWS>````

CRLF 只有作为首部字段的连词符时才允许出现在 TEXT 定义中。例外的情况，用于折行的 LWS 在 TEXT 值被解释之前将被一个单一的 SP 替换。

十六进制的数字字符可以用在若干种协议元素中。

````xml
HEX	        = "A" | "B" | "C" | "D" | "E" | "F"   

			| "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
````

许多 HTTP/1.1 协议首部字段值由 LWS 或者其它特殊字符分隔的词语组成。这些特殊字符必须由引号包围，用于表示参数值。

````
token			= 1*<any CHAR except CTLs or separators>

separators		= "(" | ")" | "<" | ">" | "@"

				| "," | ";" | ":" | "\" | <">

				| "/" | "[" | "]" | "?" | "="

				| "{" | "}" | SP | HT`
````

一些 HTTP 首部字段都可以包含注释，用括号包围注释文本。注释仅仅允许用在包含````comment````作为字段值一部分的定义中。在其它所有字段中，括号都会被认为是字段值的一部分。

​	````comment	= "(" *( ctext | quoted-pair | comment ) ")"````

​	````ctext	= <any TEXT excluding "(" and ")">````

如果被双引号包围，则文本字符串会被当作单一一个词语。

​	````quoted-string	= ( <"> * ( qdtext | quoted-pair ) <"> )````

​	````qdtext		= <any TEXT except <">>````

反斜杠字符````\````可以被作为一个单字符引号机制，仅仅用在包围字符串和注释结构。

​	````quoted-pair		= "\" CHAR````

# 3 协议参数

## 3.1 HTTP 版本

HTTP 使用````<major>.<minor>````数字体系表示协议的版本。协议版本化策略目的是允许消息发送方说明消息格式和它自身理解后续 HTTP 通信的能力，而不是通过通信过程获取这些特性。附加消息组件不会影响通信行为，只是增加一些可扩展字段值，这种情况协议版本号不需要变化。当修改协议，添加特性在不改变通用消息解析算法前提下，添加消息语义和增加发送方附加能力时，````<minor>````数字需要增加。当协议消息格式发生变化时````<major>````值也需要增加。进一步解释参见 RFC 2145 。

HTTP 消息版本通过消息第一行中的````HTTP-Version````字段表示。

​	````HTTP-Version	= "HTTP" "/" 1*DIGIT "." 1*DIGIT````

注意这里的 major 和 minor 版本号必须被视为独立的整数，而且都可以增加任意整数数量。因此，HTTP/2.4 是比 HTTP/2.13 更低的版本号，而 HTTP/12.3 版本号更高。版本号开头的0必须被忽略，绝对不能被发送出去。

一个发送的请求或者响应消息中包含 HTTP/1.1 协议的````HTTP-Version````首部字段的应用必须是至少条件兼容与本规范的。至少条件兼容此规范的应用应该在它们的消息中使用 HTTP/1.1 协议的````HTTP-Version````首部字段，而且必须对所有不兼容 HTTP/1.0 协议的消息也这么做。关于何时发送指定````HTTP-Version````值的细节可以参考 RFC 2145 。

应用的 HTTP 版本是该应用至少条件兼容的 HTTP 协议规范版本。

代理和网关应用在转发那些协议版本与应用本身协议版本不一致的消息时需要当心。因为消息的协议版本表示的是发送者的协议处理能力，代理和网关绝对不能发送携带协议版本超过它们本来版本的消息。如果接收到高于自身支持协议版本的请求，代理或者网关必须要么将请求版本降级，要么响应一个错误，或者干脆切换到隧道模式。

自从 RFC 2068 发布以来，由于 HTTP/1.0 代理在互操作性方面被发现的问题，缓存代理必须、网关可以、隧道绝不能升级请求的版本到它们支持自身支持的更高协议版本。代理或者网关的响应必须与请求是同一个主要版本。

注意：HTTP 协议版本的切换可能牵涉到协议首部字段的修改需求，也可能被相关版本禁止。

## 3.2 统一资源标识符

URIs 已经以许多名称为人们熟知：WWW 地址、通用文件标识符、通用资源标识符等，最终演化成为统一资源定位符 URL 和统一资源名称 URN 的结合。在跟 HTTP 扯上关系之前，统一资源标识符知识简单地用名称、位置或者任何其他字符来标识资源的字符串而已。

### 3.2.1 通用语法

HTTP 中的 URIs 可以被表示为绝对路径形式或者相对于某些周知基本 URI 的相对路径形式，取决于它们所使用的上下文。两种形式的主要区别在于绝对 URIs 永远都会以一个后面跟着冒号的协议名称开头。更多有关 URI 语法定义的信息参见 RFC 2396 。本规范吸收了该规范中相关定义，诸如````URI-reference````、````absoluteURI````、````relativeURI````、````port````、````host````、````abs_path````、````rel_path````以及````authority````等。

HTTP 协议并没有对 URI 长度进行任何限制。服务器必须能够处理任何它所提供的资源对应的 URI，同时应该能够处理无限长度的 URIs ，如果它们提供了基于 GET 的接口服务，这种请求就有可能产生无限长度的 URIs。如果 URI 长度超过了服务器的处理能力，服务器应该返回 414 请求 URI 过长状态响应。

注意：服务器使用长度超过 255 字节的 URI 时要格外小心，因为一些老版本的客户端或者代理服务器的实现可能不能支持这样的长度。

### 3.2.2 http URL

HTTP 协议使用````http````体系来定位网络资源。本章节定义该体系特定的 http URLs 的语法和语义。

````http_URL = "http:" "//" host [ ":" port ] [ abs_path [ "?" query ] ]````

如果````port````是空或者没有给出，则假定使用 80 端口。上面表达式的语义是访问的资源正位于服务器上，在````host````主机的````port````端口上监听着 TCP 连接，同时指向该资源的````Request-URI````就是````abs_path````。根据 RFC 1900 应该尽可能避免在 URLs 中使用 IP 地址。如果 URL 中没有````abs_path````，则当被用作指向某资源的````Request-URI````时必须给定其值为````/````。如果代理接收到的主机名不是完整的全限定域名，它就可以将自己的域名添加到它接收到的主机名中。如果代理接收到的主机名是完整的全限定域名，则它绝对不能改变该主机名。

### 3.2.3 URI 对比

当比较两个 URIs 以确定它们是否匹配时，客户端应该使用大小写敏感的方式逐字符比较整个 URIs，不过存在以下例外：

* 对````URI-reference````来说端口号为空或者未给出等价于默认端口；
* 主机名比较必须是大小写不敏感的；
* 体系名称比较必须是大小写不敏感的；
* 空````abs_path````等价于值为````/````的````abs_path````。

不在保留字符集合或者不安全字符集中的其它字符都等价于它们各自的````"%" HEX HEX````编码。

例如，下面几个 URIs 都是等价的：

````
http://abc.com:80/~smith/home.html
http://ABC.com/%7Esmith/home.html
http://ABC.com:/%7Esmith/home.html
````

## 3.3 日期时间格式

### 3.3.1 完整日期

HTTP 应用传统上允许使用三种不同的格式表示日期和时间戳：

````xml
Sun, 06 Nov 1994 08:49:37 GMT	; RFC 822, updated by RFC 1123
Sunday, 06-Nov-94 08:49:37 GMT	; RFC 850, obsoleted by RFC 1036
Sun Nov 6 08:49:37 1994			; ANSI C's asctime() format
````

第一种格式被广泛作为互联网标准，表示为一个固定长度的子集，由 RFC 1123 定义。第二种格式应用也很广泛，但是它基于已经淘汰的 RFC 850 日期格式，缺少四位数字的年份表示。HTTP/1.1 客户端和服务器必须接受所有这三种日期时间格式，保证兼容 HTTP/1.0 。然而它们必须只产生 RFC 1123 格式的 HTTP 日期值用于协议首部字段。更多细节参见 19.3 章节。

注意：日期值的接收者被鼓励对接收来自非 HTTP 协议应用的日期值保持足够的鲁棒性。比如通过 SMTP 或者 NNTP 代理或者网关收发消息的情况。

所有 HTTP 日期时间戳必须表示为格林威治标准时间 GMT ，没有例外。为了用于 HTTP ，GMT 完全等价于 UTC ( 协调世界时间 )。这就表示在前两种时间格式中结尾的 GMT 是作为时区的缩写。当阅读标准时间格式时必须假定该时区。HTTP 时间是大小写敏感的，除了语法定义中的 SP 绝对不能包含多余的线性空白。

````xml
HTTP-date 		= rfc1123-date | rfc850-date | asctime-date
rfc1123-date 	= wkday "," SP date1 SP time SP "GMT"
rfc850-date 	= weekday "," SP date2 SP time SP "GMT"
asctime-date 	= wkday SP date3 SP time SP 4DIGIT
date1 			= 2DIGIT SP month SP 4DIGIT
				  ; day month year (e.g., 02 Jun 1982)
date2 			= 2DIGIT "-" month "-" 2DIGIT
				  ; day-month-year (e.g., 02-Jun-82)
date3 			= month SP ( 2DIGIT | ( SP 1DIGIT ))
				  ; month day (e.g., Jun 2)
time 			= 2DIGIT ":" 2DIGIT ":" 2DIGIT
 				  ; 00:00:00 - 23:59:59
wkday 			= "Mon" | "Tue" | "Wed"
				| "Thu" | "Fri" | "Sat" | "Sun"
weekday 		= "Monday" | "Tuesday" | "Wednesday"
				| "Thursday" | "Friday" | "Saturday" | "Sunday"
month 			= "Jan" | "Feb" | "Mar" | "Apr"
				| "May" | "Jun" | "Jul" | "Aug"
				| "Sep" | "Oct" | "Nov" | "Dec"
````

注意：HTTP 对时间格式的要求仅仅当时间用在协议数据流中时才起作用。客户端和服务器在进行用户数据展现或者请求日志记录时并不需要遵循此格式。

### 3.3.2 时差秒数

某些 HTTP 协议首部字段允许以十进制的整数秒数的形式表示从消息被接收到以来经过的时间：

````delta-seconds = 1*DIGIT````

## 3.4 字符集

HTTP 中使用的术语“字符集”定义与 MIME 中的描述一样。

术语“字符集”在此文档中用来表示一种方法，该方法基于一张或者若干张表将一个记号序列转化成为一个字符序列。注意，无条件的可逆转化不是必须的，因为在给定的字符集中并不是所有的字符都是可用的，同时，字符集可能会提供多个记号序列来表示同一个特定的字符。此定义试图允许多种字符编码，从诸如 US-ASCII 之类简单的单表映射到复杂的诸如 ISO-2022 中使用的表切换方法等技术。不过，此定义涉及到的 MIME 字符集名称必须仅仅表示应用与记号到字符的映射。特别地，使用额外的配置信息企图增加额外的映射是不允许的。

注意：术语“字符集”的使用相较于“字符编码”要更广泛。然而，由于 HTTP 和 MIME 共享了相同的注册，则当然也应该共享该术语。

HTTP 字符集表示为一系列大小写不敏感的记号。完整记号集合由 IANA 字符集注册定义。

````
charset = token
````

尽管 HTTP 允许字符集的值为任意记号，任何在 IANA 字符集注册中有预定义值的记号都必须表示该注册定义的字符集。应用应该限制它们对 IANA 注册中定义的字符集的使用。

实现者应该注意 IETF 字符集必要条件。

### 3.4.1 遗漏字符集

某些 HTTP 软件解释那些没有字符集参数的````Content-Type````首部字段时没有做到“参与者应该尽力猜测”。消息发送方希望防御这种行为的话，就可以而且应该在首部中包含明确的字符集参数，即使字符集就是 ISO-8859-1，这样就可以避免通信参与者的困惑。

不幸的是，某些老版本 HTTP/1.0 客户端却不能对明确的字符集参数进行正确处理。HTTP/1.1 参与者必须尊重消息发送方提供的字符集标签，那些拥有猜测字符集机制的用户代理在显示文档时必须使用````Content-Type````首部包含的字符集，如果它们支持该字符集，而不是参与者自身的喜好。

## 3.5 内容编码

内容编码值表示一种编码转换，已经被或者能够被应用于一个数据实体。内容编码主要用于允许文档被压缩或者进行其它有用的转化，但是不丢失其潜在的媒体类型名称，也不丢失任何信息。通常，数据实体以编码后的形式被存储，直接被传输，而只是被通信参与者解码。

````
content-coding = token
````

所有的内容编码值都是大小写不敏感的。HTTP/1.1 在````Accept-Encoding````和````Content-Encoding````首部字段中使用该值。尽管该值描述了内容编码，但是实际上更重要的是它表明了内容的解码机制。

因特网编号管理局 IANA 注册了内容编码值记号。最初，该注册信息包含了以下几种内容编码记号：

````gzip````

由文件压缩程序````gzip ( GNU zip )````产生的一种编码格式，在 RFC 1952 中描述。该搁置时一种 Lempel-Ziv 编码，同时经过了 32 位的 CRC 校验。

````compress````

此编码格式由通用的 UNIX 文件压缩程序 "compress" 产生，是一种自适应的 Lempel-Ziv-Welch 编码。

以程序名称作为编码格式的标识符并不合适，这些用法只是某些历史遗留，并不是好的设计。为了保持对早期版本的 HTTP 实现，应用应该将"x-gzip"和"x-compress"分别作为“gzip”和"compress"处理。

````deflate````

RFC 1950 定义的”zlib“格式与 RFC 1951 定义的“deflate”压缩机制相结合的产物。

````identity````

默认编码。表示没有进行任何转化。这种内容编码仅仅用于````Accept-Encoding````首部字段，而不应该用于````Content-Encoding````首部字段。

新的内容编码值记号都应该被注册，为了允许客户端和服务端之间的互操作性，实现一种新的内容编码值的内容编码算法规范需要公开并可以各自独立实现，还要符合本章节定义的内容编码目标。

## 3.6 传输编码

传输编码被用于表示一种编码转换，该转换已经被、能够被、或者可能需要被用于实体数据以保证在网络中进行所谓的“安全传输”。它与内容编码的区别在于，传输编码时消息的属性，而不是初始数据实体的属性。

````xml 
transfer-coding     = "chunked" | transfer-extension
transfer-extension  = token * ( ";" parameter )
````

参数表示为 参数/值 对形式。

````xml 
parameter  = attribute "=" value
attribute  = token
value      = token | quoted-string
````

所有的传输编码值都是大小写不敏感的。HTTP/1.1 使用传输编码值在````TE````首部字段和````Transfer-Encoding````首部字段中。

无论何时当传输编码被用于消息体，传输编码集合必须包含````chunked````，除非消息通过关闭连接被终止。当传输编码````chunked````被使用时，它必须是最后一个被应用于消息体的传输编码。该传输编码绝对不能对同一个消息体应用两次。这些规则允许通信参与者确定消息的传输长度。

传输编码类似于 MIME 的````Content-Transfer-Encoding````值，是设计来保证在一个7比特传输服务上进行二进制数据安全传输。然而，安全传输对纯净的8位传输协议来说有完全不同的关注点。在 HTTP 中，消息体中唯一的不安全特征就是很难确定消息体的准确长度，或者在共享传输中的数据加密需求。

因特网编码管理局作为传输编码值记号的注册机构。最初，注册的传输编码包括````chunked````、````identity````、````gzip````、````compress````和````deflate````。

新的传输编码值记号应该像新的内容编码值记号那样以同样的方式注册。

接收到实体主体的服务器，如果该数据的传输编码是它无法理解的，则应该返回501（未实现），然后关闭连接。服务器绝对不能发送传输编码给一个 HTTP/1.0 客户端。

### 3.6.1 分块传输编码

分块编码改变消息体，以分开序列形式传输它，每个分块都携带自己的尺寸指示器，跟随着一个可选的尾部包含实体首部字段。这就可以在传输的同时动态生成内容数据，同时数据携带必要的信息以使得通信参与者可以校验它们是否已经收到了完整的消息。

````xml
Chunked-Body	= *chunk
				  last-chunk
				  trailer
				  CRLF
chunk			= chunk-size [ chunk-extension ] CRLF
				  chunk-data CRLF
chunk-size		= 1*HEX
last-chunk		= 1*("0") [ chunk-extension ] CRLF

chunk-extension	= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
chunk-ext-name	= token
chunk-ext-val	= token | quoted-string
chunk-data		= chunk-size(OCTET)
trailer			= *(entiry-header CRLF)
````

````chunk-size````字段是一个十六进制数字字符串，表示数据分块的尺寸。分块编码过程当分块大小为0时就会结束，跟随着的尾部，由一个空行结束。

该尾部允许发送方在消息尾部包含额外的 HTTP 首部字段。````Trailer````首部字段可以被用于表示尾部包含的首部字段。

服务端在响应中使用分块传输编码时绝对不能对任何首部字段使用尾部，除非下列条件至少有一条是真的：

a. 请求中包含一个````TE````首部字段，表示````trailers````在响应的传输编码中是可接受的；

b. 该服务器是该响应的初始服务器，该尾部字段完全由可选的元数据组成，通信参与者可以在不接收该元数据的情况	下使用消息。换句话说，初始服务器可以接受该尾部字段可能在向客户端传输的路径上被静默地丢弃掉的可能性。

这种强制需求防止了当消息被一个 HTTP/1.1 或更高版本的代理然后转发给一个 HTTP/1.0 版本的通信参与者的情况下的互操作失败。它避免了一种情况，当遵循协议时可能会使得代理服务器上存在一个无限大小的缓冲区。

附录19.4.6中给出了一个````Chunked-Body````编码过程的例子。

所有的 HTTP/1.1 应用都必须能够接收和解码````chunked````传输编码，同时必须忽略它们无法理解的````chunk-extension````扩展。

## 3.7 媒体类型

HTTP 使用因特网媒体类型在````Content-Type````和````Accept````首部字段中，提供开放可扩展的数据类型和类型协商。

````xml
media-type	= type "/" subtype *( ";" parameter )
type		= token
subtype		= token
````

参数可以跟随类型或者子类型，以 属性/值 对的形式出现。

类型、子类型和参数属性名都是大小写敏感的。参数值可能是也可能不是大小写敏感的，取决于参数名称的语义。线性空白````LWS````绝对不能出现在类型和子类型之间，也不能出现在属性和它的值之间。一个参数的出现与否可能对媒体类型的处理过程意义重大，具体影响取决于它在媒体类型注册数据中的定义。

注意，一些老版本的 HTTP 应用并不认识媒体类型参数。向老版本 HTTP 应用发送数据时，发送方应该只有在类型或者子类型定义需要时才使用媒体类型参数。

媒体类型值注册在因特网编号管理局。媒体类型注册过程详见 RFC 1590 。不鼓励使用未注册的媒体类型。

### 3.7.1 标准化和默认文本

因特网媒体类型以标准化形式注册。通过 HTTP 消息传输的实体主体在传输之前必须以相应的标准化形式表示，除了下面将要提到的````text````类型。

当以标准化形式出现时，媒体类型````text````的子类型使用````CRLF````作为文本换行符。HTTP 放松了这个限制，允许传输用纯文本的````CR````或者````LF````单独作为换行符的文本媒体类型数据，当实体主体完全由该数据构成。HTTP 应用必须接受````CRLF````、````CR````或者````LF````作为换行符在通过 HTTP 接收到的文本媒体。另外，如果该文本是以并不是分别使用 13 和 10 表示````CR````和````LF````的字符集表示，就像使用一些多字节字符集的情形，HTTP 允许使用由该字符集定义的等价于````CR````和````LF````的任何字符序列表示换行符。这种换行符灵活性仅仅应用于实体主体中的文本媒体。在任何 HTTP 控制结构中单独的````CR````或者````LF````绝对不能替代````CRLF````，比如首部字段和多部分分隔符。

如果一个实体主体通过内容编码进行了编码，则其中的数据必须以上述格式被编码。

````charset````参数和某些媒体类型共同使用用来定义数据的字符集。如果发送方没有明确提供字符集参数，通过 HTTP 接受到的数据的媒体类型````text````的子类型被定义为拥有一个默认字符集值````ISO-8859-1````。默认字符集之外的数据，或者该字符集的子集都必须标明为适当的字符集值。通用性问题参见 3.4.1 章节。

### 3.7.2 多部分类型

MIME 提供了大量````multipart````类型，用来将一个或者多个实体封包进入单独一个消息体中。所有的多部分类型公用一种通用语法，定义在 RFC 2046 的 5.1.1 章节中，同时必须包含一个作为媒体类型值一部分的范围参数。消息体本身是一个协议元素，因而必须仅仅在消息体部分中使用````CRLF````来表示换行符。不像 RFC 2046 ，任何多部分消息的后记必须是空。HTTP 应用绝对不能传输消息后记，即使原始的多部分消息包含后记。这些限制存在的目的是保持多部分消息体的自定界特性，消息体的结尾由多部分边界来表示。

通常，HTTP 对待多部分消息体的方式与其它任何媒体类型没有什么不同，严格地称为有效载荷。一个例外是````multipart/byteranges````类型，当它出现在 206 部分内容 响应中，将被某些 HTTP 缓存机制解释，就像 13.5.4 章节和 14.16 章节中描述的那样。在所有其它情况下，HTTP 用户代理在接收到一个多部分类型的消息时应该遵循与 MIME 用户代理相同或者相似的行为。多部分消息主体的每个主体部分中包含的 MIME 首部字段对 HTTP 来说并没有它们在 MIME 语法中的定义之外的任何意义。

一般来说，HTTP 用户代理在接收到一个多部分类型的消息时应该遵循与 MIME 用户代理相同或者相似的行为。如果应用收到一个不认识的多部分子类型消息，它必须将该消息作为````multiparg/mixed````类型进行处理。

注意：````multipart/form-data````类型已经被专门定义为用于携带表单数据，因而适合用于通过````POST````请求方法提交表单数据，就像在 RFC 1867 中描述的那样。

## 3.8 产品标识

产品标识被相互通信的应用通过软件名称和版本来实现自我标识。大多数使用产品标识的字段也都可以同时使用子产品标识，该子产品构成了应用的主要部分，以空格分隔。方便起见，各个产品按照它们在标识应用中的重要性依次排列。

````xml
product			= token ["/" product-version]
product-version	= token
````

例子：

````xml
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
Server: Apache/0.8.4
````

产品标识应该简明扼要。它们不应该被用于广告或者其它非必要信息。尽管任何记号字符都可以出现在````product-version````中，该标识应该仅仅被用于版本标识（比如，同一个产品先行后继的版本应该仅仅在````product````值的````product-version````部分）。

## 3.9 质量值

HTTP 内容协商使用简短的浮点数字来表示不同协商参数的相对权重。权重值规范化为0到1之间的实数，0表示最小值，1表示最大值。如果一个参数的质量值为0，则拥有此参数的内容对客户端来说就是不可接受的。HTTP／1.1 应用绝对不能产生超过三位小数的质量值。该值的用户配置也应该遵循此限制。

````xml
qvalue		= ( "0" [ "." 0*3DIGIT ] )
			| ( "1" [ "." 0*3("0") ] )
````

质量值其实是一个误称，因为这些值仅仅表示期待中的质量的相对恶化程度。

## 3.10 语言标签

语言标签标示一种自然语言的读、写或者其它人类交流信息的方式。计算机语言是明确排除在外的。HTTP 使用语言标签在````Accept-language````和````Content-Language````首部字段中。

HTTP 语言标签的语法和注册信息定义在 RFC 1766 中。简单来说，一个语言标签由一个或者多个部分组成：一个主语言标签和一个可能存在的字标签序列。

````xml
language-tag	= primary-tag *( "-" subtag )
primary-tag		= 1*8ALPHA
subtag			= 1*8ALPHA
````

空格不允许出现在语言标签中，而且所有的语言标签都是大小写敏感的。语言标签的命名空间由因特网编号管理局管理。语言标签包含语言的例子：

````xml
en, en-US, en-cockney, i-cherokee, x-pig-latin
````

任何两字母的主语言标签都是一个 ISO-639 语言缩写，任何两字母初始字标签都是一个 ISO-3166 国家编码。上面最后3个标签是尚未注册的标签，但是除了最后一个标签，另外两个可能将来会被注册。

## 3.11 实体标签

实体标签用于比较来自相同请求资源的两个或者多个实体。HTTP/1.1 使用实体标签在````ETag````、````If-Match````、````If-None-Match````以及````If-Range````首部字段中。13.3.3 章节中描述了它们的使用和比较方法以及缓存验证等。实体标签由晦涩的引号字符串构成，可能由弱指示器开头。

````xml
entity-tag	= [ weak ] opaque-tag
weak		= "W/"
opaque-tag	= quoted-string
````

一个强实体标签可能被一个资源的两个实体共享，仅当它们是字节层面等价的。

一个弱实体标签，由````W/````前缀表示，可以被一个资源的两个实体共享，仅当它们是等价的，而且相互替换并不会对语义造成显著影响。弱实体标签只能被用于弱比较。

关于特定资源的所有版本的所有实体的实体标签必须都是唯一的。一个给定的实体标签值可以被用于从不同 URIs 的请求中获取的实体。关联到由不同 URIs 的请求中获取的实体的实体标签的值并不表示这些实体的等价性。

## 3.12 范围单位

HTTP/1.1 允许客户端仅仅请求响应中包含的响应数据实体的一部分（一个范围内的数据）。HTTP/1.1 使用范围单位在````Range````和````Content-Range````首部字段。一个实体可以基于各种结构化单位被分割成若干子范围数据。

````xml
range-unit			= bytes-unit | other-range-unit
bytes-unit			= "bytes"
other-range-unit	= token
````

HTTP/1.1 只定义了一个范围单位````bytes````。HTTP/1.1 协议实现可以忽略使用其它单位指定的范围。HTTP/1.1 已经被设计成为允许实现和应用不依赖有关范围的知识也能正常工作。

# 4 HTTP 消息

## 4.1 消息类型

HTTP 消息包括客户端向服务端发送的请求和服务端向客户端发送的响应。

````xml
HTTP-message	= Request | Response	; HTTP/1.1 messages
````

````Request````和````Response````消息使用 RFC 822 中的一般消息格式来传输数据实体，也就是消息的有效载荷。两种类型的消息都由几部分组成，一个开始行，0个或者更多首部字段（众所周知的````headers````），一个空行表示首部字段的结束，可能还有一个消息体。

````xml
generic-message	= start-line
				  *(message-header CRLF)
				  CRLF
				  [ message-body ]
start-line		= Request-Line | Status-Line
````

为了保证鲁棒性，服务端在希望出现````Request-Line````的地方应该忽略接收到的任何空白行。换句话说，如果服务端正在读取协议数据流以获取消息开始位置，但是却先收到了````CRLF````，则必须忽略这些````CRLF````。

某些特殊的 HTTP/1.0 版本的客户端实现会产生额外的````CRLF````在一个````POST````请求之后。为了重申 BNF 明确禁止的行为，HTTP/1.1 客户端绝对不能在一个请求的前后附带任何多余的````CRLF````。

## 4.2 消息头

HTTP 首部字段，包括一般首部，请求首部，响应首部以及实体首部字段，遵循相同的在 RFC 822 中给出的通用格式。每个首部字段由名称和随后的冒号以及最后的字段值组成。字段名是大小写敏感的。字段名可以以任何数量的````LWS````开头，但是推荐使用单个的````SP````。首部字段可以被扩展到多行，只要每个额外的行都以至少一个````SP````或者````HT````开头。应用应该遵循普遍形式，也就是众所周知的，当产生 HTTP 数据结构时，因为可能存在一些实现不能接收普遍形式之外的任何东西。

````xml
message-header	= field-name ":" [ field-value ]
field-name		= token
field-value		= *( field-content | LWS )
field-content	= <the OCTETs making up the field-value
                  and consisting of either *TEXT or combinations
                  of token, separatores, and quoted-string>
````

````field-content````不包含任何头部和尾部````LWS````，也就是说，不能有线性空白出现在````field-value````的首个非空白字符之前，或者最后一个非空白字符之后。此类````LWS````会在不改变字段值语义的前提下被移除。任何出现的````field-content````中间的线性空白都会在解释字段值或者消息被转发到下游之前被替换成单个的````SP````。

不同字段名的首部字段被接收的顺序是没什么意义的。然而，所谓的最佳实践是，首先发送通用首部字段，然后是请求首部或者响应首部字段，最后发送实体首部字段。

具有相同````field-name````的多部分消息首部字段可以同时出现在消息里，当且仅当这些首部字段的整体````field-value````被定义为括号分隔的列表````# (values)````的形式。必须可以将多个首部字段集合进一个````field-nam: field-value````对中，而不影响消息的语义，通过依次将各个````field-value````以逗号连接起来。同名首部字段的接收顺序对理解这种集合之后的字段值就是非常重要的。因此，在转发消息时代理绝对不能改变这些字段值的顺序。

## 4.3 消息体

HTTP 消息的消息体（如果存在）就是用来装载请求或者响应的实体主体的。消息体只有在进行了传输编码之后才会跟实体主体产生差异，就像````Transfer-Encoding````首部字段表示的那样。

````xml
message-body	= entity-body | <entity-body encoded as per Transfer-Encoding>
````

````Transfer-Encoding````必须用于表示任何应用所使用的传输编码，以保证消息的安全传输。````Transfer-Encoding````是消息的一个属性，而不是实体的。因此可以被应用在请求/响应链上添加或者删除。（然而，3.6章节却添加了某些传输编码应用的限制条件。）

消息体何时能够出现在消息里的规则对请求和响应有所不同。

请求中存在消息体通过在请求消息首部中包含````Content-Length````或者````Transfer-Encoding````首部字段来表示。消息体绝对不能被包含在请求中，如果请求方法的规范不允许通过请求发送实体主体。服务端应该读取并转发任何请求中的消息体。如果请求方法没有定义的包含实体主体的语义，则消息体在请求处理过程中就应该被忽略。

对响应消息来说，是否包含消息体取决于请求方法和响应状态码。所有 HEAD 请求方法的响应绝对不能包含消息体，即使实体首部字段可能误导人们相信消息体存在。所有的````1xx````，````204````，````304````状态码响应绝对不能包含消息体。所有其它响应就可以包含消息体，虽然消息体长度可能是0。

## 4.4 消息长度

消息的传输长度就是消息体出现在消息中的长度。也就是说，是经过任何传输编码处理之后的长度。当一个消息体被包含在消息中时，传输长度取决于以下规则，按照优先级排序：

1. 任何绝对不能包含消息体的响应消息永远都要以首部字段之后的首个空行结束，无论实体首部字段是否出现在消息中。
2. 如果一个````Transfer-Encoding````首部字段存在，而且其值不是````identity````，则传输长度就是通过使用````chunked````传输编码定义，除非消息通过关闭连接来终结。
3. 如果````Content-Length````首部字段存在，则它的数字值就同时表示实体长度和传输长度。该首部字段绝对不能被发送，如果其中两个长度不相同（如果````Transfer-Encoding````首部字段存在）。如果接收到的消息同时包含````Transfer-Encoding````和````Content-Length````首部字段，则后者必须被忽略。
4. 如果消息使用媒体类型````multipart/byteranges````，而且没有另外指定传输长度，则这种自定界媒体类型会自行定义传输长度。除非发送方知道消息接收方可以解析它，否则这种媒体类型绝对不能使用。````Range````首部字段和多种字节范围指定器同时出现在来自 HTTP/1.1 版本的客户端的请求中暗示该客户端能够解析````multipart/byteranges````响应。````Range````首部字段可以被 HTTP/1.0 版本的代理服务器转发，尽管代理并不理解````multipart/byteranges````，这种情况下，服务端必须使用规则1、规则3或者规则5为消息定界。
5. 当服务端关闭连接时。（关闭连接不能别用于表示请求体的结束，因为这样做服务端就没办法将响应发送回来了。）

为了兼容 HTTP/1.0 应用，包含消息体的 HTTP/1.1 请求必须包含一个有效的````Content-Length````首部字段，除非服务端是明确的兼容 HTTP/1.1 。如果包含消息体的请求没有给定````Content-Length````，则如果服务端无法确定消息长度就应该返回 400 （错误请求）响应，或者如果服务端坚持希望接收到合法的````Content-Length````，那它可以返回 411（需要长度）响应。

所有的 HTTP/1.1 应用都必须接受分片的传输编码，当消息长度无法事先确定时就可以将此机制使用于消息。

消息绝对不能同时包含````Content-Length````首部字段和非同一性的传输编码。如果消息包含了非同一性传输编码，则````Content-Length````必须被忽略。

当允许包含消息体的消息携带了````Content-Length````首部字段，其值必须精确等于消息体中的记号数量。HTTP/1.1 用户代理在接收并检测到不合法的消息长度时必须通知用户。

## 4.5 通用首部字段

有些使用于请求和响应消息的首部字段，并不应用于被传输的数据实体。这些首部字段仅仅适用于正在被传输的消息。

````xml
general-header = Cache-Control		; Section 14.9
				| Connection		; Section 14.10
				| Date				; Section 14.18
				| Pragma			; Section 14.32
				| Trailer			; Section 14.40
				| Transfer-Encoding	; Section 14.41
				| Upgrade			; Section 14.42
				| Via				; Section 14.45
				| Warning			; Section 14.46
````

随着协议版本的变化通用首部字段名称可以被可靠地扩展。然而，新的或者实验性的受字段可以被赋予通用首部字段语义，如果通信中的所有参与者都将其公认为通用首部字段。不认识的首部字段会被认为是实体首部字段。

# 5 请求

被由客户端发往服务端的请求消息包含，作为消息的第一行，将要作用于资源上的方法，资源的定位符以及所使用的协议版本。

````xml
Request		= Request-Line			; Section 5.1
			 *(( general-header		; Section 4.5
			| request-header		; Section 5.3
			| entity-header ) CRLF)	; Section 7.1
			CRLF
			[ message-body ]		; Section 4.3
````

## 5.1 请求行

````Request-Line````以一个方法记号开头，随后是````Request-URI````和协议版本，以````CRLF````结尾。这些元素以````SP````字符分隔。除非是结尾的````CRLF````，否则这里不允许出现任何````CR````或者````LF````字符。

````xml
Request-Line	= Method SP Request-URI SP HTTP-Version CRLF
````

### 5.1.1 方法

````Method````记号表示在````Request-URI````指定的资源上执行的方法。该方法记号是大小写敏感的。

````xml
Method		= "OPTIONS"			; Section 9.2
			| "GET"				; Section 9.3
			| "HEAD"			; Section 9.4
			| "POST"			; Section 9.5
			| "PUT"				; Section 9.6
			| "DELETE"			; Section 9.7
			| "TRACE"			; Section 9.8
			| "CONNECT"			; Section 9.9
			| extension-method
extension-method = token
````

资源允许的方法列表可以在一个````Allow````首部字段中指定。响应的状态码始终需要通知客户端当前的方法是否允许被应用于资源，因为允许的方法集合是会动态变化的。一个初始服务器应该返回状态码 405 （方法不被允许），如果初始服务器理解该方法，但是并不被请求的资源允许。如果初始服务器不认识或者并未实现方法，则初始服务器应该返回 501 （未实现）。````GET````和````HEAD````方法必须被所有通用服务器支持。其它所有方法的支持都是可选的。然而，如果上述方法已经被实现，则它们必须被严格按照第 9 章中定义的语义实现。

### 5.1.2 请求 URI

````Request-URI````是一个统一资源定位符，用来标识请求将要作用于其上的资源。

````xml
Request-URI		= "*" | absoluteURI | abs_path | authority
````

````Request-URI````的四个选项取决于请求的自身特性。其中的星号````*````表示该请求不会被应用到某个特定资源，而是应用于服务器自身，只有当使用的请求方法不需要应用于某个资源时才允许这样。下面是一个例子：

````xml
OPTIONS * HTTP/1.1
````

当请求是发往代理服务器时````absoluteURI````形式是必须的。代理服务器被要求基于一个合法的缓存转发或者服务该请求，然后返回响应。注意，代理服务器可以转发该请求到另一个代理服务器或者直接到````absoluteURI````指定的服务器。为了避免循环请求，代理服务器必须能够识别所有的服务器名称，包括所有的别名，局部变量，以及数字 IP 地址。````Request-Line````的例子：

````xml
GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
````

为了保证在后续版本的 HTTP 协议请求中都能传输````absoluteURI````，所有的 HTTP/1.1 服务器必须接受请求中的````absoluteURI````形式，尽管 HTTP/1.1 客户端并不会在发往代理服务器的请求中产生它。

````authority````仅仅能够被 CONNECT 方法使用。

最普通的````Request-Line````形式就是用于定位一个位于初始服务器或者网关上的资源。这种情况下该 URI 的绝对路径必须被作为````Request-URI````被发送，URI 的网络位置必须在一个````Host````首部字段中被传输。比如，希望直接从初始服务器获取上述资源的客户端会创建一个 TCP 连接到主机````www.w3.org````的 80 端口，然后发送下面一行：

````xml
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.w3.org
````

随后就是请求的剩余部分。注意，绝对路径不能是空值。如果初始 URI 中不包含以上任何内容，则其必须被给定为````/````，也就是服务器根路径。

````Request-URI````以 3.2.1 章节中指定的格式被传输。如果该````Request-URI````被使用````% HEX HEX````编码，则初始服务器就必须解码该````Request-URI````以解读请求。服务器应该以适当的状态码响应非法的````Request-URI````。

当转发请求到下一个上游服务器时，透明代理绝对不能重写接收到的````Request-URI````的````abs_path````部分，除了上面提到的情况下将````abs_path````的空值替换为````/````。

注意：当初始服务器不恰当地使用一个非保留的 URI 字符表达一个保留目的时，不重写规则防止代理改变请求的含义。协议实现应该当心一些老版本的代理服务器已经被周知会重写````Request-URI````。

## 5.2 由请求定位资源

请求对资源的额外定位取决于请求的````Request-URI````和````Host````两个首部字段。

不允许资源被通过请求的主机字段区分的初始服务器在通过一个 HTTP/1.1 请求定位资源时可以忽略请求的````Host````首部字段值。

不允许资源被通过请求的主机字段（有时候是作为虚拟主机或者空泛的主机名称）区分的初始服务器必须基于下列规则来定位一个 HTTP/1.1请求所请求的资源：

1. 如果````Request-URI````是一个````absoluteURI````，主机就是````Request-URI````的一部分。请求中的任何````Host````首部字段值都必须被忽略。
2. 如果````Request-URI````不是一个````absoluteURI````，而请求包含一个````Host````首部字段，则由该字段名确定主机。
3. 如果通过规则1或者2得到的主机并不是服务器上的合法主机，则必须返回400（Bad Request）错误页面。

接收到缺少````Host````首部字段的 HTTP/1.0 请求的通信参与者可以尝试使用启发式方法（比如，检查 URI 路径尝试发现某些关于主机的特殊标识）以确定请求所需的额外资源。

## 5.3 请求首部字段

请求首部字段允许客户端传递有关请求的额外信息，或者有关客户端本身的额外信息，给服务端。这些首部字段作为请求修饰词，语义等同于程序语言方法调用中的参数。

````xml
request-header = Accept					; Section 14.1
				| Accept-Charset		; Section 14.2
				| Accept-Encoding		; Section 14.3
				| Accept-Language		; Section 14.4
				| Authorization			; Section 14.8
				| Expect				; Section 14.20
				| Form					; Section 14.22
				| Host					; Section 14.23
				| If-Match				; Section 14.24
				| If-Modified-Since		; Section 14.25
				| If-None-Match			; Section 14.26
				| If-Range				; Section 14.27
				| If-Unmodified-Since	; Section 14.28
				| Max-Forwards			; Section 14.31
				| Proxy-Authorization	; Section 14.34
				| Range					; Section 14.35
				| Referer				; Section 14.36
				| TE					; Section 14.39
				| User-Agent			; Section 14.43
````

请求首部字段随着协议版本升级会逐步可靠扩充。然而，新的或者实验性的首部字段可能被赋予请求首部字段语义，如果通信参与者都将其视为请求首部字段。无法识别的首部字段将被作为实体首部字段处理。

# 6 响应

接收并解读一个请求消息之后，服务器将回送包含一条 HTTP 响应消息的响应。

````xml
Response	= Status-Line				; Section 6.1
			*(( general-header			; Section 4.5
			| response-header			; Section 6.2
			| entity-header ) CRLF)		; Section 7.1
			CRLF
			[ message-body ]			; Section 7.2
````

## 6.1 状态行

````Response````消息的第一行是````Status-Line````，由协议版本号和紧随其后的数字状态码和对应的文字叙述组成，每个元素都由````SP````分隔。除了末尾的````CRLF````序列，这一行中不允许出现任何````CR````或者````LF````。

````xml
Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
````

### 6.1.1 状态码和原因描述

````Status-Code````元素是一个 3 位整形数字，表示试图理解并满足请求需要的结果编码。这些编码的完整定义在第 10 章中给出。````Reason-Phrase````是对应于````Status-Code````的一个简短文字描述。````Status-Code````是给机器读取的，而````Reason-Phrase````是给人类阅读的。不强制客户端检查或者显示````Reason-Phrase````。

````Status-Code````的第一位数字定义了响应的类别。后面的两位数字并没有分门别类的角色。第一位数字有 5 种取值：

* 1xx：信息。已接收到请求，持续处理中。
* 2xx：成功。请求操作已经成功接收、理解并接受。
* 3xx：重定向。为了完成该请求必须采取进一步的行动。
* 4xx：客户端错误。请求包含无法满足的语法。
* 5xx：服务端错误。服务端无法满足看起来合法的请求。

HTTP/1.1 协议状态编码的数字值以及对应的文字描述列出如下。其中的原因描述仅仅是推荐而非强制，它们可以被应用系统本地等价的描述替代，只要不影响协议运行即可。

````xml
Status-Code	=
	  "100"	; Section 10.1.1: Continue
	| "101"	; Section 10.1.2: Switching Protocols
	| "200"	; Section 10.2.1: OK
	| "201"	; Section 10.2.2: Created
	| "202"	; Section 10.2.3: Accepted
	| "203"	; Section 10.2.4: Non-Authoritative Information
	| "204"	; Section 10.2.5: No Content
	| "205"	; Section 10.2.6: Reset Content
	| "206"	; Section 10.2.7: Partial Content
	| "300"	; Section 10.3.1: Multiple Choices
	| "301"	; Section 10.3.2: Moved Permanently
	| "302"	; Section 10.3.3: Found
	| "303"	; Section 10.3.4: See Other
	| "304"	; Section 10.3.5: Not Modified
	| "305"	; Section 10.3.6: Use Proxy
	| "307"	; Section 10.3.8: Temporary Redirect
	| "400"	; Section 10.4.1: Bad Request
	| "401"	; Section 10.4.2: Unauthorized
	| "402"	; Section 10.4.3: Payment Required
	| "403"	; Section 10.4.4: Forbidden
	| "404"	; Section 10.4.5: Not Found
	| "405"	; Section 10.4.6: Method Not Allowed
	| "406"	; Section 10.4.7: Not Acceptable
	| "407"	; Section 10.4.8: Proxy Authentication Required
	| "408"	; Section 10.4.9: Request Time-out
	| "409"	; Section 10.4.10: Conflict
	| "410"	; Section 10.4.11: Gone
	| "411"	; Section 10.4.12: Length Required
	| "412"	; Section 10.4.13: Precondition Failed
	| "413"	; Section 10.4.14: Request Entity Too Large
	| "414"	; Section 10.4.15: Request-URI Too Large
	| "415"	; Section 10.4.16: Unsupported Media Type
	| "416"	; Section 10.4.17: Requested range not satisfiable
	| "417"	; Section 10.4.18: Expectation Failed
	| "500"	; Section 10.5.1: Internal Server Error
	| "501"	; Section 10.5.2: Not Implemented
	| "502"	; Section 10.5.3: Bad Gateway
	| "503"	; Section 10.5.4: Service Unavailable
	| "504"	; Section 10.5.5: Gateway Time-out
	| "505"	; Section 10.5.6: HTTP Version not Supported
	| extension-code
extension-code = 3DIGIT
Reason-Phrase  = *<TEXT, excluding CR, LF>
````

HTTP 状态编码是可扩展的。HTTP 客户端并不需要理解所有已经注册的状态编码，尽管这些状态编码的含义都是自描述性的。不过，所有的应用都必须理解所有状态编码的类别，也就是第一位数字的含义，对所有不认识的响应状态码都作为该类别的````x00````状态编码处理，同时不能识别状态码的响应绝对不能被缓存。比如，如果客户端收到了不认识的状态编码 431 的响应，它就可以安全地假定该请求发生了某些错误或者异常情况，然后如同接收到 400 状态编码那样处理该响应。这种情况下，用户代理应该向用户展示通过响应返回的数据实体，因为该数据实体很可能包含某些人类可读的信息来解释出现的异常状态。

## 6.2 响应首部字段

响应首部字段允许服务器发送关于响应的额外信息，这些信息不能放入````Status-Line````中。这些响应首部字段给出了有关服务端和对````Request-URI````指定的资源采取进一步访问操作的信息。

````xml
response-header = Accept-Ranges				; Section 14.5
				| Age						; Section 14.6
				| ETag						; Section 14.19
				| Location					; Section 14.30
				| Proxy-Authenticata		; Section 14.33
				| Retry-After				; Section 14.37
				| Server					; Section 14.38
				| Vary						; Section 14.44
				| WWW-Authenticat			; Section 14.47
````

响应首部字段名称会随着协议版本升级可靠扩展。然而，新的或者实验性的首部字段可以被赋予响应首部字段语义，如果通信参与者都能将它们识别为响应首部字段。不能识别的首部字段会被作为实体首部字段处理。

# 7 实体

````Request````和````Response````消息可以传输一个实体，如果没有来自请求方法或者响应状态码的其它限制。一个实体由实体首部字段和实体主体构成，不过某些响应仅仅包含实体首部字段。

本节中，发送者和接收者都可能是指客户端或者服务端，具体角色取决于它是实体发送方还是接收方。

## 7.1 实体首部字段

实体首部字段定义了有关实体主体的元数据，如果实体主体不存在，则是关于请求指定资源的元数据。其中部分元数据是可选的，另外一些可能是被此规范其它部分强制要求的。

````xml
entity-header = Allow					; Section 14.7
				| Content-Encoding		; Section 14.11
				| Content-Language		; Section 14.12
				| Content-Length		; Section 14.13
				| Content-Location		; Section 14.14
				| Content-MD5			; Section 14.15
				| Content-Range			; Section 14.16
				| Content-Type			; Section 14.17
				| Expires				; Section 14.21
				| Last-Modified			; Section 14.29
				| extension-header
extension-header = message-header
````

扩展首部机制允许额外的实体首部字段在不改变协议的情况下被定义，但是这些字段不能被假定为所有通信参与者都能识别。无法识别的首部字段应该被通信参与者忽略，而且必须被透明代理转发。

## 7.2 实体主体

通过 HTTP 请求或者响应发送的实体主体，如果存在的话，会以实体首部字段定义的格式和编码进行处理。

````xml
entity-body = *OCTET
````

一个实体主体只有当消息主体存在时才会出现在消息中，就像 4.3 章节中定义的那样。实体主体从消息主体中获取，还需要经过解码，根据为了保证消息安全传输而应用于其上的传输编码````Transfer-Encoding````。

### 7.2.1 类型

当一个实体主体被包含在消息中，其数据类型通过首部字段````Content-Type````和````Content-Encoding````确定。这两个首部字段定义了一个两层的有序编码模型：

````xml
entity-body := Content-Encoding( Content-Type( data ) )
````

````Content-Type````指定数据的媒体类型。````Content-Encoding````可以被用于表示应用于数据的任何附加内容编码，通常是为了数据压缩，作为被请求资源的属性。并没有默认编码的存在。

任何包含实体主体的 HTTP/1.1 消息都应该包含````Content-Type````首部字段，用于定义主体数据类型。当且仅当媒体类型没有通过````Content-Type````首部字段指定，消息接收方可以尝试猜测其媒体类型，通过检查其内容或者用于定位资源的 URI 中的扩展名。如果无法猜到媒体类型，消息接收方应该将其作为````application/octet-stream````类型处理。

### 7.2.2 实体长度

消息的实体长度是应用任何传输编码之前的消息主体的长度。4.4 章节中定义了如何确定消息主体的传输长度和传输编码。

# 8 连接

## 8.1 持久化连接

### 8.1.1 目的

在持久化连接出现之前，人们需要建立独立的 TCP 连接来获取每个 URI ，HTTP 服务器的负载很重，同时页造成了网络的拥塞。内嵌图片以及其它相关数据的使用通常会需要客户端在很短时间间隔内向同一个服务器发出多个请求。关于此类性能问题的分析来自一个目前已经可用的原型实现。实现的体验和实际 HTTP/1.1 （RFC 2068）的定量分析得到了很好的结果。其中的区别和已经被清晰地解释，比如 T/TCP。

持久化的 HTTP 连接具有大量好处：

* 通过打开和关闭更少的 TCP 连接，路由器和主机（客户端、服务器、代理、网关、管道或者缓存）的 CPU 时间得以节省，同时主机上用于 TCP 协议控制块的内存得以节省。
* HTTP 请求和响应在一个连接上可以被组装成管线的形式。管线允许客户端发送多个请求而不需要等待每个响应，允许一个 TCP 连接被更高效地使用，从而获得更低的时延。
* 通过减少 TCP 连接开启导致的数据包，网络拥塞的情况得以缓解。同时，TCP 有充分的时间确定网络的拥塞状态，也有助于解除网络拥塞。
* 连续的请求之间的时间间隔减少，因为不再有 TCP 连接建立和打开过程中的握手过程。
* HTTP 进化的更加优雅，因为错误可以被报告出来而不一定需要关闭 TCP 连接。使用未来 HTTP 版本的客户端可能有更好的解决方案，不过如果是在同老版本的服务端通信，则接收到错误报告之后还是需要以老版本的语义进行重试。

HTTP 实现应该实现持久化连接。

### 8.1.2 综述

HTTP/1.1 与早期 HTTP 版本最大的不同就是持久化连接成为了所有 HTTP 连接的默认行为。也就是说，除非特别说明，客户端应该假定服务端将维护持久化连接，甚至是在服务端返回错误响应之后。

持久化连接提供了一种机制，通过该机制，客户端和服务端可以发送 TCP 连接关闭信号。该信号位于````Connection````首部字段中。一旦收到连接关闭信号，客户端就绝对不能再通过该连接发送任何请求。

#### 8.1.2.1 协商

HTTP/1.1 服务端可以假定 HTTP/1.1 客户端想要保持持久化连接，除非随着请求发送过来的````Connection````首部字段包含连接凭证````close````。如果服务端选择在发送响应之后立即关闭连接，它就应该发送一个包含连接凭证````close````的````Connection````首部字段。

HTTP/1.1 客户端可能希望保持连接的打开状态，但是会根据来自服务端的响应的````Connection````首部字段是否包含连接凭证````close````来决定是否保持连接打开。如果客户端不想为更多请求保持连接，它应该发送包含连接凭证````close````的````Connection````首部。

无论客户端还是服务端发送了包含连接凭证````close````的````Connection````首部，该请求就会是通过该连接发送的最后一个请求。

客户端和服务端不应该假定 HTTP/1.1 之前版本的协议实现会保持持久化连接，除非有明确信号。19.6.2 章节中详述了如何向下兼容 HTTP/1.0 客户端。

为了保持持久化，连接上的所有消息必须包含一个自我定义的消息长度（也就是不需要以连接关闭作为消息结束标识），就像 4.4 章节描述的那样。

#### 8.1.2.2 管线

支持持久化连接的客户端可能会”管线化“它发出的请求（比如，发送多个请求而不等待每个请求的响应）。服务端必须按照这些请求被接收到的顺序依次发送对应于这些请求的响应。

假定持久化连接和立即管线化的客户端在连接建立之后就做好重试连接的准备，如果首次管线化尝试失败。如果客户端不进行这样的重试，它就绝对不能在确认连接持久化之前将请求管线化。客户端同时必须准备重新发送它们的请求，如果服务端在所有响应发送完毕之前就关闭了连接。

客户端不应该将使用非幂等方法或者非幂等方法序列的请求管线化。否则，传输连接的过早关闭就可能导致不确定的结果。想要发送非幂等请求的客户端应该等到收到前一个请求的响应后再发送。

### 8.1.3 代理服务器

对代理服务器来说，按照 14.10 章节中的定义精确实现````Connection````首部字段的属性是非常重要的。

代理服务器必须跟与它直接连接的客户端和初始服务器（或者其它代理服务器）分别声明建立持久化连接。每个持久化连接仅仅应用于一段单独的传输链路。

代理服务器绝对不能与 HTTP/1.0 客户端建立 HTTP/1.1 持久化连接（但是可以查看 RFC 2068 获取关于此问题的更多信息和讨论，因为许多 HTTP/1.0 客户端都实现了````Keep-Alive````首部）。

### 8.1.4 实践考量

服务端通常会有一些超时时间设定，超过该事件它们就将不再继续保持不活跃的连接。代理服务器需要更长的连接超时时间，因为客户端可能将要通过同一台服务器建立更多的连接。持久化连接的使用与客户端或者服务端超时时间的设定值甚至超时时间是否存在都没有关系。

当客户端或者服务端想要将连接超时，它应该优雅地关闭传输连接。客户端和服务端应该持续不断地建通对方传输关闭的信号，然后给予适当回应。如果客户端或者服务端不能马上探测到对方已将连接关闭，就可能会导致不必要的网络资源耗尽。

客户端、服务器或者代理服务器可以随时关闭传输连接。比如，客户端可能已经开始发送一个新的请求，与此同时，服务端决定关闭这个空闲的连接。站在服务端的视角，该连接由于空闲而被关闭，而站在客户端视角，一个请求正在处理中。

这就意味着，客户端、服务端和代理服务器都必须能够从异步关闭事件中恢复。客户端软件应该重新打开连接并重传被取消的请求序列，而不需要用户交互，如果请求序列是幂等的。非幂等方法的请求序列绝对不能被自动重试，不过用户代理（比如浏览器）可以提供一个人类操作的选项由用户来决定是否重试请求。来自理解应用语义的用户代理的确认会被直接来自用户的确认取代。如果第二次请求序列再次失败，则就不应该再次自动重试。

服务端应该始终响应每个连接上的至少一个请求，如果可能的话。服务端不应该关闭正在传输响应的连接，除非怀疑出现了网络或者客户端失败。

使用持久化连接的客户端应该限制它与给定服务器之间同一时间保持的持久化连接数。单个用户客户端不应该与任何服务器或者代理保持超过 2 个连接。一个代理服务器应该最多使用 2*N 个连接与其它服务器或者代理服务器通信，其中 N 是同一时刻的活跃用户数。这条约束的目的是降低 HTTP 响应时间并避免潜在的网络拥塞。

## 8.2 消息传输必要条件

### 8.2.1 持久化连接和流量控制

HTTP/1.1 服务器应该维持持久化连接并且使用 TCP 流量控制机制解决临时的过载，而不是终止连接然后期待客户端发起重试。后者会加剧网络拥塞。

### 8.2.2 监听连接上的错误状态信息

HTTP/1.1 或者更高版本的发送消息体的客户端在传输请求的同时应该监控网络连接的错误状态。如果客户端发现一个错误状态，就应该立即结束消息体的传输。如果消息体正在被分块编码发送，就需要使用一个 0 长度的分片和空尾部来表示消息的提前结束。如果消息体之前发送了````Content-Length````首部字段，则客户端必须关闭连接。

### 8.2.3 使用 100（Continue）状态码

100（Continue）状态码的目的是允许正在发送包含请求体的请求的客户端在发送请求体之前确定初始服务器是否愿意接受该请求（基于请求首部）。某些情况下，明知服务器将拒绝该消息并且无视消息体时仍然发送请求体是不合适而且非常低效率的。

HTTP/1.1 客户端必要条件：

* 如果客户端发送请求体之前将等待 100（Continue）响应，它就必须发送一个````Expect````请求首部字段包含````100-continue````期待。
* 客户端如果不准备发送请求体，它就绝对不能发送包含````100-continue````期待的````Expect````首部字段。

由于老版本实现的存在，协议允许某些条件下客户端可以发送````Expect: 100-continue````而不接收 417（Expectation Failed）状态码或者 100（Continue）状态码。因此，当客户端发送此首部字段给初始服务器（可能通过代理服务器），但是该客户端从来没有从该服务器接收到过 100（Continue）状态码，客户端就不应该再发送请求体之前无休止地等待。

HTTP/1.1 初始服务器必要条件：

* 当接收到包含````Expect````请求首部字段（包含````100-continue````期待）的请求时，初始服务器必须要么响应以 100（Continue）状态码并从输入流中读取，要么响应以终结状态码。初始服务器绝对不能再发送 100（Conitnue）响应之前等待请求体。如果它响应以终结状态码，它就可以关闭传输连接或者继续读取并丢弃请求的剩余部分。发送终结状态码之后服务器就绝对不能再执行请求方法。
* 初始服务器不应该发送100（Continue）状态码响应，如果请求消息不包含````Expect````请求首部字段（包含````100-continue````期待），同时绝对不能发送100（Continue）状态码响应，如果请求来自 HTTP/1.0 或者更早版本的客户端。这条规则有个例外：为了保持兼容 RFC 2068，服务器可以发送100（Continue）状态码响应给 HTTP/1.1 PUT 或者 POST 请求，这些请求可以不包含````Expect````请求首部字段（包含````100-continue````期待）。这个例外的目的是尽量减少客户端有关未声明的100（Continue）状态的等待，因此只是应用于 HTTP/1.1 请求，而不能用于其他版本请求。
* 初始服务器可以忽略100（Continue）状态码响应如果它已经从相应的请求的请求体中接收到部分或者全部数据。
* 发送100（Continue）状态码响应的初始服务器必须最终发送一个终结状态码，一旦请求体已经被接收并处理，除非它提前中断了传输连接。
* 如果初始服务器接收到不包含````Expect````请求首部字段（包含````100-continue````期待）的请求，而请求又包含请求体，从传输连接上读取完整的请求体之前服务器返回终结状态码，然后服务器就不应该关闭传输连接，直到请求已经读取完成，或者客户端关闭连接。否则，客户端可能不能可靠地接收响应消息。然而，此条件对保护服务器免受 DOS 攻击或者糟糕的客户端实现并没有太多作用。

HTTP/1.1 代理服务器必要条件：

* 如果一个代理服务器接收到包含````Expect````请求首部字段（包含````100-continue````期待）的请求，同时该代理服务器要么知道请求的下一跳服务器遵循 HTTP/1.1 或者更高版本协议，要么不知道下一跳服务器支持的 HTTP 协议版本，它都必须转发该请求，包含其中的````Expect````首部字段。
* 如果代理服务器知道下一跳服务器支持的协议版本是 HTTP/1.0 或者更低，则它绝对不能转发请求，同时必须响应 417（Expectation Failed）状态码。
* 代理服务器应该维护一套缓存数据来纪录最近接收到的请求中携带的下一跳服务器支持的 HTTP 协议版本信息。
* 代理服务器绝对不能转发 100（Continue）响应，如果请求消息来自一个 HTTP/1.0 或者更低版本的客户端，同时并未包含````Expect````请求首部字段（包含````100-continue````期待）。此强制规则覆盖了 1xx 响应的通用转发规则。

### 8.2.4 服务端过早关闭连接时客户端行为

如果一个 HTTP/1.1 客户端发送一个包含请求体的请求，但是不包含````Expect````请求首部字段（包含````100-continue````期待），同时如果该客户端并没有直接连接到一个 HTTP/1.1 初始服务器，而该客户端在接收到来自服务器的任何状态的响应之前就发现连接关闭，则该客户端就应该重试请求。如果它没有重试该请求，它就可以使用如下“二进制指数退避”算法以获取可靠的响应：

       	1. 初始化一个到服务器的新的连接；
        	2. 传输请求头；
         	3. 初始化一个变量 R 表示到服务器的回环时间的估计（比如，基于连接建立所花费时间），或者直接表示常量5秒钟，如果回环时间不可知；
         	4. 计算 T = R * (2^N)，其中 N 是本次请求之前已经进行的重试次数；
         	5. 等待要么从服务器返回一个错误响应，要么等待 T 秒时间，看哪个先到来；
         	6. 如果没有收到错误响应，则在 T 秒之后传输请求体；
         	7. 如果客户端发现连接已经提前被关闭，重复步骤1直到请求被接受、接收到一个错误响应、或者等到用户失去耐心而终止重试过程。

如果在任何时刻收到错误状态码，客户端：

* 不应该继续，并且
* 应该关闭连接如果它尚未完成请求消息的发送。

# 9 方法定义

HTTP/1.1 协议通用方法的定义如下。尽管这个通用方法集合可以扩展，单独扩展客户端或者服务端而添加的方法并不能假定对所有通信参与者具有相同的语义。

所有 HTTP/1.1 请求都必须包含请求首部字段````Host````。

## 9.1 安全和幂等方法

### 9.1.1 安全方法

协议实现者应该对软件代表用户通过互联网进行的交互保持警觉，同时应该小心地允许用户对他们的任何可能对他们自己或者别人造成期望之外的影响的行为保持警觉。

特别地，以形成的惯例是````GET````和````HEAD````方法都不应该具有查询之外的任何附加意义。这些方法应该被认为是安全的。这就允许用户代理以以特殊的方式表示其它方法，比如````POST````、````PUT````以及````DELETE````，这样一来，用户就会注意到可能存在的某些不安全的请求行为。

自然地，实际上我们无法确保服务端程序执行一个````GET````请求绝对不产生任何副作用。事实上，一些动态资源认为那是一个特性。最关键的区别在于，用户并没有请求那些副作用，因而无法理解它们。

### 9.1.2 幂等方法

方法可以包含“幂等性”属性，表示 N > 0 个请求的副作用与单独一个请求完全一样（暂不讨论错误或者超时问题）。方法 GET、HEAD、PUT 和 DELETE 分享此属性。同时，方法 OPTIONS 和 TRACE	本身就应该没有副作用，因此是天然幂等的。

然而，即使请求序列中的所有请求方法都是幂等的，该请求序列仍然有可能是非幂等的。（幂等序列是只序列整体执行的结果不会被完整序列的重新执行、或者部分序列的重新执行所改变。）比如，一个序列是非幂等的，如果他的结果依赖于某个随后会被序列中其它方法修改的值。

根据定义，没有任何副作用的序列是幂等的。（在相同资源集合上没有并发操作执行时）

## 9.2 OPTIONS

````OPTIONS````方法表示一个请求由````Request-URI````标识的请求响应链上可用的有关通信选项信息。此方法允许客户端确定资源相关的选项或者需求，或者服务器的容量等，而不需要执行一个资源操作或者初始化一个资源查询。

此方法的响应不能被缓存。

如果````OPTIONS````请求包含一个实体主体（通过````Content-Length````或者````Transfer-Encoding````首部字段表示），则其媒体类型必须由````Content-Type````首部字段表示。尽管本规范并没有定义这个主体的任何使用方法，将来的 HTTP 扩展可能使用````OPTIONS````请求体表示更多的服务器上的请求细节。不支持这种扩展的服务器可以丢弃这个请求体。

如果````Request-URI````是一个星号````*````，则````OPTIONS````请求就是应用于服务器的，而不是应用于某个特定资源。因为一个服务器的通信选项典型地依赖资源，````*````请求只是对````ping````或者````no-op````类型的方法有用。除了允许客户端测试服务器的容量之外这种请求不能做任何其它事情。比如，这种用法可以被用于测试的一个代理服务器的 HTTP/1.1 兼容性。

如果````Request-URI````不是一个星号，则````OPTIONS````请求就会只应用于那些与相应资源通信时可用的选项。

一个````200````相应应该包含所有首部字段，表示由服务端实现的并可以应用于对应资源的可选特性（比如````Allow````），可能包含本规范未定义的扩展。响应体如果存在，应该也包含通信选项的信息。此规范并未定义此响应体的格式，但是将来的 HTTP 扩展中可能定义。内容协商可以被用来选择合适的响应格式。如果没有包含响应体，该响应必须包含````Content-Length````首部字段，并且其值为````0````。

````Max-Forwards````请求首部字段可以被用来在请求链上选择特定代理服务器作为目标。当一个代理服务器接收到一个绝对路径上的````OPTIONS````请求，而该请求是可转发的，则代理服务器就必须检查````Max-Forwards````字段。如果该字段值为 0 ，则代理服务器就绝对不能转发该消息，取而代之的，代理服务器应该通过响应返回他自己的通信选项信息。如果该字段值是一个大于 0 的整数，则代理服务器必须在转发该请求的同时对该字段减一。如果请求中不包含````Max-Forwards````字段，则转发后的请求中就绝对不能包含该字段。

## 9.3 GET

````GET````方法意味着查询````Request-URI````定位的任何信息（以数据实体的形式）。如果````Request-URI````表示的一个数据生产过程，则产生的数据就会被作为响应的数据实体返回，而不是产生数据过程的源代码，除非那些文本恰巧就是数据生产过程的输出结果。

如果请求消息包含一个````If-Modified-Since````、````If-Unmodified-Since````、````If-Match````、````If-None-Match````或者````If-Range````首部字段时````GET````方法的语义会变成条件````GET````。条件````GET````方法请求的数据实体仅仅在条件首部字段描述的环境下才会被传输。条件````GET````方法目的是减少不必要的网络带宽消耗，通过允许缓存需要刷新的数据实体，而不需要多个请求或者传输已经被客户端持有的数据。

如果请求消息包含一个````Range````首部字段则````GET````方法的语义就会变成部分````GET````。部分````GET````请求的数据实体只会被传输一部分，如 14.35 章节所述。部分````GET````方法的目的是减少不必要的网络带宽消耗，通过允许数据实体部分查询来补全数据，而不需要完整传输已经被客户端持有的数据。

````GET````请求的响应是可以被缓存的，当且仅当它符合本规范 13 章中描述的 HTTP 缓存规范时。

15.1.3 章节描述了用于表单时的安全考量。

## 9.4 HEAD

````HEAD````方法多数情况下与````GET````方法完全等价，除了服务器绝对不能在响应中包含消息体。````HEAD````请求的响应的 HTTP 首部字段中包含的元数据信息应该完全等价于````GET````请求的响应中的首部字段包含的元数据信息。此方法可以被用来获取关于请求表示的数据实体的元数据信息而不需要传输数据实体本身。此方法通常用于测试超链接的可用性、可达性以及最近修改。

````HEAD````请求的响应可以被缓存，如果响应中包含的信息可以被用于更新早先缓存的来自对应资源的数据实体。如果这个新的字段值表明已缓存的实体与当前实体（表现为相关首部字段值的变化````Content-Length````、````Content-MD5````、````ETag````或者````Last-Modified````），则该缓存就必须被认为是过时的。

## 9.5 POST

````POST````方法用于那些初始服务器接受包装在请求中作为由````Request-Line````中的````Request-URI````定位的资源的新的附属的数据实体的请求。POST 方法被设计为涵盖以下功能的统一方法：

* 已存在资源的注解；
* 推送消息到公告板、新闻组、邮件列表或者其它类似的文章群组；
* 提供数据块，比如提交表单的结果，供数据处理过程使用；
* 通过添加操作扩充数据库。

POST 方法实际执行的功能由服务器定义，通常依赖于````Request-URI````。被发送的数据实体是 URI 的附属，如同一个文件作为一个目录的附属，一条新闻报道作为它被发送到的新闻组的附属，或者一条记录作为一个数据库的附属。

````POST````方法执行操作可能并不会产生一个由 URI 定位的资源。这种情况下，200（OK）或者 204（No Content）是合适的响应状态码，取决于响应是否包含描述请求结果的数据实体。

如果一个资源已经被创建在初始服务器上，则响应应该是 201（Created），同时应该包含一个描述请求状态和新资源引用的数据实体，同时还有一个````Location````首部字段。

此方法的响应不可缓存，除非响应包含一个恰当的````Cache-Control````或者````Expires````首部字段。然而，303（See Other）响应可以被用于让用户代理直接查询一个可缓存的资源。

POST 请求必须遵循 8.2 章节中给出的消息传输要求。

15.1.3 章节描述了相关安全考量。

## 9.6 PUT

````PUT````方法请求中，请求附带的数据实体存储在给出的````Request-URI````路径下。如果````Request-URI````指向一个已经存在的资源，则请求附带的数据实体应该被看作是处于初始服务器上的对应数据的一个修改版本。如果````Request-URI````并不指向一个存在的资源，而其中的 URI 具有被发起请求的用户代理定义为一个新的资源的能力，则初始服务器就可以基于该 URI 创建相应资源。如果一个新的资源被创建，初始服务器就必须通过 201(Created) 响应状态码通知用户代理。如果一个已经存在的资源被修改，则可以用 200（OK）或者 204（No Content）响应状态码来表示请求成功完成。如果````Request-URI````指定的资源既不能被创建也不能被修改，则应该返回能够反映问题本身详情的错误响应。这种情况下，数据实体的接收者绝不能忽略任何它不能理解或者尚未实现的````Content-*````首部字段（比如````Content-Range````），同时必须返回一个 501（Not Implemented）响应状态码。

如果请求经过一个缓存，同时````Request-URI````定位一个或者多个目前已被缓存的数据实体，则这些数据实体就应该被看作是已经过时的。此方法请求的响应是不可缓存的。

````POST````和````PUT````请求的主要不同反映在````Request-URI````的不同含义。````POST````请求中的 URI 表示讲处理请求附带的数据实体的资源。该资源可能是一个数据处理过程、一个其它协议的网关、或者一个单独接受注解的数据实体。与此不同，````PUT````请求中的 URI 表示请求附带的数据实体，用户代理了解 URI 的意图，而服务器绝对不能试图将请求应用到其它资源。如果服务器希望将请求应用于别的 URI ，则它必须发送一个 301（Moved Permanently）相应状态码，然后用户代理可以由此决定是否需要对请求进行重定向。

同一个资源可能被许多不同的 URI 定位到。比如，一篇文章的每个版本都由不同的 URI 定位。这种情况下，指向通用 URI 的````PUT````请求可能导致多个其它 URI 被初始服务器定义。

HTTP/1.1 协议没有定义 PUT 方法如何影响初始服务器的状态。

PUT 请求必须遵循 8.2 章节中定义的消息传输强制规范。

除非通过实体首部字段特别指定，PUT 请求中的实体首部字段应该被用于资源创建或者更新。

## 9.7 DELETE

````DELETE````方法请求删除````Request-URI````定位的初始服务器上的资源。此方法可以通过在初始服务器上进行认为介入而被覆盖。客户端不能保证请求的操作一定被执行，即使从初始服务器返回的响应状态码表示请求的行为已经被成功完成。不过，服务器不应该声明操作成功，除非在返回响应时，它试图删除资源或者将它移动到不可访问的位置。

一个成功的响应应该是 200（OK），如果响应包含一个描述该状态的数据实体。当请求行为没有执行通过时返回 202（Accepted），当请求行为执行通过但是响应中并未包含一个数据实体时返回 204（No Content）。

如果请求经过一个缓存，同时````Request-URI````定位一个或者多个目前已被缓存的数据实体，则这些数据实体就应该被看作是已经过时的。此方法请求的响应是不可缓存的。

## 9.8 TRACE

````TRACE````方法用来调用关于请求消息的一个远程的应用层面的回环接口。该请求的最终接收者应该将接收到的消息作为一个 200（OK）响应的实体主体回送给客户端。消息的最终接收者可以实初始服务器或者接收到的请求中````Max-Forwards````字段值为 0 的第一个代理服务器或者网关。````TRACE````请求绝对不能包含数据实体。

````TRACE````方法允许客户端观察在请求链的另一端接收到的数据是什么，同时使用该数据测试或者诊断信息。首部字段````Via````的值特别有意思，因为它就是请求链的跟踪器。使用````Max-Forwards````首部字段允许客户端限制请求链的长度，这对在一个无限长度的环路中测试转发消息的代理链非常有用。

如果请求是合法的，响应数据实体主体应该包含完整的请求消息，同时携带首部字段````Content-Type````值为````message/http````。此方法请求的响应绝对不能被缓存。

## 9.9 CONNECT

此规范保留了方法名称````CONNECT````，用来和那些随时可以动态切换成隧道的代理服务器配合使用。

# 10 状态码定义

下面逐个介绍````Status-Code````定义，包括它可以作为哪些方法请求的响应状态码以及其它有关响应的元信息要求。

## 10.1 Informational 1xx

此类状态码表示一个临时性的响应，仅仅由````Status-Line````和可选的首部字段组成，以一个空行结束。此类状态码响应没有强制的首部字段要求。因为 HTTP/1.0 并没有定义任何 1xx 状态码，服务器绝对不能发送 1xx 响应给 HTTP/1.0 客户端，除非是在试验环境下。

客户端必须准备好在普通响应之前接收一个或者多个 1xx 状态码响应，即使该客户端并没有期待一个 100（Continue）状态的消息。用户代理可以忽略这些预料之外的 1xx 状态码响应。

代理服务器必须转发 1xx 状态码响应，除非该代理与客户端之间的连接被关闭，或者除非是代理服务器本身的请求产生的该 1xx 响应。

### 10.1.1 100 Continue

客户端应该继续它的请求。此临时响应用于通知客户端请求的最初部分已经被服务器接收到而且并未被抛弃。客户端应该继续发送剩余的请求，或者，如果请求已经发送完成，则忽略此响应。服务器在请求完成之后必须发送一个终结响应。更多细节参见 8.2.3 章节。

### 10.1.2 101 Switching Protocols

服务器理解并希望响应客户端请求，通过````Upgrade````消息首部字段，用来对当前连接使用的应用协议进行改变。服务器会在发送完作为 101 响应的终结符的空行之后立即将协议切换到响应的````Upgrade````首部字段定义的协议。

只有当协议确实更加优越时才应该切换。比如，切换到一个新的 HTTP 协议版本相比老版本有更多优点，切换到一个实时的异步协议可能在使用这些特性发布资源时具有更多优势。

## 10.2 Successful 2xx

此类状态码表示客户端的请求已经被成功接收、理解和接受。

### 10.2.1 200 OK

请求已经成功。跟随此状态码返回的信息取决于请求使用的方法，比如：

````GET````    对应于被请求资源的一个数据实体被放在响应中发送；

````HEAD````    对应于被请求资源的实体首部字段放在响应中发送，没有任何消息体；

````POST````    描述或者包含动作结果的数据实体；

````TRACE````    包含被最终服务器接收到的请求消息的数据实体。

### 10.2.2 201 Created

请求已经被满足，其结果是一个新的资源被创建。被创建的新资源可以被返回的响应数据实体中的 URI 引用，同时在````Location````首部字段中给出了资源的最准确的 URI 。响应应该包含一个包含资源字符集和区域位置的列表，用户或者用户代理可以从中选择最合适的一个。实体格式由````Content-Type````首部字段给出的媒体类型指定。初始服务器必须在返回 201 状态码之前创建资源。如果该创建操作不能立即执行，则服务器应该响应 202（Accepted）状态码。

一个 201 状态码响应包含一个````ETag````响应首部字段表示应请求而创建的变量的实体标签的当前值。

### 10.2.3 202 Accepted

请求已经被接受并正在处理中，但是处理过程尚未完成。请求执行的结果可能成功也可能失败。并没有什么机制可以再次发送一个状态码来反映这种异步操作的结果。

202 响应是有意不言明的。它的目的是允许服务器接受一个请求来执行其它过程（可能是一个每天执行一次的批处理操作），而不需要用户代理与服务端的连接持久化保持到操作执行完成。响应中返回的数据实体应该包含请求当前状态的标识，或者一个状态监控指针，或者某些状态估计，因而用户可以期待该请求被满足。

### 10.2.4 203 Non-Authoritative Information

返回的响应实体首部中的元信息并不是可向初始服务器获取的确定性的集合，而是从一个本地或者第三方拷贝收集而来。该集合表现的可以是初始版本的子集或者超集。比如，包含关于资源的本地注解信息可能以初始服务器了解的元信息的超集为结果。使用此响应状态码并不强制，而且仅仅当响应可能是200（OK）时才是合适的。

### 10.2.5 204 No Content

服务器已经满足请求，但是并不需要返回一个数据实体，或者可能想要返回更新的元信息。该响应的数据实体首部中可以包含新的或者更新后的元信息，它们都应该是关于请求的变量的。

如果客户端是一个用户代理，它就不应该改变它的文档视图，那样就会导致请求被发送。该响应的主要目的是允许输入行为发生，而不会导致用户代理的活动文档视图的变化，尽管任何新的或者更新的元信息都应该被应用到当前用户代理的活动文档视图中。

204 状态码响应绝对不能包含消息体，因此永远会以首部字段之后的首个空白行终结。

### 10.2.6 205 Reset Content

服务器已经满足了请求，同时用户代理应该重置导致请求被发出的文档视图。该响应的主要目的是通过用户的输入允许输入行为的发生，随着接收输入的表单被清空，用户可以很简单地初始化另外一个输入行为。该响应绝对不能包含数据实体。

### 10.2.7 206 Partial Content

服务器已经满足部分````GET````请求。请求必须包含````Range````首部字段表示期望的数据范围，同时可能包含一个````If-Range````首部字段将请求变为条件请求。

其响应必须包含下列首部字段：

* ````Content-Range````首部字段表示响应中包含的数据范围，或者每个````Content-Type````为````multipart/byteranges````的部分都包含一个````Content-Range````字段。如果响应中包含一个````Content-Length````首部字段，其值就必须等于消息体中传输的实际记号总数。
* ````Date````
* ````ETag````和 / 或````Content-Location````，如果该首部将被随着同一个请求的 200 状态码响应被发送。
* ````Expires````，````Cache-Control````和 / 或````vary````，如果该字段值可能不同于任何之前被发送的关于同一个资源变量的响应。

如果 206 状态码响应是一个````If-Range````请求的结果，该请求使用了强缓存校验，则该响应就不应该包含其它实体首部字段。如果请求使用了弱缓存校验，则响应绝对不能包含其它实体首部字段，这就避免了缓存的数据实体主体和更新了的首部之间的不一致性。否则，该响应必须包含所有的实体首部，同时必须被随着 200（OK）状态码响应相同的请求。

如果````ETag````或者````Last-Modified````首部并不完全相同，一个缓存绝对不能将一个 206 状态码响应和其它缓存内容结合起来。

不支持````Range````和````Content-Range````首部的缓存绝对不能缓存 206（Partial）响应。

## 10.3 Redirection 3xx

此类状态码表示需要用户代理采取进一步的行动来满足请求。当且仅当第二个请求使用的方法是````GET````或者````HEAD````，则需要采取的行动可以由用户代理执行而不需要真实用户的参与。客户端应该探测无限的重定向环路，因为这种环路中每次重定向都会产生网络流量。

注意：此规范的早期版本推荐最多重定向次数为5。内容开发者应该注意可能有实现了该固定限制规则的客户端。

### 10.3.1 300 Multiple Choices

请求的资源对应于表示集合中的任何一个，每个都拥有各自特定的位置，同时提供了代理驱动的协商信息供用户或者用户代理选择最好的表示，然后将请求重定向到该位置。

除非是一个````HEAD````请求，响应应该包含一个包含资源字符集和位置信息列表的数据实体，用户或者用户代理可以从该列表中选择最合适的一个。该数据实体的格式由````Content-Type````首部字段给出的媒体类型。基于该格式和用户代理的能力，做出最佳选择的过程可以是自动的。然而，本规范并未对此自动化选择过程定义任何标准。

如果服务器已经选出了最好的表示，则它就应该在响应的````Location````字段中包含该表示特定的 URI，用户代理可以使用该````Location````字段值来自动重定向。此响应是可缓存的，除非另外特别说明。

### 10.3.2 301 Moved Permanently

请求的资源已经被分配了一个新的永久性的 URI，所有后续的此资源的引用都应该使用返回的 URIs 之一。可能的话，具有连接编辑能力的客户端应该自动重链接到````Request-URI````的引用到一个或者多个这种服务器返回的新的引用。此响应是可缓存的，除非另外特别说明。

新的永久性的 URI 应当通过响应的````Location````字段给出。除非请求方法是````HEAD````，响应数据实体应该包含一个简短的超链接指向新的 URI。

如果接收到的响应状态码是 301，而请求方法又不是````GET````或者````HEAD````，用户代理就绝对不能自动重定向该请求，除非由用户亲自确认。因为这样可能改变发送请求的条件。

注意：当接收到 301 状态码响应之后自动重定向一个````POST````请求时，一些现存的 HTTP/1.0 用户代理会错误地将它变成````GET````请求。

### 10.3.3 302 Found

请求的资源临时性位于一个不同的 URI 下。由于重定向可能随时按需改变，客户端应该在后续的请求中继续使用该````Request-URI````。此响应仅当通过````Cache-Control````或者````Expires````首部字段说明时才是可缓存的。

临时性的 URI 应该通过响应中的````Location````首部字段给出。除非请求方法是 HEAD，则响应体应该包含一个简短的超文本记号以及一个指向新的 URI 的超链接。

如果接收到的响应状态码是 302，而请求方法又不是````GET````或者````HEAD````，则用户代理绝对不能自动重定向该请求，除非经过用户亲自确认，因为这将有可能改变该请求所处的环境条件。

注意：RFC 1945 和 RFC 2068 规定，客户端不允许改变重定向请求的方法。然而，大部分现存的用户代理实现并不区别对待 302 和 303 响应状态码，直接基于````Location````字段值执行````GET````方法操作而不管原始请求方法。响应状态码 303 和 307 已经被添加，供那些希望准确分辨客户端期望得到的响应类型的服务器使用。

### 10.3.4 303 See Other

请求的响应可以在一个不同的 URI 下被发现，而且应该使用该资源上的````GET````方法获取。此方法的主要目的是允许一个````POST````触发的脚本的输出将用户代理重定向到一个选定的资源。该新 URI 并不是初始请求资源的替代引用。303 状态码响应绝对不能被缓存，但是第二个（被重定向的）请求的响应可以被缓存。

该不同的 URI 应该通过响应的````Location````首部字段给出。除非请求方法是````HEAD````，响应体应该包含一个简短的超文本记号以及一个指向新的 URI 的超链接。

注意：许多 HTTP/1.1 之前版本的用户代理不理解 303 状态码。与这种客户端的交互问题需要特别关注，通常使用 302 状态码替代 303 状态码。因为大部分用户代理并不区别对待 302 和 303 状态码。

### 10.3.5 304 Not Modified

如果客户端已经执行了一个条件````GET````请求，同时访问是允许的，但是文档并未被修改，则服务器应该响应以此状态码。304 状态码响应绝对不能包含消息体，因此永远是以首部字段之后的第一个空白行作为终结符。

此响应必须包含以下首部字段：

* ````Date````，除非按照 14.18.1 章节中的规定被省略

  如果一个无时钟的初始服务器遵循此规则，同时代理服务器和客户端将它们自己的````Date````添加到接收到的所有响应中（除了在 RFC 2068 中指定的那个响应），则缓存将正确执行。

* ````ETag````和 / 或 ````Content-Location````，如果该首部将被包含在对应于相同请求的 200 状态码响应中被发送。

* ````Expires````，````Cache-Control````，和 / 或````Vary````，如果该首部字段值可能不同于同一个资源变量的之前发送的响应中的字段值。

如果条件````GET````使用强缓存校验，则响应就不应该包含其它实体首部字段。否则（比如，条件````GET````使用弱缓存校验），响应绝对不能包含其它实体首部字段。此规则防止了已经缓存的实体主体和更新了的实体首部之间不一致的情况。

如果一个 304 状态码响应表示目前尚未缓存的数据实体，则缓存必须忽略该响应并无条件重发该请求。

如果一个缓存使用接收到的 304 状态码响应更新一个缓存数据实体，该缓存必须更新该实体以反映响应中给出的所有新的字段值。

### 10.3.6 305 Use Proxy

请求的资源必须通过````Location````首部字段给出的代理访问。该````Location````字段给出了代理的 URI。通信参与者被期待通过该代理服务器重发该请求。305 状态码响应只能由初始服务器产生。

注意：RFC 2068 并未明确说明 305 状态码的目的是重定向一个单独的请求，而且只能由初始服务器产生。不遵循这些限制可能会产生重大安全问题。

### 10.3.7 306（Unused）

此状态码在早期版本规范中使用，此版本规范已不再使用，仅作为保留状态码。

### 10.3.8 Temporary Redirect

请求的资源临时性位于一个不同的 URI 下。由于重定向可能随时按需改变，客户端应该在后续的请求中继续使用该````Request-URI````。此响应仅当通过````Cache-Control````或者````Expires````首部字段说明时才是可缓存的。

临时性的 URI 应该通过响应中的````Location````首部字段给出。除非请求方法是 HEAD，则响应体应该包含一个简短的超文本记号以及一个指向新的 URI 的超链接。许多 HTTP/1.1 之前版本的用户代理不理解 307 状态码，因此，该记号中应该包含用户在新的 URI 上重发初始请求所需的必要信息。

如果接收到的响应状态码是 307，而请求方法又不是````GET````或者````HEAD````，则用户代理绝对不能自动重定向该请求，除非经过用户亲自确认，因为这将有可能改变该请求所处的环境条件。

## 10.4 客户端错误 4xx

4xx 类型的状态码用在那些看起来客户端出现了错误的情况。除了响应一个````HEAD````请求，响应其它请求时服务器应该在实体中包含关于这种错误情况的解释，以及这种情况是临时的还是永久的情况。这些状态码可以用于任何请求方法。用户代理应该向用户显示包含的所有实体。

如果客户端正在发送数据，使用 TCP 的服务器端实现应该注意确保客户端已经确认接收到包含响应数据的数据包，在服务器关闭输入连接之前。如果客户端在连接关闭之后继续向服务器发送数据，服务器端的 TCP 协议栈讲发送一个重置数据包给客户端，这将会清除客户端尚未确认收到的输入缓冲，在它们能够被 HTTP 应用读取并且解读之前。

### 10.4.1 400 Bad Request

服务器无法理解请求包含的奇葩语法。客户端不应该原封不动地重发该请求。

### 10.4.2 401 Unauthorized

请求需要用户身份认证。响应必须包含一个````WWW-Authenticate````首部字段，该字段包含一个适用于请求的资源的````challenge````。客户端可以重发携带合适的````Authorization````首部字段的请求。如果请求已经包含身份认证凭证，则 401 状态码响应表示身份认证机制已经拒绝了那些身份凭证。如果 401 状态码响应包含与它前一个响应相同的````challenge````，同时用户代理已经尝试认证至少一次，则应该向用户展示响应中包含的数据实体，因为这些数据可能包含相关诊断信息。HTTP 访问身份认证在"HTTP Authentication: Basic and Digest Access Authentication"。

### 10.4.3 402 Payment Required

此状态码保留供将来使用。

### 10.4.4 403 Forbidden

服务器理解请求，但是拒绝服务。授权没有意义，请求不应该重发。如果请求方法不是````HEAD````而且服务端希望可以公开请求不被满足的原因，它就应该在响应体中描述拒绝原因。如果服务端不想向客户端公开这些信息，则应该使用 404(NOT FOUND) 响应状态码替代。

### 10.4.5 404 Not Found

服务端没有发现匹配到````Request-URI````的任何资源。并没有标记说明这种情况是临时的还是永久的。如果服务端通过某些内部可配置的机制获知请求的旧资源已经永久不可用而又没有请求转发地址，则应该使用 410(Gone) 响应状态码。404 状态码通常被用在当服务端不想公布请求被拒绝的精确原因时，或者没有其它可用的响应时。

### 10.4.6 405 Method Not Allowed

````Request-Line````指定的方法不被````Request-URI````定位的资源允许。响应中必须包含一个````Allow````首部字段包含一个被请求资源的可用方法列表。

### 10.4.7 406 Not Acceptale

被请求定位的资源只能被用来生成某些响应体数据，这些响应体的内容特性根据随请求发送过来的````Accept````首部来看是不可接受的。

除非是一个````HEAD````请求，响应就应该包含一个数据实体，其中包含一个可用的实体特性和位置区域，用户或者用户代理可以从中选择最合适的一个使用。实体格式通过````Content-Type````首部字段中给出的媒体类型指定。取决于用户代理的格式和能力，选择最合适的特性的过程可以自动执行。然而，本规范并不定义任何有关此自动选择过程的标准。

注意：HTTP/1.1 服务器允许返回根据请求中的````Accept````首部字段判定为不可接受的响应。某些情况下，这种行为可能比发送 406 状态码响应更好。用户代理被鼓励检查到来的响应的首部以确定其是否可接受。

如果响应是不可接受的，用户代理应该临时停止解析更多数据并询问用户以决定后续操作。

### 10.4.8 407 Proxy Authentication Required

此状态码类似于 401(Unauthorized) ，但是表示客户端必须首先向代理认证它自己的身份。代理必须返回一个````Proxy-Authenticate````首部字段，包含一个用于代理的有关被请求资源的挑战。客户端可以重发请求并携带合适的````Proxy-Authorization````首部字段。HTTP 访问认证在 HTTP Authentication: Basic and Digest Access Authentication 中解释。

### 10.4.9 408 Request Timeout

客户端没能在服务端等待时间内发出请求。客户端可以稍后不加任何修改地重发该请求。

### 10.4.10 409 Conflict

请求不能被完成，因为它与所需的资源的当前状态发生了冲突。此状态码只有在希望用户可能会解决该冲突并重发该请求的情况下才能使用。响应体应该包含足够的信息来帮助用户识别冲突的源头。理想情况下，响应体将包含足够的信息以帮助用户代理解决该问题，不过，这并不是总是可能的，当然也不是强制的。

冲突最有可能发生在响应````PUT````方法请求时。比如，如果资源采用了版本管理，````PUT````方法请求的请求体中包含的用来修改资源的数据版本与另外一个请求生成的数据版本发生冲突，服务端可以使用 409 状态码响应表示它无法完成请求处理。这种情况下，响应体可以包含资源数据两个版本之间的差异，格式由响应的````Content-Type````首部字段定义。

### 10.4.11 410 Gone

请求的资源在服务器上已经不再可用而且也不知道新的转发地址。这种情况希望被认为是永久的。具有链接编辑能力的客户端应该在用户确认之后删除该````Request-URI````的引用。如果服务端不知道，或者不方便确认此种情况是否是永久的，就应该使用 404(Not Found) 状态码代替。除非特殊说明，此响应是可缓存的。

410 状态码主要被用于 web 维护任务，通知通信参与者它请求的资源已经被有意设定为不可用状态，而服务器所有者希望指向该资源的远程链接被删除。这种事件通常用于临时的促销类服务，其资源并不一定位于服务器所在站点上。没有必要将所有的永久不可用资源为````gone````或者保持该标记任意长的时间段，决定权在服务器拥有者。

### 10.4.12 411 Length Required

服务器拒绝接受没有定义````Content-Length````的请求。客户端可以在添加了有效的包含了请求消息中消息体长度的````Content-Length````首部字段之后重发该请求。

### 10.4.13 412 Precondition Failed

通过一个或者多个请求首部字段给出的先决条件在服务端通过测试被判定为不满足。这个响应状态码允许客户端将当前资源元数据需要满足的先决条件放在请求首部字段中，这样就可以防止请求方法被应用在预期之外的资源上。

### 10.4.14 413 Request Entity Too Large

服务器拒绝处理请求，因为请求体超过了服务端希望或者能够处理的最大长度。服务端可以关闭连接以阻止客户端继续发送该请求。

如果只是临时的情况，服务端应该在响应中包含一个````Retry-After````首部字段来表示这种情况是临时的，经过多长时间之后客户端可以重试。

### 10.4.15 414 Request-URI Too Long

服务端拒绝服务该请求，因为请求中的````Request-URI````太长以至于服务端不愿意解读。这是一种比较少见的情况，只有在以下情况下才可能发生：客户端将携带大量查询信息的````POST````请求不合适地转化为````GET````请求时，当客户端请求进入重定向 URI 黑洞时（比如，重定向 URI 前缀指向它自己的后缀），或者当服务端处于客户端针对安全漏洞的攻击之下时（某些服务端使用固定长度的缓冲区来读取或者处理````Request-URI````）。

### 10.4.16 415 Unsupported Media Type

服务端拒绝为请求提供服务，因为请求体的格式并不被请求方法请求的资源所支持。

### 10.4.17 416 Requested Range Not Satisfiable

如果请求包含一个````Range````请求首部字段，同时不包含````If-Range````请求首部字段，而````Range````字段中的值均没有与当前选择的资源范围重叠，则服务端应该返回此状态码响应。（对字节范围来说，这就意味着所有 byte-range-spec 值的 first-byte-pos 值大于当前选中的资源的长度。）

如果为一个限定了资源字节范围的请求返回了此状态码响应，该响应应该包含一个````Content-Range````实体首部字段来表明当前选中资源的长度。此响应绝对不能使用````multipart/byteranges````内容类型。

### 10.4.18 417 Expectation Failed

当服务端不能满足请求的````Expect````请求首部字段，或者，服务器是一个代理，而服务端有明确证据表明下一条服务器挖法满足该请求的期望时，服务端应该返回此状态码响应。

## 10.5 服务端错误 5xx

以数字5开头的响应状态码表示服务器知道它自己在处理请求过程中发生了错误或者不具有处理请求的能力的情形。除了对````HEAD````方法请求的响应，服务器应该在该状态码响应体中包含一个数据实体，其中包含了错误情况的解释，以及钙错误是暂时的还是永久的。用户代理应该将该实体中的数据全部展示给用户。此类响应状态码适用于所有请求方法。

### 10.5.1 500 Internal Server Error

服务器发生了某些意料之外的情况，使得它无法满足请求要求。

 ### 10.5.2 501 Not Implemented

服务端不具备满足请求所需的功能。当服务党不认识请求方法因而无法支持它的任何资源请求时应该返回此状态码响应。

### 10.5.3 502 Bad Gateway

当服务器作为网关或者代理工作时，试图满足请求而访问上游服务器而从上游服务器接收到一个无效响应时应该返回此状态码响应。

### 10.5.4 503 Service Unavailable

服务器当前无法处理请求，因为暂时的过载或者服务器维护。这就意味着这种暂时的情况将在不久之后恢复正常。如果可以确定恢复时间，该事件就可以通过````Retry-After````首部字段说明。如果响应中没有给出该首部字段，客户端应该如同处理 500 状态码响应那样处理该响应。

注意：503 状态码的存在并不意味着服务器在过载时必须使用它。某些服务器更愿意直接拒绝连接。

### 10.5.5 504 Gateway Timeout

当服务器作为网关或者代理工作时，试图满足请求而访问上游服务器而没能及时从上游服务器接收到有效响应时应该返回此状态码响应。

注意：某些现存的代理会在 DNS 查找超时情况下返回 400 或者 500 状态码响应。

### 10.5.6 505 HTTP Version Not Supported

服务器不支持，或者拒绝支持，请求消息使用的 HTTP 协议版本。除了这个错误信息之外，服务端应该告诉客户端它不能活着不愿意完成该版本协议的请求。该响应应该包含一个数据实体，描述协议版本不支持的原因，以及服务端支持的另外的协议版本。

# 11 访问身份认证

HTTP 提供了几种可选的质疑－响应式的身份认证机制，可以被服务器用于质疑客户端请求，被客户端用于提供身份认证信息。通用的访问身份认证框架，以及 basic 和 digest 认证 的规范，都在"HTTP Authentication: Basic and Digest Access Authentication"。本规范从其中吸纳了````challenge````和````credentials````的定义。

# 12 内容协商

大部分响应包含一个数据实体，其中包含人类用户可以理解的信息。自然地，人们都希望服务器可以根据请求提供给用户最可用的数据实体。不幸的是，对于服务器和缓存来说，不同用户对于最好的评价标准是不同的，而且不同的用户代理解析各种实体类型的能力也不尽相同。因此，HTTP 提供了集中机制用于“内容协商”－也就是当有多种可用的表达方式时选择响应体采用的最好的表达方式的过程。

注意：没有叫做“格式协商”的原因是不同表达方式可能是同一种媒体类型，但是使用该类型的不同潜在能力，比如使用不同的语言等。

所有包含数据实体的响应都会经过内容协商，包括错误响应。

HTTP 协议中包含两种内容协商方式：服务端驱动的协商和客户端驱动的协商。两种方式是正交的，因此可以单独使用或者结合使用。结合使用的一种方法，被称为透明协商，当缓存使用初始服务器提供的客户端驱动协商信息为后续的请求提供服务端驱动的内容协商。

## 12.1 服务端驱动的协商

如果为响应选择最合适的表示形式由位于服务器上的算法完成，则称为服务端驱动的协商。选择是基于响应所有可用的表示形式（它可以变化的维度，比如语言或者内容编码等）以及请求消息的特定首部字段的内容，或者请求有关的其它信息（比如客户端的网络地址）。

服务端驱动的协商在选择算法很难向用户代理描述，或者服务器希望通过第一个响应发送它所认为的最优猜测给客户端（希望可以避免后续请求的往返延迟，如果该最优猜测对用户来说足够好）的情况下是优越的。为了改进服务端猜测，用户代理可以包含请求首部字段（````Accept````，````Accept-Language````，````Accept-Encoding````等等）来描述它想要的响应。

服务端驱动的协商存在不足：

1. 为所有给定用户正确选择最优响应表示形式实际上是不可能的，因为这需要了解用户代理的所有能力以及它们希望响应使用的表示形式的所有信息（比如，用户希望在屏幕上看还是在纸上打印？）。
2. 用户代理在每个请求中都描述他的能力是非常低效的，同时也是对用户隐私的潜在侵犯。
3. 为该请求产生响应的初始服务器和该算法的实现是非常复杂的。
4. 它限制了一个公共缓存为多个用户的请求使用相同响应的能力。

HTTP/1.1 包含下列请求首部字段通过描述用户代理能力和用户偏好以支持服务端驱动内容协商：````Accept````，````Accept-Charset````，````Accept-Encoding````，`````Accept-Language````以及````User-Agent````。然而，一个初始服务器可以不受限制地在这些维度上基于请求的任何方面修改响应，包括请求首部字段中的信息或者本规范未定义的扩展首部字段中的信息。

````Vary````首部字段可以被用于表达服务器在服务端驱动内容协商中使用的参数。

## 12.2 客户端驱动内容协商

使用这种方式时，为响应选择最好的表示方式的操作由用户代理执行，在它从初始服务器接收到初始的响应之后进行。选择基于初始响应首部字段或者数据实体包含的可用的响应表示形式列表，其中的每个表示形式都由相应的 URI 标识。选择操作可以自动执行（如果用户代理具有这种能力）或者由用户手动选择产生的菜单（可能是超文本）来完成。

客户端驱动内容协商在响应可以在通用的维度（比如类型、语言或者编码）上变化时，或者当初始服务器通过检查请求无法确定用户代理的能力时，或者更一般的当使用公共缓存来分散服务器负载和削减网络资源消耗时，更有优势。

这种协商方式的不足在于需要第二个请求来获取最好的替代表示形式。该第二个请求只有当使用缓存时才是有效率的。另外，本规范没有定义任何机制来支持自动选择，不过并没有阻止此类机制被开发作为 HTTP/1.1 的扩展使用。

HTTP/1.1 定义了 300 (Multiple Choices) 和 406 (Not Acceptable) 响应状态码来支持客户端驱动内容协商，当服务器不愿意或者不能基于服务端驱动内容协商提供一个响应变体。

## 12.3 透明协商

上述两种协商机制相结合就是透明协商。当一个包含所有可用的响应表示形式列表的缓存被提供（就像客户端驱动协商中那样），同时响应的所有变体维度都被缓存彻底理解，则该缓存就具有了代表初始服务器为该资源的后续请求执行服务端驱动内容协商的能力。

透明协商将协商工作进行了分布式，因而不需要初始服务器参与，同时削减了客户端协商中的第二个请求的往返延迟时间，当缓存能够准确猜出正确的响应。

本规范没有定义透明协商的任何实现机制，不过并没有阻止此类机制被开发作为 HTTP/1.1 的扩展使用。

# 13 HTTP 中的缓存

HTTP 协议典型地应用于分布式信息系统，可以通过使用响应缓存来改善性能。HTTP/1.1 协议包含大量元素来尽可能保证缓存工作。由于这些元素与协议的另外一边相互耦合，并且它们需要彼此互动，单独描述 HTTP 中的基本缓存设计和协议方法、首部、响应状态码等信息是非常必要的。

如果不能显著改善性能，则缓存就没什么用。HTTP/1.1 协议中的缓存的目标是在很多情况下消除发送请求的需求，同时在很多其它情况下消除发送完整响应的需要。前者为很多操作减少了网络往返延迟时间，我们使用超时机制实现此目标。后者降低了网络带宽需求，我们使用一种确认机制来实现此目标。

性能、可用性以及断开连接操作需要我们放松语义透明的目标。HTTP/1.1 允许初始服务器、缓存以及客户端在必要时显式削减语义透明度。然而，由于不透明的操作可能会迷惑非专家级的用户，同时可能与某些服务器应用不兼容。协议允许透明性被放松：

* 只能通过一个显式的协议层面的请求，当透明性被客户端或者初始服务器放松
* 只能连同一个显式的给最终用户的警告，当透明性被缓存或者客户端放松

因此，HTTP/1.1 协议提供了以下重要元素：

1. 如果所有参与者都需要完整的语义透明性，则有对应的协议特性来提供完整的语义完整性。
2. 允许初始服务器或者用户代理显示请求和控制非透明操作的协议特性支持。
3. 允许缓存当不保留请求的大致语义透明性时为响应附加警告的协议特性支持。

基本的原则就是，客户端必须能够检测到任何潜在的语义透明性放松。

注意：服务器、缓存或者客户端实现者可能会面临某些本规范未涉及的设计决策。如果某个决策可能影响语义透明性，实现者就有可能在维护语义透明性方面误入歧途，除非谨慎而完整的分析显示打破语义透明性可带来非常显著的好处。

### 13.1.1 缓存正确性

正确的缓存必须响应一个请求以它所持有的对应于该请求的最新的响应，它满足以下条件之一：

1. 它已经被检查并确认了与初始服务器可能已经返回的响应的等价性，通过由初始服务器对响应进行在验证。
2. 它足够新鲜。默认情况下，这意味着它满足了客户端、服务器以及缓存对数据新鲜性需求的最小约束。如果初始服务器这样指定，则它就只满足初始服务器的数据新鲜性需求。如果一个缓存的响应不够新鲜，也就是不能同时满足客户端和服务端的最多新鲜性需求约束，谨慎检测环境之后，缓存可以仍然返回该响应，但是需要包含一个合适的````Warning````首部字段，除非这个响应被一个````no-store````缓存指令或者````no-cache````缓存指令阻止。
3. 它是一个适当的 304 (Not Modified)，305 (Procy Redirect)，或者错误（4xx 或者 5xx）响应消息。

如果缓存无法与初始服务器通信，则一个正确的缓存应该以上述规则响应请求，如果响应可以基于缓存正确产生。如果不行，它就必须返回错误或者警告来表示发生了通信错误。

如果缓存接收到一个将要转发给发送请求的客户端的响应（要么是完整的响应，要么是 304 (Not Modified) 状态码响应），则接受到的响应就不再新鲜，缓存应该直接将其转发给客户端，而不需要添加一个新的````Warning````首部字段，同时也不需要删除已经存在的````Warning````首部字段。缓存不应该简单地因为在传输中响应过时而试图再验证它，这样可能导致一个无限循环。用户代理接收到一个不包含````Warning````首部字段的过时响应可以显示警告信息给用户。

### 13.1.2 警告

无论何时，如果缓存返回一个响应，该响应既不是第一手数据，也不是足够新鲜的（根据 13.1.1 章节中第二种情况判断），它就必须在响应中附加警告信息，使用````Warning````通用首部字段。该````Warning````首部字段和警告信息的最新定义在 14.46 中描述。该警告信息通知客户端采取响应的行动。

警告可以被用于其他目的，缓存相关的或者其他什么方面。警告的使用，与错误状态码不同，携带警告信息的响应并不是真正错误的响应。

警告信息被分配了三位数字的警告编码````warn-codes````。警告编码的首个数字表示在成功再验证之后该````Warning````是否必须从已缓存的数据实体中删除：

1xx 此警告描述响应的新鲜性或者再验证状态，因此在再验证成功之后必须被删除。1xx ````warn-codes````仅可以被缓存在验证一个缓存的数据实体时产生，而不能由客户端产生。

2xx 此警告描述响应体数据实体活着实体首部字段的某些没有被再验证纠正的方面（比如，响应体数据实体的有损压缩），因此在成功再验证之后绝对不能被删除。

参考 14.46 了解更多警告码定义相关信息。

HTTP/1.0 缓存将缓存响应中的所有````Warnings````，而不会删除上述第一类警告数据。传递给 HTTP/1.0 版本缓存的响应中的警告携带额外的````warning-date````字段，它可以防止后续的 HTTP/1.1 通信参与者错误地相信缓存的````Warning````。

警告同时还携带一个警告文本。该文本可以是任何人类语言形式，同时包含一个可选的标识符说明它所采用的字符集。

响应中可以携带多个警告，由初始服务器或者缓存来添加，不过这些警告的警告码都是相同的。比如，服务器可能会同时提供同一个警告的英语和巴斯克语版本。

当多个警告被添加到一个响应中，将它们全部显示给用户是不合理也无法操作的。本规范没有给出严格的确定这些警告信息显示优先级和顺序的规则，只是给出了一些启发式建议。

### 13.1.3 缓存控制机制

HTTP/1.1 中基本的缓存机制（服务端指定超时时间和验证器）是隐含的缓存指令。某些情况下，服务器或者客户端可能需要提供显式的 HTTP 缓存指令。我们通过````Cache-Control````首部字段来达到此目的。

````Cache-Control````首部字段允许客户端或者服务端在请求或者响应中传递大量指令。这些指令会覆盖默认的缓存算法。作为通用规则，如果首部字段值出现任何冲突，限制最严格的描述将会被采用（也就是说，最大程度上保留语义透明性）。然而，某些情况下，显式指定的缓存控制指令本身就是对语义透明性的破坏（比如````max-stale````或者````public````）。

缓存控制指令细节在 14.9 中描述。

### 13.1.4 显式用户代理警告

许多用户代理允许用户覆盖基本的缓存机制。比如，用户代理可能允许用户指定被缓存的数据实体（即使是显式的过时的）不需要验证。或者用户代理可能习惯性地为每个请求都加上````Cache-Control: max-stale=3600````。用户代理不应该默认为非透明行为，或者行为会导致不正常的无效率的缓存，但是可以被最终用户显式配置成那样。

如果用户已经覆盖了基本的缓存机制，用户代理应该在显示的结果信息中显式告知用户，当缓存机制不满足服务端的语义透明性需求（特别地，如果被显示的数据实体被获知是过时的）。由于协议正常情况下允许用户代理决定响应是否是过时的，所以该提示只需要在上述情况真实发生时显示。该提示也不一定是一个对话框，也可以是一个按钮，一张死鱼图片，或者是其它什么提示器。

如果用户用来覆盖缓存机制的方式会不正常地降低缓存的效率，则用户代理应该持续将此状态提示给用户（比如，显示一张燃烧的钞票的图片），这样以避免用户不经意间过度消耗资源或者遭受过度的延迟。

### 13.1.5 规则和警告的例外

某些情况下，缓存的操作者可以选择将它配置为返回过时的响应，即使客户端并未请求如此。这个决定不能草率做出，而应该有确实的必要，比如基于可用性活着性能考虑，特别是当缓存与初始服务器之间的网络连接质量非常差时。无论何时，当缓存返回过时的响应，它必须明确标示（使用````Warning````首部字段）该响应为过时的，以使得客户端软件可以提示用户可能存在潜在问题。

用户代理尝试获取第一手数据或者新鲜的响应当然是允许的。因此，如果客户端显式请求第一手数据或者新鲜的响应时缓存不应该返回过时的响应，除非由于技术或者政策原因而不可能实现。

### 13.1.6 客户端控制行为

由于初始服务器（处于次要地位的，中间缓存，按照它们在响应年龄中的贡献）是响应超时信息的主要来源，某些情况下，客户端可能需要控制一个缓存在返回一个缓存的响应之前是否需要验证它的决策。客户端使用若干指令和````Cache-Control````首部字段来实现此控制。

一个客户端的请求可以指定它愿意接受的未经验证的响应的最大年龄，该值指定为 0 会强制缓存再验证所有响应。客户端也可以制定响应超时之前的最小剩余时间。这两种设置都增加了缓存行为的约束，因而不能进一步放松缓存的近似语义透明性。

客户端也可以指定它将接受过时的响应，取决于过时的最大程度。这就放松了对缓存使用的约束，因此可能侵犯初始服务器对语义透明性的约束，但是这可能对支持离线操作是必需的，或者基于恶劣的连接性提供更高的可靠性的场景也是必需的。

## 13.2 超时模型

### 13.2.1 服务端指定超时

HTTP 缓存的最佳效果就是完全避免向初始服务器发出请求。避免请求的主要机制是初始服务器提供一个将来的显式超时时间，表示一个响应可以用来回应后续的请求。换句话说，缓存能够在不需要跟初始服务器联络的情况下返回一个新鲜的响应。

我们的期望是服务端将为响应配置将来的超时时间，基于相信该实体不太可能变化，在一种语义形式上，在该超时时间到达之前。此时通常会保留语义透明性，只要谨慎选择服务端超时时间。

超时机制只会应用于取自缓存的响应，而不会作用于被立即转发给请求客户端的第一手响应。

如果一个初始服务器希望强制一个语义透明的缓存验证每个请求，它可以分配一个显式的过去的超时时间。这就意味着响应永远是过时的，因此缓存应该在将它用于后续请求之前验证它。参考 14.9.4 章节了解更多约束方式来强制验证。

如果一个初始服务器希望强制任何 HTTP/1.1 缓存，无论它是如何配置的，验证每个请求，它就应该使用````must-revalidate````缓存控制指令。

服务端指定显式超时时间，要么使用````Expires````首部字段，要么使用````Cache-Control````首部字段的````max-age````指令。

超时时间不能用于强制用户代理刷新显示或者重新加载资源，该语义只能用于缓存机制，同时该机制只需要检查资源的超时状态，当一个关于该资源的新的请求被初始化时。参考 13.13 章节了解缓存和历史机制之间差异的说明。

### 13.2.2 启发式超时

又有初始服务器并不总是会提供显式的超时时间，HTTP 缓存通常会配置启发式超时时间，使用算法基于其它首部字段值（比如````Last-Modified````时间）来估计一个看似合理的超时时间。HTTP/1.1 规范并不提供指定算法，也不为它们的结果施加最坏情况下的性能约束。由于启发式超时时间可能伤害语义透明性，因而应该谨慎使用，同时我们鼓励初始服务器尽可能提供显式超时时间。

### 13.2.3 年龄计算

为了确认一个缓存的数据实体是否新鲜，缓存需要知道它的年龄是否达到了它的新鲜的生存时间。我们将在下一节中讨论如何计算新鲜生存时间，本节描述如何计算响应或者缓存数据实体的年龄。

在这里讨论中，我们使用术语````now````表示执行年龄计算的主机上的时钟的当前值。使用 HTTP 的主机，特别是运行着服务端程序和缓存的主机，应该使用 NTP 或者其他类似的协议来将它们的时钟与准确的世界时钟同步。

HTTP/1.1 需求初始服务器如果可能为每个响应发送一个````Date````首部字段，给出响应的产生时间。我们使用术语````date_value````来表示````Date````首部字段的值，该字段值的形式适合算术运算。

当从缓存获取响应时，HTTP/1.1 使用````Age````响应首部字段传输响应消息的大致年龄。该````Age````字段值是缓存估计的从响应产生或者由初始服务器再验证至今的时间。

本质上，````Age````字段值是响应在达到初始服务器的路径上的所有缓存中的驻留时间的总和，加上它在网络路径中传输的时间。

我们使用````age_value````字段来表示````Age````首部字段的值，形式适合算术运算。

响应的年龄可以通过两种完全独立的方法计算：

1. ````now - data_value````，如果本地时钟与初始服务器同步良好。如果结果是负值，则结果被替换为 0 。
2. ````age_value````，如果响应路径上的所有缓存都实现了 HTTP/1.1 协议。

有了这两种相互独立的方法，我们可以结合使用来计算响应年龄：

````
corrected_received_age = max(now - date_value, age_value)
````

由于我们基本上网络上基本同步的时钟，因此可以得到一个可靠的年龄计算结果。

由于网络传输延迟，服务器产生响应到该响应被下一跳缓存或者客户端收到，可能会经过一段较大的时间间隔。如果不进行修正，这种延迟将会导致不合理的超短的年龄。

由于导致返回````Age````值的请求必须在````Age````值产生之前初始化完成，我们可以通过记录请求初始化的时间点来修正网络传输延迟。然后，当一个````Age````值被接收到时，它就必须被解读为相对于请求初始化时间点的，而不是相对于响应被接收到的时间点。这种算法倾向于保守，无论有多少网络延迟。因此，我们计算：

````
corrected_initial_age = corrected_received_age + (now - request_time)
````

其中的````request_time````是导致该响应的请求的发送时间（基于本地时钟）。

总结年龄计算算法，当一个缓存接收到一个响应：

````
/*
* age_value
* 	is the value of Age: header received by the cache weith this response.
* date_value
*	is the value of the origin server's Date: header
* request_time
*	is the (local) time when the cache made the request that resulted in this cached response
* response_time
*	is the (local) time when the cache received the response
* now
*	is the current (local) time

apparent_age = max(0, response_time - date_value);
corrected_received_age = max(apparent_age, age_value);
response_delay = response_time - request_time;
corrected_initial_age = corrected_received_age + response_delay;
resident_time = now - response_tiem;
current_age = corrected_initial_age + resident_time;
````

其中一个缓存实体的````current_age````是该实体最近一次由初始服务器校验以来的时间加上````corrected_initial_age````。当一个响应从缓存实体产生，该缓存必须在响应中包含一个单独的````Age````首部字段，其值等于该缓存实体的````current_age````。

响应首部字段````Age````的出现意味着该响应不是一手数据。不过，反之并不成立。因为除了不存在这个首部字段，还需要请求路径上的所有缓存都是兼容 HTTP/1.1 的，才能说明该响应是一手数据。因为早期版本的 HTTP 缓存并没有实现````Age````首部字段。

### 13.2.4 超时计算

为了确定响应是新鲜还是过时，我们需要比较它的新鲜生存时间和它的年龄。年龄的计算方法在上一节中描述，本节介绍如何计算新鲜生存时间，然后确定响应是否超时。在下面的讨论中，时间值可以是任何适合算术运算的形式。

我们使用术语````expire_value````来表示````Expires````首部字段的值，使用术语````max_age_value````表示响应中```` Cache_Control````首部字段中的````max-age````指令携带的秒数的适当的值。

 ````max-age````指令的优先级高于````Expires````，因此，当响应中存在````max-age````时，计算很简单：

````
freshness_lifetime = max_age_value
````

否则，如果````Expires````存在于响应中时，计算方法为：

````
freshness_lifetime = expires_value - date_value
````

注意，所有这些计算方法都非常容易受到时钟扭曲的破坏，因为所有这些信息都来自初始服务器。

如果````Expires````，````Cache-Control:max-age````或者````Cache-Control:s-maxage````都没有在响应中出现，而且该响应也不包含别的对缓存的约束，缓存就可以使用启发式算法计算响应的新鲜生存时间。缓存必须为所有年龄超过 24 小时的响应都贴上````Warning 113````标识，如果它们还没有被贴上此标识。

而且，如果响应拥有````Last-Modified````时间，启发式的超时时间值就不应该超过从那个时间点以来的时间间隔的某个比例。这个比例典型的设定值可能是 10%。

计算响应是否超时也很简单：

````
response_is_fresh = (freshness_lifetime > current_age)
````

### 13.2.5 无二义性超时时间

因为超时时间设置倾向于乐观，所以有可能出现两个缓存包含同一个资源的不同新鲜值的情况。

如果客户端请求接收到一个非一手的响应，该响应在它自身的缓存中还是新鲜的，而且它的缓存中的数据实体中的````Date````首部字段比这个新的响应中的````Date````还要新，则客户端可以忽略该响应。如此一来，它可以重发该请求包含````Cache-Control:max-age=0````指令，以强制由初始服务器检查确认。

如果缓存拥有两个新鲜的相同表现形式、不同验证器的响应，它必须使用其中具有更新的````Date````首部字段的那个。这种情况在一个缓存将来自其它缓存的响应进行池化，或者当一个客户端要求重新加载或者再验证一个看起来新鲜的缓存数据实体时可能出现。

### 13.2.6 无二义性多个响应

因为客户端可能接收到来自多个路径的响应，这样就会有些响应流通过一系列的缓存，而其它响应流经过另外一些缓存，客户端接收到响应的顺序可能跟初始服务器发出它们的顺序不同。我们希望客户端使用最新产生的响应，尽管稍微老一些的响应仍然也是新鲜的。

实体标签或者超时时间都不能给响应强加上顺序，因为后面到来的响应可能会携带一个更早的超时时间。````Date````首部的值是秒粒度的。

当客户端试图再验证一个缓存数据实体，同时接收到的响应包含一个````Date````首部字段，而该字段的值看起来要比存在的缓存实体更老，则客户端就应该无条件重发该请求，请求携带：

````
Cache-Control: max-age=0
````

以强制相关的缓存向初始服务器验证它们缓存的数据，或者携带：

````
Cache-Control: no-cache
````

以强制所有相关的缓存从初始服务器获取一份新的数据。

如果````Date````字段相等，则客户端可以使用随便哪个响应，如果确实需要非常谨慎，就请求一个新的响应。服务端绝对不能指望客户端能够分辨在同一秒钟产生的响应，如果它们的超时时间是重叠的。

## 13.3 验证模型

当缓存包含一个过时的数据实体，而它想要将其作为一个客户端请求的响应，它首先必须与初始服务器确认（或者是一个包含一个新鲜响应数据的中间缓存）它缓存的数据实体是否仍然可用。我们称该过程为"验证"缓存实体。由于我们不希望在缓存的实体可用时从初始服务器重新获取，同时我们也希望在缓存的实体可用时避免额外的往返延迟，HTTP/1.1 协议支持使用条件方法。

支持条件方法的关键协议特性都是关于缓存验证器的。当初始服务器产生一个完整的响应，它会附加一些验证器到其上，和实体一起被缓存。当客户端（用户代理或者代理缓存）发出一个条件请求道一个资源，而该资源它已经拥有缓存实体，它就可以在请求中包含相关的验证器。

服务端接下来将实体中的验证器与当前验证器相比较，如果它们匹配，就响应以特定的响应状态码（通常是 304 Not Modified）的无实体响应。否则，它返回一个完整响应（包含实体）。因此，我们避免了在验证器匹配时传输完整响应，同时在验证器不匹配时避免了额外的往返延迟。

在 HTTP/1.1 中，同一个资源的条件请求看起来与正常的请求几乎完全一样，除了它携带了一个特殊的首部字段（其中包含了验证器）来显式地将请求方法（通常是 GET）转换为条件方法。

协议中包含了缓存验证条件的肯定意义和否定意义。也就是说，当且仅当验证器匹配时请求方法才会被执行，同时，当且仅当验证器不匹配时请求方法才不会被执行。

注意：缺少验证器的响应仍然能够被缓存，也能够被缓存用于响应请求直到它超时实效，除非通过一个````cache-control````指令显式禁止。然而，缓存不能发出条件请求，如果它没有关于实体的验证器，这意味着该实体实效之后将不会被刷新。

### 13.3.1 最近修改时间

````Last-Modified````实体首部字段值通常用于缓存验证器。简单来说，一个缓存实体可用的标志是自从````Last-Modified````值表示的时间以来没有被修改过。

### 13.3.2 实体标签缓存验证器

````ETag````响应首部字段值，一个实体标签，作为一个潜在的缓存验证器。可能允许更可靠的验证，如果某些情况下不方便存储修改时间，比如秒粒度的 HTTP 时间值不足够精确，或者初始服务器希望避免某种因为修改时间的使用而造成的似是而非的情况。

### 13.3.3 弱验证器和强验证器

因为初始服务器和缓存都会比较两个验证器以确定它们解读的是不是相同的数据实体，通常我们希望如果数据实体（实体主体或者任何实体首部字段）发生任何变化时，相关的验证器也会随之改变。如果确实如此，我们将这种验证器称为强验证器。

然而，很多时候服务器可能希望验证器只是在数据实体发生明显的语义改变时响应的验证器才发生变化，这种不会随时都随着数据实体变化的验证器称为弱验证器。

实体标签通产是强验证器，但是协议提供了一种将实体标签标记为弱验证器的机制。我们可以这样理解，强验证器在数据实体任何一个数据位发生变化时就会变化，弱验证器只会在数据实体的含义发生明显变化时才会变化。换句话说，可以认为强验证器是一个特定数据实体的标识符的一部分，弱验证器是一系列语义等价的数据实体的标识符的一部分。

注意：强验证器的一个例子是持久化存储中的一个整数，实体每次变化时该整数就会增加。

实体的变化时间，如果以秒粒度表示，可以作为一个弱验证器，因为资源可能在一秒钟之内发生两次修改。

对弱验证器的支持是可选的。然而，弱验证器可以提供对等价对象的更高效的缓存。比如，一个站点的点击数每隔几天或者几周更新就可能是足够好的，这个期间内的任何值对“足够好”这个标准来说都是等价的。

验证器的使用发生在客户端产生一个请求，而该请求的验证首部字段中包含该验证器的情况下，或者当服务端比较两个验证器之时。

强验证器用在任何上下文中。弱验证器只是用在哪些不依赖一个数据实体的严格相等的上下文中。比如，两者都可以用户一个完整数据实体的条件 GET。然而，只有强验证器才能用于子范围查询，因为否则客户端就可能以本质上不一致的数据实体结束。

客户端可以为简单（非子范围）GET 请求使用强验证器或者弱验证器。客户端绝对不能为其它形式的请求使用弱验证器。

HTTP/1.1 协议定义的有关验证器的唯一功能就是比较操作。协议中存在两个验证器的比较函数，取决于比较上下文是否允许使用弱验证器：

* 强比较函数：为了被认为是相等的，两个验证器必须在各方面都是相同的，而且都绝对不能是弱验证器。
* 弱比较函数：为了被认为是相等的，两个验证器必须在各方面都是相同的，不过它们可以被贴上弱验证器标签，而不会影响比较结果。

一个实体标签是强验证器，除非它被显式贴上了弱验证器标签。

````Last-Modified````时间，当在请求中被作为验证器使用时，是隐含的弱验证器，除非使用下述规则可以推断出它是强验证器：

* 该验证器正在被初始服务器为了数据实体与实际的当前验证器进行比较，而且，
* 初始服务器可靠地知道相关的数据实体没有在请求中存在的验证器覆盖的那一秒时间内发生两次变化。

或者：

* 该验证器将要被客户端用在````If-Modified-Since````或者````If-Unmodified-Since````首部字段中，因为客户端拥有相关数据实体的一个缓存实体，而且，
* 该缓存实体包含一个````Date````值，给出了初始服务器发送初始响应的时间，而且，
* 出现的````Last-Modified````时间至少比````Date````值提前 60 秒。

或者：

* 该验证器正在被中间缓存为数据实体与它所缓存的实体中的验证器进行比较，而且，
* 缓存的数据实体包含一个````Date````值，给出了初始服务器发送初始响应的时间，而且，
* 出现的````Last-Modified````时间至少比````Date````值提前 60 秒。

此方法基于这样的事实：如果两个不同的响应由初始服务器在同一秒发出，然而都包含相同的````Last-Modified````时间，则至少其中一个响应将包含一个````Date````字段值等于它自己的````Last-Modified````时间。强制的 60 秒限制防止了````Date````和````Last-Modified````值由不同时钟产生的可能性，或者在响应产生过程中的其它不同时间产生的可能性。协议实现可以使用一个大于 60 秒的值，如果它认为 60 秒时间太短了。

如果客户端想要执行一个子范围查询，但是它只有一个````Last-Modified````时间而没有隐含的验证器，它就可以这么做，仅当该````Last-Modified````时间在这种情况下是强验证器。

缓存或者初始服务器接收到一个条件请求，不同于一个包含完整请求体的 GET 请求，必须使用强比较函数来评价其条件。

这些规则允许 HTTP/1.1 缓存和客户端基于从 HTTP/1.0 初始服务器获取的数据安全地执行子范围查询。

### 13.3.4 实体标签和````Last-Modified````时间使用时机规则

我们采取了一系列的规则和推荐为了初始服务器、客户端、以及缓存关于何时各种验证器类型应该被使用，以及为了何种目的而使用。

HTTP/1.1 初始服务器：

* 应该发送一个实体标签验证器，除非它不能产生实体标签。
* 可以发送一个弱实体标签替代一个强实体标签，如果性能考量支持弱实体标签的使用，或者如果发送一个强实体标签是不可行的。
* 应该发送一个````Last-Modified````值，如果可以的话，除非使用````If-Modified-Since````首部字段中的时间带来的语义透明性的损失可能导致严重问题。

换句话说，HTTP/1.1 初始服务器比较好的做法是同时发送一个强实体标签和一个````Last-Modified````值。

为了确保合法，相关实体值发生任何形式的变化强实体标签必须改变。而弱实体标签在相关实体发生语义层面的显著变化时才应该改变。

注意：为了提供语义透明性缓存，初始服务器必须避免为两个不同的数据实体重用一个特定的强实体标签值，或者为两个语义不同的数据实体重用一个特定的弱实体标签。缓存实体可能保存任意长的时间，无论超时时间如何，因此期待缓存将永远不会再次试图使用它在过去某个时间点获得的验证器再验证一个实体是不妥当的。

HTTP/1.1 客户端：

* 如果一个实体标签已经被初始服务器提供出来，就必须使用该实体标签在所有来自缓存的请求中（使用````If-Match````或者````If-None-Match````）。
* 如果初始服务器只提供了````Last-Modified````值，就应该使用该值在来自缓存的非子范围请求（使用````If-Modified-Since````）。
* 如果 HTTP/1.0 服务器只提供了````Last-Modified````值，可以使用该值在来自缓存的子范围请求中（使用````If-Modified-Since````）。用户代理应该提供一种方式来使之不可用，万一遇到困难。
* 如果初始服务器同时提供了实体标签和````Last-Modified````值，应该同时使用这两种验证器在来自缓存的请求中。这就允许 HTTP/1.0 和 HTTP/1.1 缓存进行适当的响应。


HTTP/1.1 初始服务器收到一个条件请求，而该请求同时包含一个````Last-Modified````时间（比如，在````If-Modified-Since````或者````If-Unmodified-Since````首部字段中）和一个或者多个实体标签（比如，在````If-Match````、````If-None-Match````或者````If-Range````首部字段中）作为缓存验证器，它绝对不能返回一个 304 （Not Modified）状态码响应，除非这样做与请求中的所有的条件首部字段都是一致的。

HTTP/1.1 缓存代理收到一个条件请求，如果该请求中同时包含作为缓存验证器的````Last-Modified````时间和一个或者多个实体标签，它绝对不能返回一个本地缓存的响应给客户端，除非该缓存的响应与请求中所有的条件首部字段都是一致的。

注意：这些规则背后的基本原则是，HTTP/1.1 服务器和客户端应该在请求和响应中传输尽可能无冗余的信息。接收这些信息的 HTTP/1.1 系统将对它们接收到的验证器进行最保守的假定。

HTTP/1.0 客户端和缓存将忽略实体标签。通常，这些系统接收或者使用的最近修改时间值将支持透明和有效的缓存，因此，HTTP/1.1 初始服务器应该提供````Last-Modified````值。在其它某些罕见情况下，HTTP/1.0 系统使用````Last-Modified````值作为缓存验证器将可能导致严重问题，因此 HTTP/1.1 初始服务器就不应该提供该值。

### 13.3.5 非验证条件

实体标签背后的原则是只有服务作者才透彻了解资源的语义，因而可以选择合适的缓存验证机制，同时，任何复杂程度超过字节相等的验证器比较函数的规范都可能引入潜在问题。因此，其它首部字段的比较（除了````Last-Modified````，为了兼容 HTTP/1.0）都永远不用被用于缓存实体的验证。

## 13.4 响应可缓存性

除非通过缓存控制指令特别指定，缓存系统可以用于存储一个成功的响应作为缓存实体，如果足够新鲜就可以无需验证而返回它，同时可以在验证成功之后返回它。如果响应既没有缓存验证器，也没有显式的超时时间，我们就不希望它被缓存，不过某些缓存会违反这个期望（比如，当网络很差的情况下）。客户端通常能够通过比较````Date````首部字段值与当前时间而检测出这种响应。

注意：一些 HTTP/1.0 缓存是众所周知的会打破这个期望，而不会给出任何````Warning````。

不过，某些情况下缓存保存一个数据实体、或者在后续请求的响应中返回它可能是不合适的。这可能是因为绝对的语义透明性被服务作者认为是必需的，或者是因为安全或者隐私考量。某些缓存控制指令被引入，来允许服务器可以说明某些资源实体、或者其部分内容，无论如何都是不能被缓存的。

14.8 章节通常阻止一个共享缓存保存和返回响应给一个稍早的请求，如果该请求包含一个````Authorization````首部字段。

状态码为 200、203、206、300、301 或者 410 的响应可以被缓存保存并用于响应后续的请求，由超时机制约束，除非一个缓存控制指令阻止了缓存。然而，不支持````Range````和````Content-Range````首部字段的缓存绝对不能缓存 206 状态码（部分内容）响应。

接收到的其它状态码的响应绝对不能被作为后续请求的回应被返回，除非有缓存控制指令或者其它首部字段显式允许这么做。例如，````Expires````首部字段，````max-age````，````s-maxage````，````must-revalidate````，````proxy-revalidate````，````public````或者````private````缓存控制指令。

## 13.5 从缓存构造响应

HTTP 缓存的目标是存储从响应中获得的信息以便在将来的请求到来时使用。很多情况下，缓存简单地返回响应的合适部分给请求者。然而，如果缓存持有的缓存数据实体是基于先前的响应，它就必须将新的响应的某些部分与它持有的缓存数
据实体组合起来。

### 13.5.1 端到端首部和逐跳首部

为了定义缓存和无缓存的代理的行为，我们将 HTTP 首部字段分为两类：

* 端到端首部，被传输到请求或者响应的最终接收者。响应中的端到端首部字段必须作为缓存实体的一部分被存储，同时必须在任何来自此缓存实体的响应中被传输。
* 逐跳首部，只是对单个的传输层连接有意义，不会被缓存存储或者被代理转发。

以下 HTTP/1.1 首部字段是逐跳首部字段：

* ````Connection````
* ````Keep-Alive````
* ````Proxy-Authenticate````
* ````Proxy-Authorization````
* ````TE````
* ````Trailers````
* ````Transfer-Encoding````
* ````Upgrade````

所有 HTTP/1.1 定义的其它首部字段都是端到端首部字段。

其它逐跳首部字段必须被列入````Connection````首部字段中，将会被引入 HTTP/1.1 或者稍后将被引入。

### 13.5.2 不可修改首部字段

某些 HTTP/1.1 协议特性，比如 Digest Authentication，依赖于某些端到端首部字段的值。透明代理不应该修改端到端首部字段，除非该首部字段的定义需要或者特地允许那样做。

透明代理绝对不能修改请求或者响应中的下列任何首部字段，同时也绝对不能添加这些字段，如果它们不存在：

* ````Content-Location````
* ````Content-MD5````
* ````ETag````
* ````Last-Modified````

透明代理绝对不能修改响应中的下列字段：

* ````Expires````

但是它可以添加这些字段，如果它们不存在。如果一个````Expires````首部字段被添加，它必须被赋予一个字段值，等于该响应中````Date````首部字段的值。

代理绝对不能修改或者添加任何包含````no-transform````缓存控制指令的消息中的下列字段，或者任何请求中的下列字段：

* ````Content-Encoding````
* ````Content-Range````
* ````Content-Type````

不透明代理可以修改或者添加这些字段到一条不包含````no-transform````缓存控制指令的消息中，但是如果它这么做了，它就必须添加一个 Warning 214 (Transformation applied) 如果它并没有出现在该消息中。

警告：不必要的端到端首部字段的修改可能导致身份认证失败，如果强认证机制在后续版本的 HTTP 版本中被引入。这种认证机制可能基于某些并未在这里列出的首部字段的值。

请求或者响应的````Content-Length````字段被添加或者删除基于 4.4 章节介绍的规则。透明代理必须保留实体主体的实体长度，尽管它可能修改传输长度。

### 13.5.3 组合首部

当缓存向服务器发出认证请求，并且服务器提供了一个 304（Not Modified）状态码响应或者一个 206（Partial Content）状态码响应，该缓存接下来构造一个响应并发送给请求客户端。

如果状态码是 304（Not Modified）则缓存使用存储的缓存实体的实体主体作为它发送出去的响应的实体主体。如果状态码事 206（Partial Content）同时````ETag````或者````Last-Modified````首部字段精确匹配，缓存可以将存储在缓存实体中的内容和新接收到的响应的内容组合起来作为它发出的响应中的实体主体。

存储在缓存实体中的端到端首部字段会被用于构造响应，除非：

* 任何存储的````Warning````首部字段连同警告编码 1xx 必须被从缓存实体和转发的响应中删除。
* 任何存储的````Warning````首部字段连同警告编码 2xx 必须被保留在缓存实体和转发的响应中。
* 任何在 304 或者 206 状态码响应中提供的端到端首部字段必须替换缓存实体中对应的首部字段。

除非缓存决定删除缓存实体，它必须同时用接收到的响应中端到端首部字段替换缓存实体中的对应字段，除了上面刚刚提到的````Warning````首部字段。如果到来的响应中的一个首部字段名对应于缓存实体中多个首部字段，所有这些老首部字段都必须被替换。

换句话说，接收到的响应中的端到端首部字段集合会覆盖缓存实体中的所有对应的端到端首部字段（除了存储的警告编码为 1xx 的````Warning````首部字段，即使没有被覆盖也会被删除）。

注意：这条规则允许初始服务器使用 304（Not Modified）或者 206（Partial Content）响应来更新前一个携带相同数据实体或者部分实体数据的响应中的任何首部字段，尽管这么做可能并不永远是合理或者准确的。这条规则不允许初始服务器使用 304 （Not Modified）或者 206（Partial Content）状态码响应来完全删除一个由前一个响应提供的首部字段。

### 13.5.4 组合字节范围

一个响应可能仅仅传输数据实体主体的某个子范围的字节内容，要么是因为请求包含一个或者多个````Range````规范，要么是因为连接被过早断开。经过若干次这种传输，缓存可能已经接收到同一个数据实体主体的若干个范围的数据。

如果缓存已经存储了一个数据实体数据的子范围的非空集合，同时一个到来的响应传输了另外一个子范围数据，缓存可以组合新的子范围数据和已经存在的集合，如果下面两个条件同时满足：

* 到来的响应和缓存的实体都包含一个缓存验证器。
* 这两个缓存验证器使用强比较函数进行匹配，结果为真。

如果两个条件任何一个不满足，缓存必须只使用最新的分片响应（基于每个响应携带的````Date````值，同时使用新到来的响应，如果这些值相等或者不存在），同时必须丢弃其它部分分片信息。

## 13.6 缓存协商响应

使用服务端驱动的内容协商，如同在响应中使用````Vary````首部字段所表示的，可以改变缓存可以为后续请求使用该响应的条件和过程。参考 14.44 章节了解由服务端使用````Vary````首部字段的细节。

服务器应该使用````Vary````首部字段来通知缓存，该缓存使用请求首部字段在多个可缓存的响应的表现形式中基于服务端驱动的内容协商进行选择。由````Vary````字段值命名的首部字段集合作为周知的 ````selecting````请求首部字段。

当缓存接收到一个后续请求，该请求的````Request-URI````指定了一个或者多个包含````Vary````首部字段的缓存实体，缓存就绝对不能使用这种缓存实体来为新的请求构造响应，除非新的请求中所有的````selecting````请求首部匹配到被缓存的初始请求中的请求首部字段。

来自两个请求的````selecting````请求首部字段被定义为是匹配的，当且仅当第一个请求中的该字段只需要通过在对应的 BNF 允许的位置添加或者删除线性空白（LWS）就可以转化为第二个请求中的该字段，并且／或者组合多个相同字段名的消息首部字段，遵循 4.2 章节中的消息首部字段规则。

````Vary````首部字段的值"*"永远不会匹配，因而后续对该资源的请求就只能被初始服务器合适地解读。

如果缓存的数据实体中的````selecting````请求首部字段无法匹配到新的请求中的相应首部字段，则缓存绝对不能使用缓存实体来满足该请求，除非它首先将新的请求以一个条件请求的形式中继给初始服务器，然后服务器回复 304（Not Modified）状态码响应，包含一个实体标签或者````Content-Location````来表示该实体将被使用。

如果一个实体标签呗分配给一个缓存的表示形式，被转发的请求应该是条件式的，并且该实体标签被包含在来自关于被请求的资源的所有缓存实体的````If-None-Match````首部字段中。这会将当前呗缓存持有的实体集合传输给服务器，因此，如果其中任何一个实体匹配到被请求的实体，服务器就可以使用````ETag````首部字段在它的 304（Not Modified）响应中，来告诉缓存哪个数据实体是合适的。如果新的响应的实体标签匹配到已经存在的实体，新的响应就应该被用来更新已经存在的实体中的首部字段，而且该结果必须被返回给客户端。

如果所有存在的缓存实体只包含相应实体的分片内容，它的实体标签就不应该被包含在````If-None-Match````首部字段中，除非该请求所需要的数据范围可以被该实体完全满足。

如果缓存接收到一个成功的响应，其````Content-Location````字段匹配到已经存在的具有相同````Request-URI````的缓存实体，其实体标签不同于存在的实体，其````Date````比存在的实体要更加新鲜，则已经存在的实体不应该被在响应中返回，同时应该被从缓存中删除。

## 13.7 共享和非共享缓存

基于安全和因此考虑，有必要区分共享和非共享缓存。非共享缓存只允许一个用户访问，这种情况下的可访问性应该被合适的安全机制约束。所有其它的缓存都被认为是共享缓存。本规范的其它章节介绍了施加在共享缓存操作之上的某些约束，来防止访问控制失败或者隐私泄露。

## 13.8 错误或者不完整的响应缓存行为

当缓存接收到不完整的响应（比如，响应体中的数据字节数小于````Content-Length````首部字段中给出的数值），它可以缓存该响应。不过缓存必须将其作为一个分片响应对待。分片响应可以被如 13.5.4 章节中描述的那样组合起来，组合的结果可以是完整的响应，或者仍然是响应分片。缓存绝对不能将分片响应返回给客户端，除非特别说明它应该这么做，同时必须使用 206（Partial Content）状态码。缓存绝对不能使用 200（OK）状态码返回分片响应。

如果缓存在试图重验证数据实体时接收到一个 5xx 状态码响应，它可以要么将该响应转发给客户端，要么将这种情况当作服务端响应失败处理。后者情况下，它可以返回一个先前接收到的响应，除非之前缓存的数据实体包含````must-revalidate````缓存控制指令。

## 13.9 GET 和 HEAD 的副作用

除非初始服务器显式阻止它们发送的响应被缓存，对任何资源使用的````GET````和````HEAD````方法不应该有副作用，如果这些响应来自缓存，它们也不会导致错误的行为。它们可以仍然拥有副作用，但是缓存并不强制需要在他的缓存决策中考虑这种副作用。缓存永远被期待观察来自初始服务器的显式缓存限制。

这条规则的一个例外：因为一些应用按照传统对查询 URL（那些````rel_path````部分包含````?````）使用````GET````和````HEAD````方法来执行某些副作用明显的操作，缓存绝对不能将这种响应当作新鲜的，除非服务器提供了显式的超时时间。特别地，这就意味着来自 HTTP/1.0 服务器的对这种 URL 的响应都不应该来自缓存。参考 9.1.1 章节获取更多相关信息。

## 13.10 更新或者删除之后的失效

在初始服务器上的资源上执行某些方法可能会导致一个或者多个现存的缓存实体变为不透明不可用状态。也就是说，尽管它们可能仍然是“新鲜”的，当时却已经不能精确反映初始服务器将会为该资源的下一次新的请求返回的响应。

HTTP 协议无法保证所有这些缓存实体都被标记为不可用。比如，在初始服务器上导致变化的请求可能并没有经过存储缓存实体的代理服务器。不过，还是存在一些规则帮忙减少类似的错误行为。

在本节中，术语“使实体失效”意味着缓存将要么从它的存储中删除数据实体的所有实例，要么将它们标记为“失效的”因而在它们被作为响应返回给下一个请求之前必须经过再认证。

某些 HTTP 方法必须导致缓存将一个数据实体标记为失效的。该数据实体要么是其````Request-URI````指向的，要么是由````Location````或者````Content-Location````首部字段（如果存在）指定。这些方法有：

* PUT
* DELETE
* POST

为了防止拒绝服务攻击，基于````Location````或者````Content-Location````首部字段中的 URI 的失效只有当其 host 部分与````Request-URI````中一致时才能执行。

当缓存传输它无法理解其请求方法的请求时应该马上将该请求的````Request-URI````指向的所有数据实体都标记为失效的。

## 13.11 强制写穿透

所有希望修改初始服务器上的资源的请求方法都必须被穿透缓存写入到初始服务器上。目前包括除了````GET````和````HEAD````之外的所有方法。缓存绝对不能在将此类方法的请求发送到初始服务器并接收到来自初始服务器的对应响应之前就回复客户端。这并不阻止代理缓存在初始服务器彻底发送完成它的最终回复之前发送 100（Continue）状态码响应。

替代方案，比如众所周知的“回写”缓存等方式在 HTTP/1.1 中是不允许的，由于很难保证一致性更新，同时服务器、缓存或者网络失效等问题都可能在回写完成之前发生。

## 13.12 缓存更新

如果一个新的可缓存的响应被接收到，同时存在关于同一个资源的响应已被缓存，缓存服务器就应该使用新的响应回复当前请求。它可以将这个新的响应添加到缓存存储中去，或者也可以，如果这个新的响应满足所有其它要求，用它回复所有本来可能导致旧的响应被返回的请求。如果缓存将这个新的响应添加到存储中，则应用 13.5.3 章节中的规则。

注意：具有相对于已缓存的响应更老的````Date````首部字段值得新响应是不可缓存的。

## 13.13 历史列表

用户代理经常使用历史机制，比如“后退”按钮和浏览历史列表，来重新显示会话中早先接收到的数据。

历史机制和缓存是不同的。特别地，历史机制不应该试图显示一个资源当前状态的语义透明视图。历史机制的含义恰恰是展示该资源的数据在早先被接收到时的样子。

默认情况下，历史机制不受超时时间影响。如果一个数据实体存在于存储空间中，即使已经超时，历史机制仍然应该展示它。除非用户显式配置用户代理刷新超时的历史数据。

这样并没有禁止历史机制告诉用户他们现在看到的视图已经过时了。

注意：如果浏览历史列表机制对防止用户浏览过时的资源是不必要的，则会倾向于强制服务开发者避免使用 HTTP 超时控制和缓存控制，不然他们很可能希望使用这些特性。服务开发者可能认为用户在使用他们的导航栏按钮，比如后退等浏览早先获取的数据时不会看到警告或者错误信息是重要的。某些时候资源甚至是不应该被缓存的，或者应该很快超时失效。用户接口考虑可能会强迫服务作者重新对阻止缓存的结果进行考量，以避免不恰当的历史机制引发的问题。

# 14 首部字段定义

本节定义所有标准 HTTP/1.1 首部字段的语法和语义。对实体首部字段来说，*发送方*和*接收方*都既可以表示客户端或者服务器，具体含义取决于它是发送实体还是接收实体。

## 14.1 Accept

````Accept````请求首部字段可以被用来指定能够接受的响应的特定的媒体类型。````Accept````首部可以被用于表示请求被特别限定在一个期待类型的很小集合内，就像请求一个内嵌图像的请求中那样。

````xml
Accept				= "Accept" ":" # ( media-range [ accept-params ] )
media-range			= ( "*/*"
						| ( type "/" "*" )
						| ( type "/" subtype )
						) * ( ";" parameter )
accept-params		= ";" "q" "=" qvalue * ( accept-extension )
accept-extension	= ";" token [ "=" ( token | quoted-string ) ]
````

星号字符“*”用来将媒体类型进行区间分组，用“\*/\*”表示所有的媒体类类型，“type/\*”表示给定类型的所有子类型。````media-range````可以包含能够应用于该区间的媒体类型参数。

每个媒体区间后面可以跟随着一个或者多个````accept-params````，以````q````参数开头，表示相对质量比率。第一个````q````参数（如果存在）将````media-range````参数与````accept-params````分隔开。质量比率允许用户或者用户代理表示该媒体区间的期望的相对质量比率，使用的 qvalue 范围从 0 到 1，默认值是````q=1````。

注意：使用````q````参数名分隔媒体类型和````Accept````扩展参数是一种历史实践。尽管这样做阻止了媒体区间内使用任何名为````q````的媒体类型参数，在 IANA 媒体类型注册中心中不包含````q````参数没什么问题，同时在````Accept````中使用那种媒体类型参数也是很罕见的。将来的媒体类型也不推荐注册任何名为````q````的参数。

例子：

````
Accept: audio/*; q=0.2, audio/basic
````

应该被解读为：我更想要````audio/basic````类型，不过如果在质量降低 80% 之后是最佳可用类型，则只要是任何````audio````类型，我都可以接受。

如果````Accept````首部字段不存在，则可以假定客户端可以接受所有媒体类型。如果````Accept````首部字段存在，同时服务器不能发送符合组合的````Accept````字段值所表示的可接受媒体类型的响应，则服务器应该发送一个 406（Not Acceptable）状态码响应。

稍微复杂一些的例子：

````
Accept: text/plain; q=0.1, text/html,
		text/x-dvi; q=0.8, text/x-c
````

按照字面含义，它可以被解读为：我更希望得到````text/html````和````text/x-c````媒体类型，但是如果它们不存在，则发送````text/x-dvi````数据实体，如果该类型也不存在，就发送````text/plain````媒体类型的数据实体。

媒体类型范围会被更精确的媒体类型范围或者特定的媒体类型覆盖。如果不止一个媒体类型范围应用于一个给定类型，则最精确的那个将是优先应用的。比如：

````
Accept: text/*, text/html, text/html; level=1, */*
````

具有以下优先顺序：

1. ````text/html; level=1````
2. ````text/html````
3. ````text/*````
4. ````*/*````

与给定类型相关的媒体类型质量比率由发现的匹配该类型的具有最高优先级的媒体类型范围确定。比如：

````
Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
		text/html;level=2;q=0.4, */*;q=0.5
````

将导致下面的赋值关系：

````
text/html;level=1		= 1
text/html				= 0.7
text/plain				= 0.3
image/jpeg				= 0.5
text/html;level=2		= 0.4
text/html;level=3		= 0.7
````

注意：一个用户代理可能被提供某个媒体类型范围内的一个质量比率值的默认集合。然而，除非该用户代理是一个关闭系统而不能与其它工作着的用户代理交互，该默认集合应该由用户自己配置。

## 14.2 Accept-Charset

````Accept-Charset````请求首部字段可以被用来表示客户端可以接受何种字符集的响应。该字段允许客户端能够理解更全面或者特殊用途的字符集向服务器发出能够表示这些字符集中的文档的能力。

````
Accept-Charset = "Accept-Charset" ":"
				1#( ( charset | "*" )[ ";" "q" "=" qvalue ] )
````

字符集值在 3.4 章节中描述。每个字符集可以连同质量值一起被提供，以表示用户对该字符集的喜好。默认的质量值是````q=1```` 。例子：

````
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
````

特定的值"*"，如果出现在````Accept-Charset````字段中，会匹配到````Accept-Charset````首部字段中没有提到的每个字符集（包括 ISO-8859-1）。如果该值没有出现在该首部字段中，则所有没有显式提到的字符集都会获得质量值 0 ，除了 ISO-8859-1，如果没有被显式提到，这个字符集将得到质量值 1 。

如果````Accept-Charset````首部字段没有出现，则默认可以接受任何字符集。如果存在````Accept-Charset````首部字段，而服务器不能发送该首部字段指出的可接受字符集的响应，则服务器应该发送一个错误响应，状态码为 406（Not Acceptable），不过发送一个不可接受的响应也是允许的。

## 14.3 Accept-Encoding

````Accept-Encoding````请求首部字段类似于````Accept````，但是限制可接受的响应内容编码。

````
Accept-Encoding	= "Accept-Encoding" ":"
					1#( codings [ ";" "q" "=" qvalue ] )
codings			= ( content-coding | "*" )
````

该字段的使用例子：

````
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
````

服务器检查按照下面规则，根据````Accept-Encoding````首部字段确定内容编码是否可接受：

1. 如果内容编码是````Accept-Encoding````首部字段中列出的内容编码之一，则它是可接受的。除非它还伴随着 qvalue 为 0。（3.9章中的定义，质量比率值为0表示不可接受。）
2. ````Accept-Encoding````首部字段中特定的"*"记号匹配该首部字段中未显式列出的任何可用的内容编码。
3. 如果多种内容编码可接受，则最希望接受的是具有最高非零质量比率值的内容编码。
4. ````identity````内容编码永远是可接受的，除非由于````Accept-Encoding````首部字段包含````identity;q=0````而特别拒绝，或者因为该字段包含````*;q=0````而又没有显式包含````identity````内容编码。如果````Accept-Encoding````字段值为空，则只有````identity````内容编码是可接受的。

如果一个````Accept-Encoding````字段出现在一个请求中，同时如果服务器无法发送该字段定义的可接受的响应，则服务器应该发送一个 406 （Not Acceptable）状态码的错误响应。

如果请求中不包含````Accept-Encoding````字段，服务器可以假定客户端将接受任何内容编码。这种情况下，如果````identity````是其中一个可用内容编码，则服务器应该使用````identity````内容编码，除非有额外的信息表明别的内容编码对客户端有特定含义。

注意：如果请求不包含````Accept-Encoding````字段，而````identity````内容编码不可用，则可以被 HTTP/1.0 客户端广泛理解的内容编码是首选的（比如````gzip````和````compress````）。某些老版本的客户端不能正确显示其它内容编码的消息。服务端也可以根据特定用户代理或者客户端的信息来作出这个决定。

注意：大多数 HTTP/1.0 应用不认识或者遵循与内容编码相关联的质量比率值。这就意味着 qvalue 将不生效，也不允许与````x-gzip````或者````x-compress````一起使用。

## 14.4 Accept-Language

````Accept-Language````请求首部字段类似于````Accept````，但是限制该请求希望得到的响应的自然语言集合。语言标签在 3.10 章节中定义。

`````
Accept-Language = "Accept-Language" ":"
					1#( language-range [ ";" "q" "=" qvalue ] )
language-range  = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )
`````

每个````language-range````可以被关联一个质量比率值，表示用户对该范围指定语言的喜好程度估计。质量比率值默认为````q=1````。比如：

````
Accept-Language: da, en-gb;q=0.8, en;q=0.7
````

意思是：我更喜欢 Danish，不过将接受 British English 和其它类型的英语。一个````language-range````匹配到一个````language-tag````如果两者精确相等，或者该范围精确等于该标签的前缀因此跟随该前缀的首个标签字符是“－”。如果````Accept-Language````首部字段中的特殊范围“＊”可以匹配到所有该首部字段中其它范围尚未匹配到的语言标签。

注意：前缀匹配规则并不意味着如果语言标签以这种方式被分配给语言，则以下永远为事实：如果用户理解某个特定标签的语言，那么他将也理解所有将此标签作为前缀的标签所标识的语言。前缀规则只是在这个前提成立的情况才允许使用前缀标签。

通过````Accept-Language````字段分配给语言标签的语言质量比率是该字段中匹配到````language-tag````的最长````language-range````的质量值。如果该字段中没有````language-range````匹配到````language-tag````，则语言质量比率就是0。如果请求中没有````Accept-Language````首部字段，则服务器应该假定所有的语言都是可以接受的。如果存在````Accept-Language````首部字段，则所有质量比率大于0的语言都是可接受的。

在每个请求中都携带````Accept-Language````首部字段来表示用户的语言喜好可能是一种违反隐私策略的做法。关于这个问题的讨论，详见 15.1.4 章节。

内容的可理解性高度依赖特定的用户，推荐的做法是客户端应用来作出用户语言喜好的决定。如果无法做出该决定，则请求中就绝对不能出现在请求中。

注意：当决定了用户可用的语言喜好，我们提醒实现者这个事实：用户并不熟悉上面描述的语言匹配机制的细节，因而应该提供一个合适的引导。比如，用户可能会想当然地认为选择了"en-gb"，他们就将会被服务为任何 English 语言的文档，如果 British English 不可用。在这种情况下，用户代理可能会建议添加“en”以获得最佳匹配行为。

## 14.5 Accept-Range

````Accept-Range````响应首部字段允许服务器表达它对关于一个资源的范围请求的接受性。

````
Accept-Ranges     = "Accept-Ranges" ":" acceptable-ranges
acceptable-ranges = 1#range-unit | "none"
````

接受字节范围请求的初始服务器可以发送：

````
Accept-Ranges: bytes
````

不过这并不是强制的。客户端可以产生字节范围请求，而不必接收到相关资源的这个首部字段。范围单位在 3.12 章节中定义。

服务器不接受关于资源的任何类型的范围请求时可以发送：

````
Accept-Ranges: none
````

来告知客户端不要试图进行范围请求。

## 14.6 Age

````Age````响应首部字段传输发送者对响应在初始服务器上产生（或者再验证）时刻到目前经过的时间的估计值。被缓存的响应如果尚未超过它的新鲜生存时间就是新鲜的。````Age````字段的值的计算方法定义在 13.2.3章节中。

````
Age			= "Age" ":" age-value
age-value	= delta-seconds
````

````Age````值是非负的十进制整数，表示时间秒数。

如果缓存接收到的值超过它能够表述的最大值，或者任何一个年龄计算溢出了，它就必须传输````Age````首部字段值````2147483648(2^31)````。一个包含缓存的 HTTP/1.1 服务器必须在从它的缓存中产生的每个响应中都包含````Age````字段。缓存应该使用至少 31 位范围的算术类型。

## 14.7 Allow

````Allow````实体首部字段列出````Request-URI````指定的资源所支持的所有方法集合。目的是严格地通知通信对方改资源相关的方法。````Allow````首部字段必须出现在 405(Method Not Allowed) 状态码响应中。

````
Allow	= "Allow" ":" #Method
````

使用的例子：

````
Allow: GET, HEAD, PUT
````

该字段不能阻止客户端尝试使用其它方法。不过，该字段值给出的指示应该被遵循。实际的允许方法的集合还是由初始服务器在每个请求到来时决定。

该字段可以出现在 PUT 请求中来推荐新的或者修改过后的资源所支持的方法。服务器不强制支持这些方法，在响应中应该包含一个````Allow````首部字段给出实际支持的方法。

代理服务器绝对不难修改````Allow````首部字段，即使它不理解该字段指定的所有方法，因为用户代理可能通过它与初始服务器交流其它更重要的信息。

## 14.8 Authorization

用户代理希望向初始服务器认证它自己的身份，在接收到一个 401 状态码响应之后，此时，就可以在请求首部中包含一个````Authorization````字段。该字段值由包含了用户代理对于请求的资源所在的域的身份认证信息的````credentials````组成。

````
Authorization	= "Authorization" ":" credentials
````

HTTP 访问身份认证在“HTTP 认证：基本的和摘要的访问认证”章节中描述。如果一个请求是已认证的，同时也制定了````realm````，则对于该````realm````下的所有其它请求，相同的````credentials````就应该都是合法可用的（假定认证机制本身不需要任何其它条件，比如身份凭证会基于验证码或者同步时钟变化）。

当一个共享缓存收到一个包含````Authorization````首部字段的请求时，它绝对不能像回复任何其它请求那样返回相应的响应，除非发生以下特定例外情况之一：

1. 如果响应包含````s-maxage````缓存控制指令，缓存可以在后续请求的回复中使用该响应。但是（如果已经超过指定的最大年龄）一个代理缓存必须首先向初始服务器验证它，使用来自的新的请求的请求首部来允许初始服务器对新的请求进行认证（这就是````s-maxage````被定义的行为）。如果响应包含````s-maxage=0````，则代理必须在使用之前再次验证它。
2. 如果响应包含````must-revalidate````缓存控制指令，缓存可以在后续请求的回复中使用该响应。但是如果该响应已经过时，所有缓存必须首先向初始服务器再次验证它，使用来自新的请求的请求首部来允许初始服务器对新的请求进行身份认证。
3. 如果响应包含````public````缓存控制指令，它可以被在任何后续请求的回复中被返回。

## 14.9 Cache-Control

````Cache-Control````通用首部字段用于指定那些请求响应链路上所有缓存机制都必须遵循的指令。这种指令指定的行为目的是防止缓存对请求或者响应产生不良影响。这些指定通常会覆盖默认的缓存算法。缓存指令是单向的，也就是说出现在请求中的指令并不会导致相同的指令被施加到响应中。

注意：HTTP/1.0 缓存可能没有实现````Cache-Control````而可能只是实现了````Pragma : no-cache````。

缓存指令必须被嗲了或者网关服务器应用透传，无论它们对这些应用有没有意义，因为这些指令可能会应用到请求响应链路上的所有通信参与者。不可能为特定的缓存指定专门的缓存控制指令。

````
Cache-Control		= "Cache-Control" ":" 1#cache-directive
cache-directive		= cache-request-directive
	| cache-response-directive
cache-request-directive	=
	  "no-cache"										; Section 14.9.1
	| "no-store"										; Section 14.9.2
	| "max-age" "=" delta-seconds						; Section 14.9.3, 14.9.4
	| "min-fresh" "=" delta-seconds 					; Section 14.9.3
 	| "no-transform" 									; Section 14.9.5
 	| "only-if-cached" 									; Section 14.9.4
 	| cache-extension 									; Section 14.9.6
 cache-response-directive =
 	  "public" 											; Section 14.9.1
	| "private" [ "=" <"> 1#field-name <"> ]			; Section 14.9.1
 	| "no-cache" [ "=" <"> 1#field-name <"> ]			; Section 14.9.1
 	| "no-store" 										; Section 14.9.2
 	| "no-transform" 									; Section 14.9.5
 	| "must-revalidate" 								; Section 14.9.4
 	| "proxy-revalidate" 								; Section 14.9.4
 	| "max-age" "=" delta-seconds 						; Section 14.9.3
 	| "s-maxage" "=" delta-seconds 						; Section 14.9.3
 	| cache-extension 									; Section 14.9.6
 cache-extension = token [ "=" ( token | quoted-string ) ]
````

当一个指令出现，但是并未携带任何````1#field-nam````参数，该指令应用于整个亲求或者响应。当这个指令携带````1#field-name````参数时，它只会应用于其中指出名称的字段，而不应用于请求或者响应的剩余部分。这种机制支持扩展，将来版本的 HTTP 协议实现可能将这些指令应用于没有在 HTTP/1.1 中定义的首部字段。

缓存控制指令可以被分为以下几类：

* 限制哪些数据可以被缓存，这些指令只能由初始服务器负责。
* 限制哪些数据可能会被缓存保存，这些指令可以由初始服务器或者用户代理负责。
* 基本超时机制修改指令，这些指令可以由初始服务器或者用户代理负责。
* 控制缓存再验证和重新加载，这些指令只能由用户代理负责。
* 数据实体转化的控制指令。
* 缓存系统的扩展指令。

### 14.9.1 什么是可缓存的

默认情况下，如果请求方法的需求、请求首部字段以及响应状态码表明响应的可缓存性，则该响应就是可缓存的。13.4 章节概况了可缓存性的默认规则。接下来的````Cache-Control````响应指令允许初始服务器覆盖默认的响应的可缓存性：

````public````

​	表示该响应可以被任何缓存服务器缓存，即使它本来是不可缓存的或者只能被非共享缓存服务器缓存。

````private````

​	表示全部或者部分响应消息只打算为单个用户所用，绝对不能被共享缓存保存。这就允许初始服务器标记出只希望为单个用户所用的响应部分，而不允许其它用户访问。私有（非共享）的缓存可以保存这种响应。

注意：这个关键字````private````的作用仅仅是控制响应中哪些部分可以被缓存，而不能确保消息内容的私密性。

````no-cache````

​	如果````no-cache````指令没有指定字段名，则缓存服务器在从初始服务器再验证成功之前绝对不能将响应用于后续请求。这就允许初始服务器阻止某些缓存服务器的缓存行为，即使那些缓存服务器被配置为可以为客户端请求返回过时响应。

如果````no-cache````指定了一个或者多个字段名，则缓存服务器可以使用该响应满足后续的请求，同时遵守其它对缓存的限制。然而，指定名称的字段绝对不能出现在被发送给后续请求的响应中，除非已经经过了由初始服务器进行的再验证。这就允许初始服务器阻止响应中某些特定字段的重用，同时仍然允许响应剩余部分被缓存。

注意：大多数 HTTP/1.0 缓存不认识也不遵循这个指令。

### 14.9.2 哪些数据可以被缓存存储

````no-store````

​	本指令的目的是防止敏感信息的意外释放或者保留（比如，作为备份的磁带）。本指令应用于整个消息，既可以通过响应发送，也可以通过请求发送。如果在请求中发送，缓存服务器就绝对不能存储该请求的任何部分，或者对应于该请求的响应的任何部分。如果在响应中发送，缓存绝对不能存储该响应的任何部分或者引起该响应的请求的任何部分。本指令应用于共享和非共享缓存。“绝对不能存储”在这里的上下文中意味着缓存绝对不能在非易失存储中有意存储信息，同时在转发完成之后必须尽最大可能尝试将信息从易失存储中删除信息。

即使当响应中包含此指令时，用户可能还是会将这种响应显式存储在缓存系统之外（比如，通过另存为操作等）。历史缓冲可能存储这种响应作为它们的正常操作的一部分。

此指令的目的是满足和确定某些用户和服务作者的需求，他们关注通过意料之外的对缓存数据结构访问导致的信息的意外泄露问题。尽管使用此指令可以在一些场景下提高信息私密性，我们还是需要提醒大家，不存在完全可靠或者充分的方法或者机制能确保信息的私密性。特别地，恶意的或者不安全的缓存可能并不认识或者遵循此指令，同时通信网络也可能是很容易被窃听的。

### 14.9.3 基本超时机制的修改

数据实体的超时时间可以由初始服务器使用````Expires````首部字段指定。另外，还可以在响应中使用````max-age````指令指定。当````max-age````缓存控制指令出现在被缓存的响应中，如果该响应的当前年龄大于对于该资源的新的请求到来的时刻对应的年龄值（秒数），则它就是过时的。响应中存在````max-age````指令暗示该响应是可缓存的（比如````public````），除非响应中还存在其它更严格的缓存控制指令。

如果响应同时包含````Expires````首部字段和````max-age````指令，则````max-age````指令将覆盖````Expires````首部字段，即使````Expires````首部更加严格。此规则允许初始服务器为给定的响应对 HTTP/1.1 缓存服务器提供一个比 HTTP/1.0 缓存服务器更长的超时时间。这一点对某些由于非同步时钟等因素造成的 HTTP/1.0 缓存服务器无法正确计算年龄或者超时时间的情况是很有用的。

很多 HTTP/1.0 缓存实现将小于等于响应的````Date````值的````Expires````值视作等价于````Cache-Control````响应指令````no-cache````。如果 HTTP/1.1 缓存服务器接收到这样的响应，而该响应不包含````Cache-Control````首部字段，它就应该将该响应视作不可缓存的，以保持与 HTTP/1.0 兼容。

注意：初始服务器可能希望使用相对更新的 HTTP 缓存控制特性，比如````private````指令，将这些指令应用到包含一些不理解这些特性的缓存的网络上。初始服务器将需要将新特性与````Expires````字段结合使用，该字段值小于等于````Date```` 值。这样就可以防止老版本的缓存服务器不恰当地缓存该响应。

````s-maxage````

​	如果响应中包含````s-maxage````指令，则对共享缓存（并不是对私有缓存）来说，此指令指定的最大年龄将覆盖````max-age````指令或者````Expires````首部字段指定的最大年龄值。此指令同时也暗含````proxy-revalidate````指令的语义，比如，共享缓存服务器绝对不能为后续的请求使用已经过时的数据实体，除非首先从初始服务器进行了成功的再验证。此指令永远会被私有缓存忽略。

注意：大部分老版本缓存实现，不符合本规范，没有实现任何缓存控制指令。初始服务器希望使用缓存控制指令限制，而不是阻止，被 HTTP/1.1 兼容的缓存服务器缓存，可以利用````max-age````指令对````Expires````首部字段的覆盖条件，以及 HTTP/1.1 之前版本的缓存实现都不认识````max-age````指令的事实。

其它一些指令允许用户代理修改基本的超时机制。这些指令可以在请求中指定：

````max-age````

​	表示客户端希望接受年龄不大于该指令指定的时间秒数的响应。除非同时包含````max-stale````指令，否则客户端将不接受过时的响应。

````min-fresh````

​	表示客户端希望接受新鲜生存时间小于当前年龄加上此指令指定的时间秒数的响应。也就是说，客户端希望接受新鲜生存时间至少是这么多秒的响应。

````max-stale````

​	表示客户端希望接受已经超过超时时间的响应。如果此指令分配了一个值，则客户端就希望接受超过超时时间不超过该值秒数的响应。如果此指令没有分配值，则客户端希望接受任何年龄的过时响应。

如果缓存服务器收到一个过时响应，要么由于请求中的````max-stale````指令，要么由于该缓存服务器被配置为覆盖响应的超时时间，该缓存服务器必须为该过时响应添加一个````Warning````首部字段，使用 Warning 110（Response is stale）状态码。

缓存服务器可以配置成无需验证直接返回过时的响应，但是前提是不能与任何“必须”级别的缓存验证需求发生冲突（比如````must-revalidate````缓存控制指令）。

如果新的请求和缓存的数据实体都包含````max-age````指令，则两个值中较小者将被用于为该请求确定缓存的数据实体的新鲜性。

### 14.9.4 缓存再验证和重新加载控制

有时候用户代理可能希望或者需要强调缓存服务器需要向初始服务器（而不仅仅是请求响应路径上初始服务器方向的下一个缓存服务器）再验证它所缓存的数据实体，或者从初始服务器重新加载数据实体。端到端的再验证可能是必要的，如果缓存服务器或者初始服务器高估了被缓存的响应的超时时间。端到端的重新加载可能是必要的，如果缓存实体由于什么别的原因被破坏了。

端到端的再验证可能需要，要么当客户端没有它自己的本地缓存拷贝，这种场景下我们称之为“非特定的端到端再验证”，要么当客户端拥有本地缓存的拷贝，这种场景下我们称之为“特定的端到端再验证”。

客户端能够通过使用````Cache-Control````请求指令指定这三种行为：

端到端重新载入

​	请求包含````no-cache````缓存控制指令，或者为了保持与 HTTP/1.0 客户端，包含````Pragma: no-cache````。字段名绝对不能包含在请求的````no-cache````指令中。当响应这个请求时服务器绝对不能使用缓存拷贝。

特定的端到端再验证

​	请求包含一个````max-age=0````缓存控制指令，该指令会强制请求路径上的每个缓存再验证它们自己的数据实体，如果存在，向下一个缓存服务器或者初始服务器验证。初始的请求包含一个关于客户端当前验证器的缓存验证条件。

非特定的端到端再验证

​	请求中包含````max-age=0````缓存控制指令，将强制请求路径上的每个缓存都与初始服务器再验证它们的数据实体，如果存在，与下一个缓存服务器或者初始服务器。初始请求不包含缓存验证条件，请求路径上的第一个缓存服务器（如果存在）持有请求资源的缓存实体包含关于它的当前验证器的缓存验证条件。

````max-age````

​	当一个中间缓存服务器被强制，由````max-age=0````指令，向初始服务器再验证它们自己的缓存数据实体，同时客户端已经在请求中提供了它自己的验证器，则提供的验证器可能不同于缓存的数据实体中的验证器。这种情况下，缓存服务器可以使用任何一个验证器来产生它自己的请求，这样就不会影响语义透明性。

然而，验证器选择可能会影响性能。对中间缓存服务器来说最好的方法就是使用它自己的验证器来产生请求。如果服务器返回 304 (Not Modified) 状态码响应，则缓存服务器可以返回它现在验证后的拷贝给客户端，携带状态码 200 (OK)。如果服务器返回一个新的数据实体和缓存验证器，但是中间缓存服务器能够比较返回的验证器和客户端请求中的验证器，使用强比较函数。如果客户端的验证器等于初始服务器的验证器，则中间缓存服务器简单地返回 304(Not Modified) 状态码响应。否则，它返回 200 (OK) 状态码的新的数据实体的响应。

如果请求中包含````no-cache````指令，它就不应该包含````min-fresh````，````max-stale````或者````max-age````指令。

````only-if-cached````

​	某些情况下，比如网络连接状况比较恶劣时，客户端可能希望缓存服务器仅仅返回它当前已经存储的响应数据，而不要向初始服务器再验证或者从初始服务器重新加载。为了做到这一点，客户端可以在请求中包含一个````only-if-cached````指令。如果接收到该指令，缓存服务器应该要么使用一个缓存的符合请求的其它约束的数据实体响应之，要么响应以 504(Gateway Timeout) 状态码。不过，如果一组缓存服务器通过稳定的内容连接作为同一系统工作，这样的请求就可以被转发进入该缓存服务器群组。

````must-revalidate````

​	因为缓存可以被配置为忽略服务器指定的超时时间，同时，客户端请求可以包含一个````max-stale````指令（具有类似的影响），协议也包含一个机制来使得初始服务器要求缓存实体在任何后续使用时都需要再验证。当````must-revalidate````指令出现在缓存接收到的响应中，在数据实体过时后，该缓存绝对不能使用该实体，除非首先与初始服务器对该实体进行再验证。（比如，缓存服务器必须每次都进行端到端的再验证，如果，仅仅根据初始服务器的````Expires````或者````max-age````值，已经缓存的响应是过时的）

````must-revalidate````指令对支持某些协议特性的可靠操作是必要的。在所有环境中，HTTP/1.1 缓存服务器必须遵循此````must-revalidate````指令，特别地，如果由于任何原因缓存服务器无法抵达初始服务器，它就必须产生一个 504(Gateway Timeout) 状态码响应。

服务器应该发送````must-revalidate````指令，当且仅当数据实体桑拿的请求再验证失败会导致错误的操作时，比如无声无息没有执行的金融交易。通信参与者绝对不能采取任何违反此指令的自动行为，同时，如果再验证失败，就绝对不能自动提供一个未通过验证的数据实体副本。

尽管并不是推荐做法，运行在严苛的连接性限制条件下的用户代理可以违反此指令，不过，如果这样做，就必须显式警告用户此时提供的是未验证的响应。每个未验证的访问都必须携带该警告信息，同时应该要求显式的用户确认。

````proxy-revalidate````

​	此指令与````must-revalidate````含义相同，除了它并不应用于非共享的用户代理缓存。它可以被用在一个认证的请求对应的响应中以允许用户缓存存储并随后使用该响应，而不需要再验证（因为它已经由用户进行了认证），同时仍然需要为多个用户提供服务的代理服务器每次都进行验证（为了保证每次每个用户都是已认证的）。注意，这种认证后的响应也需要````public````缓存控制指令以允许它们被缓存。

### 14.9.5 No-Transform 指令

````no-transform````

​	中间缓存（代理）的实现者已经发现对某些数据实体主体的媒体类型进行转化是很有用的。一个非透明传输的代理可能，例如，在图片格式之间转换以便节省存储空间或者降低低速连接上的网络流量。

严重的操作问题会发生，当这些转换应用于某些特定类型的应用的数据实体主体上时。比如，医学图片应用、科研数据分析应用等使用端到端身份认证的应用，都依赖于接收到一个与初始数据实体主体逐字节相同的数据实体主体。

因此，如果消息包含````no-transform````指令，为了遵循该指令，中间缓存服务器或者代理就绝对不能修改那些 13.5.2 章节中列出的首部字段。这就意味着缓存或者代理绝对不能改变这些首部字段指定的数据实体主体的任何方面，包含数据实体主体本身的值。

### 14.9.6 缓存控制扩展

````Cache-Control````首部字段可以通过使用一个或者多个缓存扩展指令来扩展，每个指令携带一个可选的分配的值。信息式扩展（不要求缓存行为的改变）可以被添加而不会改变其它指令的语义。行为式扩展呗设计为作为现存缓存指令的修改器的角色儿存在。新的指令和标准指令都被提供，因而不理解新指令的应用将默认执行标准指令指定的行为，那些理解新指令的应用将识别它并修改标准指令的关联需求。以这种方式，缓存控制指令的扩展可以不需要基本协议的任何修改。

扩展机制依赖于这样的前提，那就是，HTTP 缓存遵循所有为它自身 HTTP 版本所定义的缓存控制指令，遵循某些扩展，同时忽略所有它无法理解的指令。

比如，考虑一个假想的新响应指令，名为````community````，作为````private````指定的修改器。我们定义该新指令的含义为，除了任何非共享缓存，任何仅仅通过它们的通信成员名称进行共享的缓存服务器都可以缓存响应。初始服务器希望允许````UCI community````使用一个私有响应在它们的共享缓存上，它可能会这么做：

````
Cache-COntrol: private, community="UCI"
````

缓存服务器看到这个首部字段，将执行精准动作，即使它无法理解````community````缓存扩展，因为它仍然可以看到并理解````private````指令进而执行安全的行为。

不认识的缓存控制指令必须被忽略。假设所有可能不被 HTTP/1.1 缓存服务器理解的缓存指令将都会与一个标准指令（或者响应的默认可缓存性）共同使用，那么即使缓存服务器完全不理解扩展，也能保证它的行为的最小限度精准性。

## 14.10 Connection

````Connection````通用首部字段允许发送者指定该特定连接期望的选项，而绝对不能在后续的连接中被代理服务器传输。

````Connection````首部字段具有以下语法：

````
Connection = "Connection" ":" 1#(connection-token)
connection-token = token
````

HTTP/1.1 代理必须在消息被转发前解析````Connection````首部字段，对该字段中的每个 connection-token ，从名称与 connection-token 相同的消息中删除所有首部字段。````Connection````选项通过````Connection````首部字段中出现的 connection-token 被标记，而不是通过任何相应的附加首部字段，因为附加首部字段可能不会被发送，如果没有与连接选项关联的参数存在。

在````Connection````首部字段中列出的消息首部字段绝对不能包含端到端的首部字段，比如````Cache-Control````。

HTTP/1.1 定义"close"连接选项以使得发送方在响应完成之后发出连接即将被关闭的信号。比如：

````
Connection: close
````

请求或者响应中的首部字段表示该连接在当前请求／响应完成之后不应该被认为是“持久”的。

不支持持久连接的 HTTP/1.1 应用必须在所有的消息中都包含“close”连接选项。

接收到一个包含````Connection````首部字段的 HTTP/1.0(或者更低版本)的消息的系统必须，对该字段中的每个 connection-token ，删除并忽略消息中与 connection-token 名称相同的所有首部字段。这种机制防止这些首部字段被 HTTP/1.1 更早版本的代理服务器错误转发。参考 19.6.2 章节。

## 14.11 Content-Encoding

````Content-Encoding````实体首部字段被作为 media-type 的修改器使用。当它存在时，它的值表示何种附加内容编码已经被应用于实体主体，何种解码机制必须被应用来获取````Content-Type````首部字段引用的 media-type 。````Content-Encoding````主要被用来允许文档在不丢失它隐含的 media type 标志的前提下被压缩。

````
Content-Encoding = "Content-Encoding" ":" 1#content-coding
````

内容编码定义在 3.5 章节中，下面是个例子：

````
Content-Encoding: gzip
````

内容编码是````Request-URI````指定的数据实体的一种特性。典型地，数据实体主体被编码后存储，只是到渲染或者类似使用之前才会解码。然而，一个不透明代理可以修改内容编码，如果新的编码已知是通信对方可接受的，除非````no-transform````缓存控制指令出现在消息中。

如果数据实体主体的内容编码不是````identity````，则响应就必须包含一个````Content-Encoding````实体首部，其中列出了使用的非 - identiey 内容编码。

如果请求消息中的实体主体的内容编码不是初始服务器可接受的，则服务器应该响应以 415（Unsupported Media Type）状态码响应。

如果多种编码已经应用于一个实体，这些内容编码必须被按照它们被应用的顺序列出。编码参数的附加信息可以被此规范未定义的其它实体首部字段提供。

## 14.12 Content-Language

````Content-Language````实体首部字段描述了所包含数据实体的目标受众的自然语言。注意这有可能并不与实体主体中使用的所有语言相同。

````
Content-Language = "Content-Language" ":" 1#language-tag
````

语言标签在 3.10 章节中定义。````Content-Language````的主要目标是允许用户指定和区分数据实体，根据用户自己的语言偏好。因此，如果主体内容只是面向丹麦语受众，则合适的字段值就是：

````
Content-Language: da
````

如果没有指定````Content-Language````，则默认数据实体内容就是面向所有语言受众。这可能意味着发送方并不认为该实体内容应该指定为任何特定自然语言，或者发送方不知道应该使用何种自然语言。

面向多种受众的内容可以列出多种语言。比如，同时出现原始毛利语和英语版本数据，可以：

````
Content-Language: mi, en
````

不过，仅仅是实体中出现多种语言并不意味着它是面向多种语言受众的。一个例子是初学者语言入门中的"拉丁语第一课"，显然是面向英语受众的。这种情况下，````Content-Language````可以仅仅包含````en````。

````Content-Language````可以被应用于任何媒体类型－并未限定为只能用于文本文档。

## 14.13 Content-Length

````Content-Length````实体首部字段表示实体主体的尺寸，字符的十进制数目，发送给通信对象，或者，在````HEAD````方法请求场景下，实体主体的尺寸应该已经被发送，如同````GET````请求方法的情形。

````
Content-Length		= "Content-Length" ":" 1*DIGIT
````

一个例子：

````
Content-Length: 3495
````

应用应该使用该字段表示消息体的传输长度，除非被 4.4 章节中的规则禁止。

任何大于或者等于 0 的````Content-Length````值都是有效值。4.4 章节中描述了在没有给定````Content-Length````情况下如何确定消息主体长度。

注意，此字段的含义与 MIME 中对应的定义截然不同，MIME 中该字段时一个使用在````message/external-body````内容类型字段中的可选字段。在 HTTP 中，它应该被发送，如果消息长度可以在传输之前确定，除非被 4.4 章节中的规则禁止。

## 14.14 Content-Location

````Content-Location````实体首部字段可以被用于为封装进入消息中的数据实体提供资源位置，当该数据实体的内容来自不同于请求的资源的 URI 的另外一个单独的位置。服务器应该为对应的响应数据实体的变体提供一个````Content-Location````，特别是在该资源存在多个数据实体相关联的情况下，而这些实体实际上存在多个单独的位置因而可以被单独访问，服务器应该为返回的每个特定变体提供一个````Content-Location````。

````
Content-Location = "Content-Location" ":" ( absoluteURI | relativeURI)
````

````Content-Location````字段值同时也为实体定义了基本 URI。

````Content-Location````值并不是初始请求的 URI 的替代品，它只是当前请求的特定返回数据对应的资源的位置陈述。后续的请求可以指定````Content-Location```` URI 作为 request-URI，如果希望它指定了特定数据实体的数据来源。

缓存服务器不能假定包含的````Content-Location````的字段值不同于查询它自己的 URI 的数据实体能够被用于响应该````Content-Location```` URI 上的后续的请求。不过，该````Content-Location````可以被用于区分从同一个资源获取的多个数据实体，如 13.6 章节中所述。

如果````Content-Location````是一个相对 URI，则它会被解读为相对于````Request-URI````。

PUT 和 POST 请求中的````Content-Location````首部字段的含义没有定义，服务器可以安全地忽略它们。

## 14.15 Content-MD5

RFC 1864 中定义的````Content-MD5````首部字段是实体主体的 MD5 摘要，目的是提供实体主体的端到端的消息完整性检查（MIC）。注意，MIC 对探测传输中的实体主体的意外修改是有用的，但是不能防止恶意攻击。

````
Content-MD5		= "Content-MD5" ":" md5-digest
md5-digest		= <base64 of 128 bit MD5 digest as per RFC 1864>
````

````Content-MD5````首部字段可以由初始服务器或者客户端产生，用作消息完整性检查。只有初始服务器或者客户端可以产生````Content-MD5````首部字段，代理服务器和网关服务器都不能产生它，只有这样才能保证它的值可以用作端到端的消息完整性检查。任何有关实体主体的通信参与者，包括网关和代理服务器，可以检查该字段中摘要的值是否符合接收到的实体主体。

MD5 摘要基于实体主体的内容计算，包括任何已被应用的内容编码，但是不包括任何应用到消息主体上的传输编码。如果接收到的消息被施加了传输编码，该编码必须在进行 MD5 检查之前被清除。

这就使得该摘要需要基于实体主体的原原本本的字节内容进行计算，如果没有应用传输编码，则应该按照它们被发送的顺序被计算。

HTTP 扩展了 RFC 1864 以允许为 MIME 复合媒体类型（例如，multipart / * 和 message / rfc822）计算摘要，但这不会改变前一段中定义的计算摘要的方式。
这有几个后果。复合类型的实体主体可以包含许多主体部分，每个主体部分都有自己的 MIME 和 HTTP 头（包括````Content-MD5````，````Content-Transfer-Encoding````和````Content-Encoding````头）。如果正文部分具有````Content-Transfer-Encoding````或````Content-Encoding````首部字段，则假设正文部分的内容已应用编码，并且正文部分包含在````Content-MD5````摘要中，以应用编码之后的形式。 在 body-parts 中不允许包含````Transfer-Encoding````首部字段。

在计算或检查摘要之前，不得将所有换行符转换为 CRLF 。在计算摘要时，实际传输的文本中使用的换行符必须保持不变。

注意：由于````Content-MD5````在 HTTP 中的定义与 RFC 1864 中为 MIME 实体主体定义的完全一样，存在几种方式可以区分为 HTTP 实体主体使用的````Content-MD5````和为 MIME 实体主体使用的````Content-MD5````。如果是 HTTP ，不像 MIME ，不会使用````Content-Transfer-Encoding````，仅使用````Tansfer-Encoding````和````Content-Encoding````。另一个区别是 HTTP 比 MIME 更频繁地使用二进制内容类型，因此值得注意的是，在这种情况下，用于计算摘要的字节顺序是为该类型定义的传输字节顺序。最后，HTTP 允许使用几种换行约定中的任何一种来传输文本类型，而不仅仅是使用 CRLF 的规范形式。

## 14.16 Content-Range

随着一个实体主体部分被发送的````Content-Range````实体首部字段表示该部分应该放到完整实体主体中的哪个位置。范围单位定义在 3.12 章节中。

````
Content-Range			= "Content-Range" ":" content-range-spec
content-range-spec		= byte-content-range-spec
byte-content-range-spec	= bytes-unit SP
						  byte-range-resp-spec
						  ( instance-length | "*" )
byte-range-resp-spec	= (first-byte-pos "-" last-byte-pos)
						  | "*"
instance-length			= 1*DIGIT
````

此首部字段应该指明完整实体主体的全长，除非该长度未知或者很难确定。星号“*”字符表示````instance-length````在响应产生时刻是未知的。

不像````byte-content-range-specifier````值，一个````byte-range-resp-spec````必须仅仅指定一个范围，同时必须包含该范围第一个和最后一个字节的绝对字节位置。

一个携带````byte-range-resp-spec````的````byte-content-range-spec````，如果它的````last-byte-pos````值小于它的````first-byte-pos````值，或者其````instance-length````值小于或者等于它的````last-byte-pos````，那么它就是无效的。接收到无效````byte-content-range-spec````的通信参与者必须忽略它以及通过它传输的所有内容。

服务器发送的 416（Requested range not satisfiable）状态码响应应该包含````Content-Range````字段携带值为“\*”的````byte-range-resp-spec````内容。````instance-length````只当选中资源的当前长度。206（Partial Content）状态码响应绝对不能包含````Content-Range````字段携带值为“\*”的````byte-range-resp-spec````内容。

````byte-content-range-spec````取值的例子，假定实体包含总共 1234 个字节：

* 开头的 500 字节

````
bytes 0-499/1234
````

* 接下来的 500 字节

````
bytes 500-999/1234
````

* 除了开头的 500 字节之外的字节

````
bytes 500-1234/1234
````

* 最后的 500 字节

````
bytes 734-1234/1234
````

当一个 HTTP 消息包含单个范围的内容（比如，一个对应于单个范围请求的响应，或者对一系列相互重叠而无范围遗漏的范围请求的响应），其内容会连同一个````Content-Range````首部字段被传输，同时一个````Content-Length````首部字段展示实际传输的字节数。比如：

````
HTTP/1.1 206 Partial content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

````

当一个 HTTP 消息包含多个范围的内容（比如，一个对多个非重叠范围的请求的响应）它就会被作为多部分消息传输。用于此目的的多部份媒体类型就是````multipart/byteranges````，定义在附录 19.2 中。附录 19.6.3 描述了更复杂的情况。

一个单个范围请求的响应绝对不能使用````multipart/byteranges````媒体类型被发送。多个范围的请求的响应，如果结果是单个范围，则可以被作为只有一个部分的````multipart/byteranges````媒体类型被发送。不能解码一个````multipart/byteranges````媒体类型消息的客户端绝对不能在一个请求中请求多个字节范围。

当客户端在一个请求中请求多个字节范围时，服务器应该按照它们出现在请求中的顺序依次返回它们。

如果服务器由于语法不合法而忽略````byte-range-spec````字段，该服务器就应该对待该请求如同那个不合法的````Range````首部字段不存在。（通常这意味着返回包含完整数据实体的 200 状态码响应）。

如果服务器接收到的请求（不包含````If-Range````请求首部字段）携带一个无法满足的````Range````请求首部字段（也就是说，其中的````byte-range-spec````值拥有一个超过当前选择的资源长度的````first-byte-pos````值），它就应该返回一个 416 （Requested rang not satisfiable）状态码响应。

注意：客户端不能指望服务器永远都会对一个无法满足的范围请求首部字段返回 416 状态码响应，因为不是所有服务器都实现了该请求字段。

## 14.17 Content-Type

````Content-Type````实体首部字段表示发送给收件方的实体主体的媒体类型，或者，在````HEAD````方法的情况下，在````GET````请求时已经发送的媒体类型。

````
Content-Type	= "Content-Type" ":" media-type
````

媒体类型定义在 3.7 章节中，一个例子：

````
Content-Type: text/html; charset=ISO-8859-4
````

有关标识实体媒体类型的方法的进一步的讨论放在 7.2.1 章节中。

## 14.18 Date











## 14.47 WWW-Authenticate

````WWW-Authenticate````响应首部字段必须被包含在 401（Unauthorized）状态码响应消息中。字段值由至少一个表示认证规则的````Challenge````和可以应用于````Request-URI````的参数组成。

````
WWW-Authenticate	= "WWW-Authenticate" ":" 1#challenge
````

HTTP 访问认证过程在 ”HTTP Authentication: Basic and Digest Access Authentication“ 中描述。用户代理应该谨慎转化该字段的值，因为其中可能包含超过一个 challenge，或者如果提供了多个该字段，一个 challenge 的内容也可能包含一个逗号分隔的认证参数列表。

# 15 安全问题

本章节的目的是提醒应用开发者、信息提供者以及用户本文档所描述的 HTTP/1.1 协议的安全局限性。本章节并不讨论确定的相关问题解决方案，而只是提供一些可以降低安全风险的建议。

## 15.1 私人信息

HTTP 客户端通常持有大量用户的私人信息，因而应该非常谨慎地使用来防止此类信息通过 HTTP 协议泄漏给其它数据源头。我们强烈推荐提供一个方便的接口来帮助用户控制此类信息的传播，同时其设计者和实现者应该特别小心处理这些信息。历史经验表明这种情况下的错误经常会导致严重的安全或者隐私问题，并对实现者公司造成恶劣影响。

### 15.1.1 服务端日志信息滥用

站在服务器的角度，通常会保存有关用户请求的一些个人数据，这些数据可能表示他们的阅读模式或者兴趣爱好等。这些信息很显然是机密的，因而它们的使用在某些国家受到法律约束。使用 HTTP 协议提供数据的人们有责任保证这些未授权的数据不被扩散。

### 15.1.2 敏感信息传输

类似于通用的数据传输协议，HTTP 不能调节它所传输的数据的内容，也不存在任何先验方法来确定给定请求上下文中哪些部分数据是敏感的。因此，应用应该为信息的提供者提供尽可能多的对这些信息的控制。四个首部字段值得特别指出：````Server````，````Via````，````Referer````以及````From````。

透露服务器软件版本可能会使得服务器变得对该版本软件的周知的严重漏洞的攻击更加脆弱。实现者应该为````Server````首部字段提供可配置的开关。

作为穿过网络防火墙的门户的代理服务器应该采取特殊的预防措施来传输标识防火墙后面的主机的首部字段信息。特别地，对于产生于防火墙之后的所有````Via````字段，它们应该删除或者将其替换为脱敏版本。

````Referer````首部字段允许阅读模式被研究以及产生反向链接。尽管它可能会非常有用，它的能力可能会被滥用，如果用户信息没有与该字段中包含的信息进行严格分离。甚至当用户的私人信息已经被删除的情况下，````Referer````首部字段可能表示一个不适合公布的私有文档的 URI。

放在````From````字段中发送的信息可能与用户的隐私倾向或者他们网站的安全策略发生冲突，因而如果用户不能关闭、开启并且修改该字段内容，则它不应该被发送。用户必须能够按照用户自己的意愿活着应用的默认配置设定该字段的内容。

我们建议，并不是强制，提供一个方便的切换接口给用户，用来开启或者关闭````From````和````Referer````消息的发送。

````User-Agent````或者````Server````首部字段有时候能被用于确定特定客户端或者服务器存在一个特定的可能被利用的安全漏洞。不幸的是，相同的信息经常被用于其他更有价值的目的，因为 HTTP 目前还没有更好的实现机制。

### 15.1.3 URI 中的敏感信息编码

由于链接的源头可能是私有信息，或者可能暴露其他隐私信息源，强烈建议用户能够选择是否发送````Referer````字段。比如，一个浏览器客户端可以拥有一个切换开关来进行公开和匿名浏览模式切换，该开关相应地可以开启或者关闭````Referer````he````From````信息的发送。

客户端不应该包含一个````Referer````首部字段到一个（不安全的） HTTP 请求中，如果它指向的页面通过一个安全协议传输。

使用 HTTP 协议的服务的作者不应该使用基于表单的 GET 来获取敏感数据，因为这将导致这些数据被编码进入````Request-URI````。许多现存的服务器、代理、以及用户代理将请求 URI 记录在某些第三方可见的位置。服务端可以使用基于表单的 POST 来获取敏感数据。

###15.1.4 与 Accept 首部字段相关的隐私问题

````Accept````请求首部字段能够向所有被访问的服务器暴露有关用户的信息。特别是````Accept-Language````首部字段可能暴露用户的隐私信息，因为对特定语言的理解通常与某些特定种族成员身份密切相关。用户代理提供开关来配置随每个请求发送的````Accept-Language````首部字段内容，同时强烈建议配置过程包含一条消息，以使得用户可以注意到隐私信息泄露问题。

一种限制隐私泄露的方法是用户代理默认忽略````Accept-Language````首部字段的发送，同时询问用户是否应该开始发送````Accept-Language````首部字段给服务器，如果它通过寻找由服务端产生的任何````Vary````响应首部字段来探测，这种情况下该字段的发送能够改善服务质量。

在每个请求中发送的精心制作的用户定制的 accept 首部字段，特别是如果其中包括质量值，可以被服务器用作相对可靠和长期存在的用户标识符。 此类用户标识符将允许内容提供商进行点击跟踪，并允许协作内容提供商匹配跨服务器点击跟踪或形成单个用户的提交。 请注意，对于不在代理后面的许多用户，运行用户代理的主机的网络地址也将用作长期用户标识符。 在使用代理来增强隐私的环境中，用户代理在向最终用户提供 accept 首部字段配置选项时应该保守。 作为极端隐私措施，代理可以过滤中继请求中的 accept 首部字段。 提供高度首部字段可配置性的通用用户代理应该警告用户可能涉及的隐私丢失。

## 15.2 基于文件名和路径名的攻击

HTTP 初始服务器的实现者应该谨慎地限制 HTTP 请求返回的文档仅仅是符合服务器管理员意愿的。如果一个 HTTP 服务器将 HTTP URIs 直接转化为系统文件调用，该服务器必须特别注意不要返回不能被分发给客户端的文件。比如，Unix，Microsoft Windows，以及其他操作系统，使用````..````作为路径组件来表示当前目录的上级目录。在这种系统中，HTTP 服务器必须禁止````Request-URI````中的任何此类结构，如果它可能允许访问 HTTP 服务器意愿之外的资源。类似的，仅供服务器内部使用的文件，比如访问控制文件、配置文件以及脚本代码等，必须受到保护来防止不合适的访问，因为它们可能包含敏感信息。经验表明，此类 HTTP 服务器实现中的小错误已经演变为乐安全风险。

## 15.3 DNS 欺骗

使用 HTTP 协议的客户端重度依赖域名解析服务，因此通常都很容易受到基于有意的错误 DNS 域名与 IP 地址的映射关系的安全攻击。客户端需要谨慎假定 IP 地址与 DNS 域名映射关系的持续合法性。

特别地，HTTP 客户端应该依赖它们自己的名称解析器来确定 IP 地址与 DNS 域名的映射关系，而不是依赖缓存的之前的主机名称解析结果。很多平台已经能够在合适的时候本地缓存查找到的主机名称，因而它们应该被配置成这种行为。查找结果应该被缓存，不过，只有当命名服务器报告的生存时间信息表明该缓存信息仍然可用时，这种缓存才是有用的。

如果 HTTP 客户端缓存主机名称查找结果来获得性能改善，它们必须同时关注 DNS 报告的这些数据的生存时间信息。

如果客户端没有注意到上述规则，它们就有可能被欺骗，当之前访问过的服务器的 IP 地址发生改变时。随着可以预见的愈加普遍的网络重编号的出现，这种攻击的可能性也在增加。遵守上述规则可以减少这种潜在的安全威胁。

此规则还改进了使用相同 DNS 名称的副本服务器的客户端的负载均衡行为，并降低了用户访问使用该策略的站点时出现故障的可能性。

## 15.4 Location 首部字段和欺骗

如果一个服务器支持多个互相不信任的组织，则它必须检查响应中在上述组织控制下产生的````Location````和````Content-Location````首部字段值，以确保它们不会试图访问未被授权的资源。

## 15.5 Content-Disposition 问题

RFC 1806 [35]，从中衍生出经常被实现的````Content-Disposition````（参见第19.5.1节）首部字段，有许多非常严重的安全问题考虑因素。 ````Content-Disposition````不是 HTTP 标准的一部分，但由于它已被广泛实现，我们正在记录它的使用以及它对实现者的风险。有关详细信息，请参阅 RFC 2183 [49]（更新自 RFC 1806）。

## 15.6 身份认证凭据和空闲客户端

现有的 HTTP 客户端和用户代理通常会无限期地保留身份验证信息。HTTP / 1.1 也没有提供服务器指示客户端丢弃这些缓存凭据的方法。这是一个重要缺陷，需要进一步扩展HTTP。凭证缓存可能会干扰应用程序的安全模型的情况包括但不限于：

* 长时间处于空闲状态的客户端，服务器可能希望使客户端重新提示用户提供凭据。
* 应用程序包括会话终止指示器（例如页面上的“注销”或“提交”按钮），之后应用程序的服务器端“知道”客户端没有进一步访问的原因来保留凭据。

此问题目前正在进行单独研究。这个问题的权变解决方法有很多，我们鼓励在屏幕保护程序，空闲超时和其他方法中使用密码保护，以减轻此问题中固有的安全问题。特别是，鼓励缓存凭证的用户代理提供易于访问的机制，用于在用户控制下丢弃缓存的凭证。

## 15.7 代理和缓存

就其本质而言，HTTP代理是中间人，并且代表了中间人攻击的机会。 代理服务器上运行的系统的问题可能导致严重的安全和隐私问题。代理可以访问与安全相关的信息，个人用户和组织的个人信息以及属于用户和内容提供商的专有信息。有问题的代理，或者在不考虑安全性和隐私考虑因素的情况下实现或配置的代理，可能会被用于各种潜在的攻击。

代理运营商应该保护代理运行的系统，因为它们会保护包含或传输敏感信息的任何系统。特别是，在代理处收集的日志信息通常包含高度敏感的个人信息和/或有关组织的信息。应谨慎保护日志信息，并制定和遵循适当的使用准则（第15.1.1节）。

缓存代理提供了额外的潜在漏洞，因为缓存的内容可能是可被恶意利用的有吸引力的目标。由于缓存内容在HTTP请求完成后仍然存在，因此对缓存的攻击可在用户认为已从网络中删除信息后很长时间内进行信息获取。因此，缓存内容应作为敏感信息进行保护。

代理实现者应考虑其设计和编码决策的隐私和安全影响，以及它们为代理操作员提供的配置选项（尤其是默认配置）。

代理用户需要意识到他们不比运行代理的人更值得信任；HTTP本身无法解决这个问题。

在适当的情况下，明智地使用密码可能足以抵御通常的安全和隐私攻击。此类加密超出了 HTTP / 1.1 规范的范围。

### 15.7.1 对代理的拒绝服务攻击

它们存在。它们很难防御。研究仍在继续，请提高警惕。