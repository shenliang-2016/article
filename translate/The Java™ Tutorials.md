# Java™教程

[主页](https://docs.oracle.com/javase/tutorial/index.html)

#Java教程学习路径

> Java教程是为JDK 8编写的。本页描述的示例和实践没有利用后续版本中引入的改进。

## 入门

- [入门](https://docs.oracle.com/javase/tutorial/getStarted/index.html) - 介绍Java技术和安装Java开发软件并使用它来创建简单程序的课程。
- [学习Java语言](https://docs.oracle.com/javase/tutorial/java/index.html) - 描述基本概念（如类，对象，继承，数据类型，泛型和包）的课程。
- [基本Java类](https://docs.oracle.com/javase/tutorial/essential/index.html) - 有关异常，基本输入/输出，并发，正则表达式和平台环境的课程。

## 基础

- [集合](https://docs.oracle.com/javase/tutorial/collections/index.html) - 使用和扩展Java集合框架的经验教训。
- [Lambda表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)：了解如何以及为何在应用程序中使用Lambda表达式。
- [聚合操作](https://docs.oracle.com/javase/tutorial/collections/streams/index.html)：探索聚合操作，流和Lambda表达式如何协同工作以提供强大的过滤功能。
- [JAR文件中的打包程序](https://docs.oracle.com/javase/tutorial/deployment/jar/index.html) - 有关创建和签署JAR文件的课程。
- [国际化](https://docs.oracle.com/javase/tutorial/i18n/index.html) - 设计软件的介绍，以便可以轻松地适应（本地化）各种语言和区域。
- [反射](https://docs.oracle.com/javase/tutorial/reflect/index.html) - 表示（“反映”）当前Java虚拟机中的类，接口和对象的API。
- [安全性](https://docs.oracle.com/javase/tutorial/security/index.html) - Java平台功能，有助于保护应用程序免受恶意软
- [JavaBeans](https://docs.oracle.com/javase/tutorial/javabeans/index.html) - Java平台的组件技术。
- [扩展机制](https://docs.oracle.com/javase/tutorial/ext/index.html) - 如何使Java平台上运行的所有应用程序都可以使用自定义API。
- [泛型](https://docs.oracle.com/javase/tutorial/extra/generics/index.html) - 对类型系统的增强，支持对各种类型的对象的操作，同时提供编译时类型安全性。

## 客户端开发

- [JavaFX入门](http://www.oracle.com/pls/topic/lookup?ctx=javase80&id=JFXST804) - 一组示例应用程序，旨在帮助您开始使用常见的JavaFX任务
- [Scene Builder入门](http://www.oracle.com/pls/topic/lookup?ctx=javase80&id=JSBGS101) - 逐步向您展示如何使用JavaFX Scene Builder工具创建简单的问题跟踪应用程序。
- [使用Swing创建GUI](https://docs.oracle.com/javase/tutorial/uiswing/index.html) - 全面介绍Java平台上的GUI创建。
- [部署](https://docs.oracle.com/javase/tutorial/deployment/index.html) - 如何使用JAR文件打包应用程序和applet，并使用Java Web Start和Java Plug-in进行部署。
- [2D图形](https://docs.oracle.com/javase/tutorial/2d/index.html) - 如何在应用程序中显示和打印2D图形。
- [全屏独占模式API](https://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html) - 如何编写更充分利用用户图形硬件的应用程序。

## 服务端开发

- [JDBC数据库访问](https://docs.oracle.com/javase/tutorial/jdbc/index.html) - 介绍用于Java应用程序与各种数据库和数据源之间的连接的API。
- [JMX](https://docs.oracle.com/javase/tutorial/jmx/index.html) - Java Management Extensions提供了一种管理应用程序，设备和服务等资源的标准方法。
- [JNDI](https://docs.oracle.com/javase/tutorial/jndi/index.html) - Java命名和目录接口支持访问DNS和LDAP等命名和目录服务。
- [JAXP](https://docs.oracle.com/javase/tutorial/jaxp/index.html) - 介绍用于XML处理的Java API（JAXP）1.4技术。
- [RMI](https://docs.oracle.com/javase/tutorial/rmi/index.html) - 远程方法调用API允许对象调用在另一个Java虚拟机上运行的对象的方法。
- [并发](https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html) - Java平台具有API，可帮助您开发多线程程序。

# 入门

这一部分提供了有关Java编程语言入门的所有知识。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/getStartedIcon.gif)**Java技术现象**](https://docs.oracle.com/javase/tutorial/getStarted/intro/index.html)提供Java技术的整体概述。它讨论了Java编程语言和平台，提供了该技术可以做什么以及如何使您的生活更轻松的广泛概述。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/getStartedIcon.gif)**“Hello World！” 应用程序**](https://docs.oracle.com/javase/tutorial/getStarted/cupojava/index.html)这种实用的方法描述了创建简单的“Hello World！”的下载内容，安装内容和输入内容。应用。它为NetBeans™集成开发环境（NetBeans IDE），Microsoft Windows，Solaris™操作系统（Solaris OS），Linux和Mac用户提供单独的说明。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/getStartedIcon.gif)**仔细看看“Hello World！”** ](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html)讨论“Hello World！” 应用程序，详细描述每段代码。它包括源代码注释，`HelloWorldApp`类定义块和`main`方法。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/getStartedIcon.gif)**常见问题（及其解决方案）**](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html)如果您在此路径中编译或运行程序时遇到问题，那么这就是您要去的地方。

## Java技术现象

谈论Java技术似乎无处不在，但究竟是什么呢？以下部分解释了Java技术如何既是编程语言又是平台，并概述了该技术可以为您做什么。

- [关于Java技术](https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html)
- [Java技术可以做什么？](https://docs.oracle.com/javase/tutorial/getStarted/intro/cando.html)
- [Java技术将如何改变我的生活？](https://docs.oracle.com/javase/tutorial/getStarted/intro/changemylife.html)

### 关于Java技术

Java技术既是一种编程语言，也是一种平台。

**Java编程语言**

Java编程语言是一种高级语言，可以通过以下所有流行语来表征：

- 简单
- 面向对象
- 分布式
- 多线程
- 动态
- 架构中立
- 可移植
- 高性能
- 鲁棒性
- 安全

前面的每个流行语都在[*Java语言环境*](http://www.oracle.com/technetwork/java/langenv-140151.html)中进行了解释， 它是由James Gosling和Henry McGilton编写的白皮书。

在Java编程语言中，所有源代码首先以用`.java`扩展名结尾的纯文本文件编写。然后，编译器将这些源文件编译成`.class`文件`javac`。一个`.class`文件不包含的代码是原产于你的处理器; 它包含*字节码* - Java虚拟机[1](https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html#FOOT)（Java VM）的机器语言。然后，`java`启动器工具使用Java虚拟机实例运行应用程序。

![image-20190504114539193](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504114539193.png)

由于Java VM可用于许多不同的操作系统，因此相同的`.class`文件能够在Microsoft Windows，Solaris™操作系统（Solaris OS），Linux或Mac OS上运行。某些虚拟机（例如 [Java SE HotSpot概览）会](http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136373.html)在运行时执行其他步骤，从而为您的应用程序提供性能提升。这包括各种任务，例如查找性能瓶颈和重新编译（对本机代码）经常使用的代码段。

![image-20190504114555283](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504114555283.png)

**Java平台**

一个*平台*是在程序运行的硬件或软件环境。我们已经提到了一些最受欢迎的平台，如Microsoft Windows，Linux，Solaris OS和Mac OS。大多数平台可以描述为操作系统和底层硬件的组合。Java平台与大多数其他平台的不同之处在于，它是一个纯软件平台，可以在其他基于硬件的平台上运行。

Java平台有两个组件：

- 在*Java虚拟机*
- 在*Java应用程序编程接口*（API）

您已经了解了Java虚拟机; 它是Java平台的基础，并移植到各种基于硬件的平台上。

API是大量现成的软件组件，提供许多有用的功能。它被分为相关类和接口的库; 这些库称为*包*。下一节， [Java Technology可以做什么？](https://docs.oracle.com/javase/tutorial/getStarted/intro/cando.html)重点介绍了API提供的一些功能。

![image-20190504114610831](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504114610831.png)

作为独立于平台的环境，Java平台可能比本机代码慢一点。但是，编译器和虚拟机技术的进步使性能接近本机代码的性能而不会威胁到可移植性。

术语“Java虚拟机”和“JVM”表示Java平台的虚拟机。

### Java技术可以做什么？

通用的高级Java编程语言是一个功能强大的软件平台。Java平台的每个完整实现都为您提供以下功能：

- **开发工具**：开发工具提供编译，运行，监视，调试和记录应用程序所需的一切。作为一名新开发人员，您将使用的主要工具是`javac`编译器，`java`启动器和`javadoc`文档工具。
- **应用程序编程接口（API）**：API提供Java编程语言的核心功能。它提供了各种有用的类，可以在您自己的应用程序中使用。它涵盖了从基本对象到网络和安全性，XML生成和数据库访问等所有内容。核心API非常大; 要了解它包含的内容，请参阅 [Java平台标准版8文档](https://docs.oracle.com/javase/8/docs/index.html)。
- **部署技术**：JDK软件提供标准机制，例如Java Web Start软件和Java Plug-In软件，用于将应用程序部署到最终用户。
- **用户界面工具包**：JavaFX，Swing和Java 2D工具包可以创建复杂的图形用户界面（GUI）。
- **集成库**：集成库，例如Java IDL API，JDBC API，Java命名和目录接口（JNDI）API，Java RMI和基于Internet的ORB间协议技术的Java远程方法调用（Java RMI-IIOP技术），支持数据库访问和远程对象的操纵。

### Java技术将如何改变我的生活？

如果你学习Java编程语言，我们不能保证你的名声，财富甚至是工作。尽管如此，它可能会使您的程序更好，并且比其他语言需要更少的工作量。我们相信Java技术将帮助您执行以下操作：

- **快速入门**：尽管Java编程语言是一种功能强大的面向对象语言，但它易于学习，特别是对于已经熟悉C或C ++的程序员。
- **编写更少的代码**：程序指标（类计数，方法计数等）的比较表明，用Java编程语言编写的程序可以比用C ++编写的相同程序小四倍。
- **编写更好的代码**：Java编程语言鼓励良好的编码实践，自动垃圾收集可以帮助您避免内存泄漏。它的面向对象，JavaBeans™组件架构及其广泛，易于扩展的API使您可以重用现有的，经过测试的代码并减少错误。
- **更快地开发程序**：Java编程语言比C ++更简单，因此，在编写时，您的开发时间可能快两倍。您的程序还需要更少的代码行。
- **避免平台依赖**：您可以通过避免使用其他语言编写的库来保持程序的可移植性。
- **编写一次，随处运行**：因为用Java编程语言编写的应用程序被编译成与机器无关的字节码，所以它们在任何Java平台上都能一致地运行。
- **更轻松地分发软件**：使用Java Web Start软件，用户只需单击鼠标即可启动应用程序。启动时的自动版本检查可确保用户始终了解最新版本的软件。如果有可用更新，Java Web Start软件将自动更新其安装。

# 学习Java语言

该路径涵盖了Java编程语言中编程的基础知识。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**面向对象的编程概念**](https://docs.oracle.com/javase/tutorial/java/concepts/index.html)向您介绍[**面向对象编程**](https://docs.oracle.com/javase/tutorial/java/concepts/index.html)背后的核心概念：对象，消息，类和继承。本课程将向您展示这些概念如何转化为代码。如果您已熟悉面向对象的编程，请随意跳过本课程。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**语言基础知识**](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html)描述了[**语言**](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html)的传统特性，包括变量，数组，数据类型，运算符和控制流。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**类和对象**](https://docs.oracle.com/javase/tutorial/java/javaOO/index.html)描述了如何编写从中创建对象的类，以及如何创建和使用对象。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**注释**](https://docs.oracle.com/javase/tutorial/java/annotations/index.html)是元数据的一种形式，为编译器提供信息。本课程描述了在程序中有效使用注释的位置和方法。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**接口和继承**](https://docs.oracle.com/javase/tutorial/java/IandI/index.html)描述了接口 - 它们是什么，为什么要编写接口，以及如何编写接口。本节还介绍了从另一个类派生一个类的方法。也就是说，*子类*如何从*超类*继承字段和方法。您将了解到所有类都是从类派生的`Object`，以及如何修改子类从超类继承的方法。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**数字和字符串**](https://docs.oracle.com/javase/tutorial/java/data/index.html)本课程介绍如何使用`Number`和`String`对象本课程还介绍如何格式化输出数据。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**泛型**](https://docs.oracle.com/javase/tutorial/java/generics/index.html)是Java编程语言的强大功能。它们可以提高代码的类型安全性，使您可以在编译时检测到更多错误。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**包**](https://docs.oracle.com/javase/tutorial/java/package/index.html)是Java编程语言的一个特性，它可以帮助您组织和构建类及其相互之间的关系。

## 面向对象的编程概念

如果您以前从未使用过面向对象的编程语言，那么在开始编写任何代码之前，您需要学习一些基本概念。本课将向您介绍对象，类，继承，接口和包。每个讨论都关注这些概念如何与现实世界相关，同时介绍Java编程语言的语法。

* [什么是对象？](https://docs.oracle.com/javase/tutorial/java/concepts/object.html)

对象是相关状态和行为的软件包。软件对象通常用于模拟您在日常生活中发现的真实世界对象。本课程解释了如何在对象中表示状态和行为，介绍数据封装的概念，并解释以这种方式设计软件的好处。

* [什么是类？](https://docs.oracle.com/javase/tutorial/java/concepts/class.html)

类是创建对象的蓝图或原型。本节定义了一个模拟现实世界对象的状态和行为的类。它故意专注于基础知识，展示一个简单的类如何能够清晰地模拟状态和行为。

* [什么是继承？](https://docs.oracle.com/javase/tutorial/java/concepts/inheritance.html)

继承为组织和构建软件提供了强大而自然的机制。本节介绍了类如何从超类继承状态和行为，并解释了如何使用Java编程语言提供的简单语法从另一个类派生一个类。

* [什么是接口？](https://docs.oracle.com/javase/tutorial/java/concepts/interface.html)

接口是一个类和外部世界之间的契约。当类实现接口时，它承诺提供该接口发布的行为。本节定义了一个简单的接口，并解释了实现它的任何类的必要更改。

* [什么是包？](https://docs.oracle.com/javase/tutorial/java/concepts/package.html)

包是用于以逻辑方式组织类和接口的命名空间。将代码放入包中可以使大型软件项目更易于管理。本节解释了这有用的原因，并向您介绍Java平台提供的应用程序编程接口（API）。

* [问题与练习：面向对象的编程概念](https://docs.oracle.com/javase/tutorial/java/concepts/QandE/questions.html)

使用本节中提供的问题和练习来测试您对对象，类，继承，接口和包的理解

### 什么是对象？

对象是理解*面向对象*技术的关键。现在环顾四周，你会发现许多真实物体的例子：你的狗，你的桌子，你的电视机，你的自行车。

真实世界的对象共享两个特征：它们都具有*状态*和*行为*。狗有状态（名称，颜色，品种，饥饿）和行为（吠叫，取出，摇尾）。自行车还具有状态（当前档位，当前踏板节奏，当前速度）和行为（改变档位，改变踏板节奏，应用制动器）。识别真实世界对象的状态和行为是开始思考面向对象编程的好方法。

现在花点时间观察您附近区域的真实物体。对于您看到的每个对象，请问自己两个问题：“这个对象可能存在哪些状态？” 和“这个对象可以执行什么样的行为？”。一定要记下你的观察结果。和你一样，你会发现现实世界的物体的复杂程度各不相同; 您的桌面灯可能只有两种可能的状态（打开和关闭）和两种可能的行为（打开，关闭），但您的桌面电台可能有其他状态（开，关，当前音量，当前电台）和行为（打开） ，关闭，增加音量，减少音量，搜索，扫描和调整）。您可能还会注意到，某些对象反过来也会包含其他对象。这些现实世界的观察都转化为面向对象编程的世界。

![image-20190504120734194](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504120734194.png)

软件对象在概念上类似于现实世界的对象：它们也包括状态和相关行为。对象将其状态存储在*字段*（某些编程语言中的变量）中，并通过*方法*（某些编程语言中的函数）公开其行为。方法对对象的内部状态进行操作，并作为对象到对象通信的主要机制。隐藏内部状态并要求通过对象的方法执行所有交互称为*数据封装* - 面向对象编程的基本原则。

考虑一下自行车，例如：

![image-20190504120757739](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504120757739.png)

通过归因于状态（当前速度，当前踏板节奏和当前档位）并提供改变该状态的方法，该对象仍然控制外部世界如何被允许使用它。例如，如果自行车仅具有6个档位，则换档的方法可以拒绝小于1或大于6的任何值。

将代码捆绑到单个软件对象中可带来许多好处，包括：

1. 模块化：可以独立于其他对象的源代码编写和维护对象的源代码。一旦创建，对象就可以轻松地在系统内部传递。
2. 信息隐藏：通过仅与对象的方法交互，其内部实现的细节仍然隐藏在外部世界之外。
3. 代码重用：如果对象已存在（可能由其他软件开发人员编写），则可以在程序中使用该对象。这允许专家实现/测试/调试复杂的，特定于任务的对象，然后您可以信任这些对象在您自己的代码中运行。
4. 可插拔性和调试简便性：如果某个特定对象有问题，您只需将其从应用程序中删除，然后插入另一个对象作为替代对象。这类似于解决现实世界中的机械问题。如果螺栓断裂，则更换*它*，而不是整个机器。

### 什么是类？

在现实世界中，您经常会发现许多相同类型的单个对象。可能存在数千种其他自行车，所有相同的品牌和型号。每辆自行车都是使用相同的蓝图构建的，因此包含相同的组件。在面向对象的术语，我们说你的自行车是一个*实例*中的*类的对象*被称为自行车。一*类*是从中创建单个对象的蓝图。

以下 [`Bicycle`](https://docs.oracle.com/javase/tutorial/java/concepts/examples/Bicycle.java)类是自行车的一种可能实现：

````java
class Bicycle {

    int cadence = 0;
    int speed = 0;
    int gear = 1;

    void changeCadence(int newValue) {
         cadence = newValue;
    }

    void changeGear(int newValue) {
         gear = newValue;
    }

    void speedUp(int increment) {
         speed = speed + increment;   
    }

    void applyBrakes(int decrement) {
         speed = speed - decrement;
    }

    void printStates() {
         System.out.println("cadence:" +
             cadence + " speed:" + 
             speed + " gear:" + gear);
    }
}
````

Java编程语言的语法对您来说很新，但这个类的设计基于之前对自行车对象的讨论。的字段`cadence`，`speed`和`gear`表示该对象的状态，并且这些方法（`changeCadence`，`changeGear`，`speedUp`等）限定与外部世界的相互作用。

您可能已经注意到`Bicycle`该类不包含`main`方法。那是因为它不是一个完整的应用程序; 它只是可能在应用程序中*使用的*自行车蓝图。创建和使用新`Bicycle`对象的责任属于应用程序中的其他类。

这是一个 [`BicycleDemo`](https://docs.oracle.com/javase/tutorial/java/concepts/examples/BicycleDemo.java)创建两个独立`Bicycle`对象并调用其方法的类：

````java
class BicycleDemo {
    public static void main(String[] args) {

        // Create two different 
        // Bicycle objects
        Bicycle bike1 = new Bicycle();
        Bicycle bike2 = new Bicycle();

        // Invoke methods on 
        // those objects
        bike1.changeCadence(50);
        bike1.speedUp(10);
        bike1.changeGear(2);
        bike1.printStates();

        bike2.changeCadence(50);
        bike2.speedUp(10);
        bike2.changeGear(2);
        bike2.changeCadence(40);
        bike2.speedUp(10);
        bike2.changeGear(3);
        bike2.printStates();
    }
}
````

此测试的输出打印两辆自行车的结束踏板节奏，速度和档位：

````shell
cadence:50 speed:10 gear:2
cadence:40 speed:20 gear:3
````

### 什么是继承？

不同种类的物体通常彼此具有一定的共同量。例如，山地自行车，公路自行车和双人自行车都具有自行车的特性（当前速度，当前踏板节奏，当前档位）。然而，每个还定义了使它们与众不同的其他功能：双人自行车有两个座位和两套车把; 公路自行车有把手下降; 一些山地自行车有一个额外的链环，使它们的齿轮比更低。

面向对象编程允许类*继承*其他类中常用的状态和行为。在这个例子中，`Bicycle`现在变成了*父*的`MountainBike`，`RoadBike`和`TandemBike`。在Java编程语言中，允许每个类具有一个直接超类，并且每个超类都有可能存在无限数量的*子类*：

![image-20190504121528340](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504121528340.png)

创建子类的语法很简单。在类声明的开头，使用`extends`关键字，后跟要继承的类的名称：

````java
class MountainBike extends Bicycle {

    // new fields and methods defining 
    // a mountain bike would go here

}
````

这提供了`MountainBike`所有相同的字段和方法`Bicycle`，但允许其代码专注于使其独特的功能。这使您的子类代码易于阅读。但是，您必须注意正确记录每个超类定义的状态和行为，因为该代码不会出现在每个子类的源文件中。

### 什么是接口？

正如您已经了解的那样，对象通过它们公开的方法定义它们与外部世界的交互。方法形成对象与外界的*界面* ; 例如，电视机正面的按钮是您与塑料外壳另一侧电线之间的接口。按“电源”按钮打开和关闭电视。

在最常见的形式中，接口是一组具有空体的相关方法。自行车的行为（如果指定为界面）可能如下所示：

````java
interface Bicycle {

    //每分钟转数
    void changeCadence（int newValue）;

    void changeGear（int newValue）;

    void speedUp（int increment）;

    void applyBrakes（int decrement）;
}
````

要实现此接口，您的类的名称将更改（例如，特定品牌的自行车`ACMEBicycle`），并且您将在类声明中使用````implements````关键字：

````java
class ACMEBicycle implements Bicycle {

    int cadence = 0;
    int speed = 0;
    int gear = 1;

   // The compiler will now require that methods
   // changeCadence, changeGear, speedUp, and applyBrakes
   // all be implemented. Compilation will fail if those
   // methods are missing from this class.

    void changeCadence(int newValue) {
         cadence = newValue;
    }

    void changeGear(int newValue) {
         gear = newValue;
    }

    void speedUp(int increment) {
         speed = speed + increment;   
    }

    void applyBrakes(int decrement) {
         speed = speed - decrement;
    }

    void printStates() {
         System.out.println("cadence:" +
             cadence + " speed:" + 
             speed + " gear:" + gear);
    }
}
````

实现接口允许类对其承诺提供的行为变得更加正式。接口在类和外部世界之间形成契约，并且该合同在构建时由编译器强制执行。如果您的类声称实现了一个接口，那么该接口定义的所有方法必须在其成功编译之前出现在其源代码中。

**注意：**  要实际编译`ACMEBicycle`该类，您需要将`public`关键字添加到已实现的接口方法的开头。稍后您将在有关[类和对象](https://docs.oracle.com/javase/tutorial/java/javaOO/index.html)以及 [接口和继承](https://docs.oracle.com/javase/tutorial/java/IandI/index.html)的课程中了解相关原因 。

### 什么是包？

包是一个命名空间，用于组织一组相关的类和接口。从概念上讲，您可以将包视为与计算机上的不同文件夹类似。您可以将HTML页面保留在一个文件夹中，将图像保存在另一个文件夹中，将脚本或应 因为用Java编程语言编写的软件可以由数百或*数千个*单独的类组成，所以通过将相关的类和接口放入包来保持组织是有意义的。

Java平台提供了一个巨大的类库（一组包），适合在您自己的应用程序中使用。该库称为“应用程序编程接口”，简称“API”。它的包代表了最常用于通用编程的任务。例如，`String`对象包含字符串的状态和行为; 一个`File`对象允许程序员轻松地创建，删除，检查，比较或修改文件系统上的文件; 一个`Socket`object允许创建和使用网络套接字; 各种GUI对象控制按钮和复选框以及与图形用户界面相关的任何其他内容。有数以千计的课程可供选择。这使程序员可以专注于特定应用程序的设计，而不是使其工作所需的基础结构。

在 [Java平台API规范](https://docs.oracle.com/javase/8/docs/api/index.html)包含了所有的包，接口，类，字段和Java SE平台提供的方法完整列表。在浏览器中加载页面并为其添加书签。作为程序员，它将成为您最重要的参考文档。

## 语言基础知识

* [ 变量](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html)

您已经了解到对象将其状态存储在字段中。但是，Java编程语言也使用术语“变量”。本节讨论此关系，变量命名规则和约定，基本数据类型（基本类型，字符串和数组），默认值和文字。

* [运算符](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)

本节介绍Java编程语言的运算符。它首先介绍了最常用的运算符，并且不常用的运算符持续存在。每个讨论都包含可以编译和运行的代码示例。

* [表达式，语句和块](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html)

运算符可用于构建计算值的表达式; 表达式是陈述的核心组成部分; 语句可以分组为块。本节讨论使用您已经看过的示例代码的表达式，语句和块。

* [控制流程语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)

本节介绍Java编程语言支持的控制流语句。它涵盖了决策制定，循环和分支语句，使您的程序能够有条件地执行特定的代码块。

### 变量

正如您在上一课中所了解到的，对象将其状态存储在*字段中*。

````java
int cadence = 0;
int speed = 0;
int gear = 1;
````

在 [什么是对象？](https://docs.oracle.com/javase/tutorial/java/concepts/object.html)讨论向您介绍了字段，但您可能还有一些问题，例如：命名字段的规则和约定是什么？此外`int`，还有哪些其他数据类型？在声明字段时是否必须初始化字段？如果未明确初始化字段，是否为字段分配了默认值？我们将在本课中探讨这些问题的答案，但在我们开始之前，您必须首先了解一些技术差异。在Java编程语言中，使用术语“字段”和“变量”; 这是新开发者之间混淆的常见原因，因为两者往往都是指同一件事。

Java编程语言定义了以下几种变量：

- **实例变量（非静态字段）**从技术上讲，对象将其各个状态存储在“非静态字段”中，即，不使用`static`关键字声明的字段。非静态字段也称为*实例变量，*因为它们的值对于类的每个*实例*是唯一的（换句话说，对于每个对象）; 的`currentSpeed`一个自行车的是独立于`currentSpeed`另一个。
- **类变量（静态字段）**甲*类变量*是与声明任何字段`static`改性剂; 这告诉编译器这个变量只有一个副本存在，无论该类被实例化多少次。定义特定种类的自行车的齿轮数的字段可以标记为`static`从概念上相同数量的齿轮将适用于所有实例。代码`static int numGears = 6;`将创建这样的静态字段。此外，`final`可以添加关键字以指示齿轮的数量永远不会改变。
- **局部变量**类似于对象如何在字段中存储其状态，方法通常会将其临时状态存储在*局部变量中*。声明局部变量的语法类似于声明字段（例如，`int count = 0;`）。没有特殊的关键字将变量指定为本地变量; 该决定完全来自声明变量的位置 - 它位于方法的开始和结束括号之间。因此，局部变量只对声明它们的方法可见; 他们无法从课堂上的其他人那里获得。
- **参数**您已经在“Hello World！” 的`Bicycle`类和`main`方法中看到过参数的示例。应用。回想一下该`main`方法的签名是`public static void main(String[] args)`。这里，`args`变量是此方法的参数。要记住的重要一点是参数总是被分类为“变量”而不是“字段”。这也适用于其他参数接受构造（例如构造函数和异常处理程序），您将在本教程后面学习。

话虽如此，本教程的其余部分在讨论字段和变量时使用以下一般准则。如果我们谈论的是“一般的字段”（不包括局部变量和参数），我们可以简单地说“字段”。如果讨论适用于“以上所有”，我们可以简单地说“变量”。如果上下文要求区分，我们将酌情使用特定术语（静态字段，局部变量等）。您也可能偶尔会看到使用“成员”一词。类型的字段，方法和嵌套类型统称为其*成员*。

**命名**

每种编程语言都有自己的规则和约定，适用于您允许使用的各种名称，Java编程语言也不例外。命名变量的规则和约定可归纳如下：

- 变量名称区分大小写。变量的名称可以是任何合法标识符 - Unicode字母和数字的无限长度序列，以字母，美元符号“ `$`”或下划线字符“ `_`” 开头。但是，惯例是始终用字母开头，而不是“ `$`”或“ `_`”。此外，按照惯例，美元符号字符根本不会被使用。您可能会发现某些情况，其中自动生成的名称将包含美元符号，但您的变量名称应始终避免使用它。对于下划线字符存在类似的约定; 虽然用“ `_`” 开始你的变量名称在技术上是合法的，但是这种做法是不鼓励的。不允许有空白区域。
- 后续字符可以是字母，数字，美元符号或下划线字符。约定（和常识）也适用于此规则。为变量选择名称时，请使用完整单词而不是隐藏缩写。这样做可以使您的代码更易于阅读和理解。在许多情况下，它还会使您的代码自我记录; 田命名`cadence`，`speed`和`gear`，例如，比缩写版本，如更直观`s`，`c`和`g`。另请注意，您选择的名称不得是 [关键字或保留字](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)。
- 如果您选择的名称只包含一个单词，则以全小写字母拼写该单词。如果它由多个单词组成，则将每个后续单词的首字母大写。名称`gearRatio`和`currentGear`是这个惯例的主要例子。如果您的变量存储一个常量值，例如`static final int NUM_GEARS = 6`，约定会略有变化，将每个字母大写并用后突字符分隔后续单词。按照惯例，下划线字符从未在别处使用过。

#### 原始数据类型

Java编程语言是静态类型的，这意味着必须首先声明所有变量才能使用它们。这包括声明变量的类型和名称，如您所见：

````java
int gear = 1;
````

这样做会告诉程序一个名为“gear”的字段存在，保存数字数据，初始值为“1”。变量的数据类型确定它可能包含的值，以及可能对其执行的操作。除此之外`int`，Java编程语言还支持其他七种*原始数据类型*。基本类型由语言预定义，并由保留关键字命名。原始值不与其他原始值共享状态。Java编程语言支持的八种原始数据类型是：

- **byte**：`byte`数据类型是8位有符号二进制补码整数。它的最小值为-128，最大值为127（含）。的`byte`数据类型可以是在大型保存存储器有用 [阵列](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html)，其中存储器的节省实际上重要的。它们也可用于代替`int`其限制有助于澄清您的代码; 变量范围有限的事实可以作为一种文档形式。
- **short**：`short`数据类型是16位带符号的二进制补码整数。它的最小值为-32,768，最大值为32,767（含）。与`byte`此同样，适用相同的指导原则：`short`在内存节省确实很重要的情况下，您可以使用a 来节省大型阵列中的内存。
- **int**：默认情况下，`int`数据类型是32位带符号的二进制补码整数，其最小值为-2^31，最大值为2^31 -1。在Java SE 8及更高版本中，您可以使用`int`数据类型表示无符号的32位整数，其最小值为0，最大值为2^32 -1。使用Integer类将`int`数据类型用作无符号整数。有关更多信息，请参阅数字类一节。像静态方法`compareUnsigned`，`divideUnsigned`等已被添加到 [`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)类，以支持算术运算的无符号整数。
- **long**：`long`数据类型是64位二进制补码整数。带符号的long的最小值为-2^63，最大值为2^63 -1。在Java SE 8及更高版本中，您可以使用`long`数据类型表示无符号的64位长，其最小值为0，最大值为2^64 -1。当您需要的值范围比提供的值更宽时，请使用此数据类型`int`。本 [`Long`](https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html)类也包含类似的方法`compareUnsigned`，`divideUnsigned`等支持算术运算unsigned long类型。
- **float**：`float`数据类型是单精度32位IEEE 754浮点。其值范围超出了本讨论的范围，但在Java语言规范的 [浮点类型，格式和值](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3)部分中指定。正如所提建议`byte`和`short`，使用`float`（而不是`double`如果你需要节省内存浮点数的大型阵列）。绝不应将此数据类型用于精确值，例如货币。为此，您需要使用 [java.math.BigDecimal](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)类。 [数字和字符串](https://docs.oracle.com/javase/tutorial/java/data/index.html)涵盖`BigDecimal`Java平台提供的其他有用类。
- **double**：`double`数据类型是双精度64位IEEE 754浮点数。其值范围超出了本讨论的范围，但在Java语言规范的 [浮点类型，格式和值](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3)部分中指定。对于十进制值，此数据类型通常是默认选择。如上所述，此数据类型不应用于精确值，例如货币。
- **boolean**：`boolean`数据类型只有两个可能的值：`true`和`false`。将此数据类型用于跟踪真/假条件的简单标志。此数据类型表示一位信息，但其“大小”不是精确定义的内容。
- **char**：`char`数据类型是单个16位Unicode字符。它的最小值为`'\u0000'`（或0），最大值为`'\uffff'`（或65,535（含））。

除了上面列出的八种原始数据类型之外，Java编程语言还通过[java.lang.String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)类为字符串提供特殊支持 。将字符串括在双引号内将自动创建一个新`String`对象; 例如，`String s = "this is a string";`。`String`对象是*不可变的*，这意味着一旦创建，它们的值就无法更改。该`String`班是不是技术上原始数据类型，但考虑由语言所赋予的特殊支持，你可能会倾向于认为它是这样的。您将`String`在[Simple Data Objects中](https://docs.oracle.com/javase/tutorial/java/data/index.html)了解有关该类的 更多信息

**默认值**

声明字段时并不总是需要分配值。声明但未初始化的字段将由编译器设置为合理的默认值。一般来说，此默认值为零或`null`取决于数据类型。然而，依赖于这样的默认值通常被认为是糟糕的编程风格。

下表总结了上述数据类型的默认值。

| **Data Type**          | **Default Value (for fields)** |
| ---------------------- | ------------------------------ |
| byte                   | 0                              |
| short                  | 0                              |
| int                    | 0                              |
| long                   | 0L                             |
| float                  | 0.0f                           |
| double                 | 0.0d                           |
| char                   | '\u0000'                       |
| String (or any object) | null                           |
| boolean                | false                          |

局部变量略有不同; 编译器永远不会为未初始化的局部变量分配默认值。如果无法初始化声明它的局部变量，请确保在尝试使用它之前为其赋值。访问未初始化的局部变量将导致编译时错误。

**字面值**

您可能已经注意到`new`在初始化基本类型的变量时不使用关键字。基元类型是语言中内置的特殊数据类型; 它们不是从类创建的对象。甲*文字*是固定值的源代码表示; 文字直接在代码中表示，无需计算。如下所示，可以将文字分配给基本类型的变量：

````java
boolean result = true;
char capitalC = 'C';
byte b = 100;
short s = 10000;
int i = 100000;
````

**整型字面值**

字面的整数类型的`long`，如果它以字母`L`或`l`; 否则它是类型`int`。建议您使用大写字母，`L`因为小写字母`l`很难与数字区分开来`1`。

整型值`byte`，`short`，`int`，并且`long`可以从创造`int`文字。`long`超出范围的类型的值`int`可以从`long`文字创建。整数文字可以用这些数字系统表示：

- 十进制：基数为10，其数字由数字0到9组成; 这是您每天使用的数字系统
- 十六进制：Base 16，其数字由数字0到9和字母A到F组成
- 二进制：基数2，其数字由数字0和1组成（您可以在Java SE 7及更高版本中创建二进制文字）

对于通用编程，十进制系统可能是您将使用的唯一数字系统。但是，如果需要使用其他数字系统，以下示例将显示正确的语法。前缀`0x`表示十六进制，`0b`表示二进制：

````java
// The number 26, in decimal
int decVal = 26;
//  The number 26, in hexadecimal
int hexVal = 0x1a;
// The number 26, in binary
int binVal = 0b11010;
````

**浮点字面值**

浮点文字的类型的`float`，如果它以字母`F`或`f`; 否则它的类型是`double`，它可以选择以字母`D`或结尾`d`。

浮点类型（`float`和`double`）也可以用E或e（用于科学记数法），F或f（32位浮点字面量）和D或d（64位双字面值）表示;这是默认值，按惯例是中省略）。

````java
double d1 = 123.4;
// same value as d1, but in scientific notation
double d2 = 1.234e2;
float f1  = 123.4f;
````

**字符和字符串字面值**

类型`char`和`String`可以包含任何Unicode（UTF-16）字符。如果您的编辑器和文件系统允许，您可以直接在代码中使用这些字符。如果没有，您可以使用“Unicode转义”，例如`'\u0108'`（带有circumflex的大写C）或`"S\u00ED Se\u00F1or"`（西班牙语中的SíSeñor）。始终对`char`文字使用“单引号”，对文字使用“双引号” `String`。Unicode转义序列可以在程序的其他地方使用（例如在字段名称中），而不仅仅是在文字`char`或`String`文字中。

Java编程语言还支持一些特殊的转义序列`char`和`String`文字:( `\b`退格），`\t`（制表符），`\n`（换行），`\f`（换页），`\r`（回车），`\"`（双引号），`\'`（单引号）和`\\`（反斜杠）。

还有一个特殊的`null`文字可以用作任何参考类型的值。`null`除了基本类型的变量之外，可以将其分配给任何变量。`null`除了测试它的存在之外，你几乎无法做到超值。因此，`null`经常在程序中用作标记来指示某些对象不可用。

最后，还有一种特殊的文字，称为*类文字*，通过获取类型名称并附加“ `.class"`;例如，`String.class`。”这是指`Class`表示类型本身的对象（类型）。

**在数字字面值中使用下划线**

在Java SE 7及更高版本中，任何数量的下划线字符（`_`）都可以出现在数字文字中的数字之间的任何位置。例如，此功能可用于您。分隔数字文字中的数字组，这可以提高代码的可读性。

例如，如果您的代码包含具有多个数字的数字，则可以使用下划线字符来分隔三个组中的数字，类似于使用逗号或空格等标点符号作为分隔符的方式。

以下示例显示了在数字文字中使用下划线的其他方法：

````java
long creditCardNumber = 1234_5678_9012_3456L; 
long socialSecurityNumber = 999_99_9999L; 
float pi = 3.14_15F; 
long hexBytes = 0xFF_EC_DE_5E; 
long hexWords = 0xCAFE_BABE; 
long maxLong = 0x7fff_ffff_ffff_ffffL; 
byte nybbles = 0b0010_0101; 
long bytes = 0b11010010_01101001_10010100_10010010;
````

您只能在数字之间放置下划线; 你不能在以下地方放置下划线：

- 在数字的开头或结尾
- 与浮点文字中的小数点相邻
- 之前`F`或`L`后缀
- 在预期有一串数字的位置

以下示例演示了数字文字中有效和无效的下划线放置（突出显示）：

````java
// Invalid: cannot put underscores
// adjacent to a decimal point
float pi1 = 3_.1415F;
// Invalid: cannot put underscores 
// adjacent to a decimal point
float pi2 = 3._1415F;
// Invalid: cannot put underscores 
// prior to an L suffix
long socialSecurityNumber1 = 999_99_9999_L;

// OK (decimal literal)
int x1 = 5_2;
// Invalid: cannot put underscores
// At the end of a literal
int x2 = 52_;
// OK (decimal literal)
int x3 = 5_______2;

// Invalid: cannot put underscores
// in the 0x radix prefix
int x4 = 0_x52;
// Invalid: cannot put underscores
// at the beginning of a number
int x5 = 0x_52;
// OK (hexadecimal literal)
int x6 = 0x5_2; 
// Invalid: cannot put underscores
// at the end of a number
int x7 = 0x52_;
````

#### 数组

一个*阵列*是保持单一类型的值的固定数目的容器对象。创建数组时，将建立数组的长度。创建后，其长度是固定的。你已经在`main`“Hello World！” 的方法中看到了一个数组的例子。应用。本节更详细地讨论了数组。

![image-20190504131241768](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504131241768.png)

数组中的每个项称为一个*元素*，每个元素都由其数字*索引*访问。如上图所示，编号从0开始。例如，第9个元素将在索引8处访问。

以下程序 [`ArrayDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArrayDemo.java)创建一个整数数组，将一些值放入数组中，并将每个值打印到标准输出。

````java
class ArrayDemo {
    public static void main(String[] args) {
        // declares an array of integers
        int[] anArray;

        // allocates memory for 10 integers
        anArray = new int[10];
           
        // initialize first element
        anArray[0] = 100;
        // initialize second element
        anArray[1] = 200;
        // and so forth
        anArray[2] = 300;
        anArray[3] = 400;
        anArray[4] = 500;
        anArray[5] = 600;
        anArray[6] = 700;
        anArray[7] = 800;
        anArray[8] = 900;
        anArray[9] = 1000;

        System.out.println("Element at index 0: "
                           + anArray[0]);
        System.out.println("Element at index 1: "
                           + anArray[1]);
        System.out.println("Element at index 2: "
                           + anArray[2]);
        System.out.println("Element at index 3: "
                           + anArray[3]);
        System.out.println("Element at index 4: "
                           + anArray[4]);
        System.out.println("Element at index 5: "
                           + anArray[5]);
        System.out.println("Element at index 6: "
                           + anArray[6]);
        System.out.println("Element at index 7: "
                           + anArray[7]);
        System.out.println("Element at index 8: "
                           + anArray[8]);
        System.out.println("Element at index 9: "
                           + anArray[9]);
    }
} 
````

该程序的输出是：

````shell
Element at index 0: 100
Element at index 1: 200
Element at index 2: 300
Element at index 3: 400
Element at index 4: 500
Element at index 5: 600
Element at index 6: 700
Element at index 7: 800
Element at index 8: 900
Element at index 9: 1000
````

在实际编程情况下，您可能会使用其中一个受支持的*循环结构*来遍历数组的每个元素，而不是像前面的示例中那样单独写入每一行。但是，该示例清楚地说明了数组语法。您将了解各种循环结构（`for`，`while`，和`do-while`在） [控制流](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)部分。

**声明变量以引用数组**

前面的程序`anArray`使用以下代码行声明一个数组（命名）：

````java
// declares an array of integers
int[] anArray;
````

与其他类型的变量的声明一样，数组声明有两个组件：数组的类型和数组的名称。数组的类型写为`*type*[]`，`*type*`包含的元素的数据类型在哪里; 括号是特殊符号，表示此变量包含数组。数组的大小不是其类型的一部分（这就是括号为空的原因）。数组的名称可以是您想要的任何名称，前提是它遵循先前在[命名](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming)部分中讨论的规则和约定 。与其他类型的变量一样，声明实际上并不创建数组; 它只是告诉编译器该变量将包含指定类型的数组。

同样，您可以声明其他类型的数组：

````java
byte[] anArrayOfBytes;
short[] anArrayOfShorts;
long[] anArrayOfLongs;
float[] anArrayOfFloats;
double[] anArrayOfDoubles;
boolean[] anArrayOfBooleans;
char[] anArrayOfChars;
String[] anArrayOfStrings;
````

您还可以将括号放在数组名称后面：

````java
// this form is discouraged
float anArrayOfFloats[];
````

但是，公约不鼓励这种形式; 括号标识数组类型，并应显示类型名称

**创建，初始化和访问数组**

创建数组的一种方法是与`new`运算符一起使用。程序中的下一个语句`ArrayDemo`为10个整数元素分配一个具有足够内存的数组，并将该数组`anArray`赋值给变量。

````java
// create an array of integers
anArray = new int[10];
````

如果缺少此语句，则编译器会输出如下错误，并且编译失败：

````java
ArrayDemo.java:4: Variable anArray may not have been initialized.
````

接下来的几行为数组的每个元素赋值：

````java
anArray[0] = 100; // initialize first element
anArray[1] = 200; // initialize second element
anArray[2] = 300; // and so forth
````

或者，您可以使用快捷语法来创建和初始化数组：

````java
int[] anArray = { 
    100, 200, 300,
    400, 500, 600, 
    700, 800, 900, 1000
};
````

这里数组的长度由大括号之间提供的值的数量确定，并用逗号分隔。

您还可以使用两组或更多组括号声明一个数组数组（也称为*多维*数组），例如`String[][] names`。因此，每个元素必须由相应数量的索引值访问。

在Java编程语言中，多维数组是一个数组，其组件本身就是数组。这与C或Fortran中的数组不同。这样做的结果是允许行的长度不同，如以下[`MultiDimArrayDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/MultiDimArrayDemo.java)程序所示 ：

````java
class MultiDimArrayDemo {
    public static void main(String[] args) {
        String[][] names = {
            {"Mr. ", "Mrs. ", "Ms. "},
            {"Smith", "Jones"}
        };
        // Mr. Smith
        System.out.println(names[0][0] + names[1][0]);
        // Ms. Jones
        System.out.println(names[0][2] + names[1][1]);
    }
}
````

该程序的输出是：

````shell
Mr. Smith
Ms. Jones
````

最后，您可以使用内置`length`属性来确定任何数组的大小。以下代码将数组的大小打印到标准输出：

````java
 System.out.println(anArray.length);
````

**复制数组**

`System`类有一个`arraycopy`，可以使用有效地将数据从一个阵列复制到另一个方法：

````java
public static void arraycopy（Object src，int srcPos，
                             Object dest，int destPos，int length）
````

这两个`Object`参数指定*要从*中复制的数组和要复制*到*的数组。这三个`int`参数指定源数组中的起始位置，目标数组中的起始位置以及要复制的数组元素的数量。

以下程序 [`ArrayCopyDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArrayCopyDemo.java)声明了一系列`char`元素，拼写单词“decafffeinated”。它使用该`System.arraycopy`方法将数组组件的子序列复制到第二个数组中。

````java
class ArrayCopyDemo { 
    public static void main（String [] args）{ 
        char [] copyFrom = {'d'，'e'，'c'，'a'，'f'，'f'，'e'，
			    'i '，'n'，'a'，'t'，'e'，'d'}; 
        char [] copyTo = new char [7]; 

        System.arraycopy（copyFrom，2，copyTo，0,7）; 
        System.out.println（new String（copyTo））; 
    } 
}
````

该程序的输出是：

````shell
caffein
````

**数组操作**

数组是编程中使用的强大而有用的概念。Java SE提供了执行与数组相关的一些最常见操作的方法。例如，该[`ArrayCopyDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArrayCopyDemo.java)示例使用类的`arraycopy`方法`System`而不是手动迭代源数组的元素并将每个元素放入目标数组中。这是在幕后执行的，使开发人员只使用一行代码来调用该方法。

为方便起见，Java SE提供了几种在类中执行数组操作（常见任务，如复制，排序和搜索数组）的方法 [`java.util.Arrays`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html)。例如，可以修改前面的示例以使用类的`copyOfRange`方法`java.util.Arrays`，如 [`ArrayCopyOfDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArrayCopyOfDemo.java)示例中所示。不同之处在于，使用该`copyOfRange`方法不需要在调用方法之前创建目标数组，因为方法返回目标数组：

````java
class ArrayCopyOfDemo { 
    public static void main（String [] args）{ 
        
        char [] copyFrom = {'d'，'e'，'c'，'a'，'f'，'f'，'e'，
            'i '，'n'，'a'，'t'，'e'，'d'}; 
            
        char [] copyTo = java.util.Arrays.copyOfRange（copyFrom，2,9）; 
        
        System.out.println（new String（copyTo））; 
    } 
}
````

正如您所看到的，此程序的输出是相同的（`caffein`），尽管它需要更少的代码行。需要注意的是的第二个参数`copyOfRange`的方法是该范围的初始索引被复制，包含地，而第三个参数是将要复制的区间的最后的索引，*只*。在此示例中，要复制的范围不包括索引9处的数组元素（包含该字符`a`）。

`java.util.Arrays`该类中的方法提供的一些其他有用的操作是：

- 在数组中搜索特定值以获取放置它的索引（`binarySearch`方法）。
- 比较两个数组以确定它们是否相等（`equals`方法）。
- 填充数组以在每个索引处放置特定值（`fill`方法）。
- 按升序对数组进行排序。这可以使用该`sort`方法顺序完成，也可以使用`parallelSort`Java SE 8中引入的方法同时完成。多处理器系统上的大型数组的并行排序比顺序数组排序更快。

#### 变量摘要

Java编程语言使用“字段”和“变量”作为其术语的一部分。实例变量（非静态字段）对于类的每个实例都是唯一的。类变量（静态字段）是使用`static`修饰符声明的字段; 无论类实例化了多少次，都只有一个类变量的副本。局部变量在方法中存储临时状态。参数是为方法提供额外信息的变量; 局部变量和参数总是被归类为“变量”（而不是“字段”）。在命名字段或变量时，您应该（或必须）遵循规则和约定。

八种原始数据类型是：byte，short，int，long，float，double，boolean和char。本 [`java.lang.String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)类代表字符串。编译器将为上述类型的字段分配合理的默认值; 对于局部变量，永远不会分配默认值。文字是固定值的源代码表示。数组是一个容器对象，它包含固定数量的单个类型的值。创建数组时，将建立数组的长度。创建后，其长度是固定的。

### 运算符

现在，你已经学会了如何声明和初始化变量，你可能想知道如何*做一些*与他们。学习Java编程语言的操作符是一个很好的起点。运算符是对一个，两个或三个*操作数*执行特定操作的特殊符号，然后返回结果。

在我们探索Java编程语言的运算符时，提前知道哪些运算符具有最高优先级可能对您有所帮助。下表中的运算符按优先顺序列出。操作员越接近表格顶部，其优先级越高。优先级较高的运算符在优先级相对较低的运算符之前进行求值。同一行上的运营商具有相同的优先权。当具有相同优先级的运算符出现在同一表达式中时，规则必须控制首先计算的值。除了赋值运算符之外的所有二元运算符都是从左到右计算的; 赋值运算符从右到左进行计算。

| Operators            | Precedence                               |
| -------------------- | ---------------------------------------- |
| postfix              | `*expr*++ *expr*--`                      |
| unary                | `++*expr* --*expr* +*expr* -*expr* ~ !`  |
| multiplicative       | `* / %`                                  |
| additive             | `+ -`                                    |
| shift                | `<< >> >>>`                              |
| relational           | `< > <= >= instanceof`                   |
| equality             | `== !=`                                  |
| bitwise AND          | `&`                                      |
| bitwise exclusive OR | `^`                                      |
| bitwise inclusive OR | `|`                                      |
| logical AND          | `&&`                                     |
| logical OR           | `||`                                     |
| ternary              | `? :`                                    |
| assignment           | `= += -= *= /= %= &= ^= |= <<= >>= >>>=` |

在通用编程中，某些运营商往往比其他运营商更频繁地出现; 例如，赋值运算符“ `=`”比无符号右移运算符“ `>>>`” 更常见。考虑到这一点，以下讨论首先关注您最有可能定期使用的运营商，并最终关注那些不太常见的运营商。每个讨论都附有可以编译和运行的示例代码。研究它的输出将有助于强化你刚刚学到的东西。

#### 赋值，算术和一元运算符

**赋值操作符**

您将遇到的最常见的运算符之一是简单的赋值运算符“ `=`”。你在Bicycle类中看到过这个操作符; 它将右侧的值赋给左侧的操作数：

````java
 int cadence = 0;
 int speed = 0;
 int gear = 1;
````

此运算符也可用于对象以分配*对象引用*，如 [创建对象中所述](https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html)。

**算术运算符**

Java编程语言提供执行加法，减法，乘法和除法的运算符。你很可能会在基础数学方面认识他们。唯一可能对你来说很新的符号是“ `%`”，它将一个操作数除以另一个操作数，并将余数作为结果返回。

| Operator | Description                              |
| -------- | ---------------------------------------- |
| `+`      | Additive operator (also used for String concatenation) |
| `-`      | Subtraction operator                     |
| `*`      | Multiplication operator                  |
| `/`      | Division operator                        |
| `%`      | Remainder operator                       |

以下程序 [`ArithmeticDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArithmeticDemo.java)测试算术运算符。

````java
class ArithmeticDemo {

    public static void main (String[] args) {

        int result = 1 + 2;
        // result is now 3
        System.out.println("1 + 2 = " + result);
        int original_result = result;

        result = result - 1;
        // result is now 2
        System.out.println(original_result + " - 1 = " + result);
        original_result = result;

        result = result * 2;
        // result is now 4
        System.out.println(original_result + " * 2 = " + result);
        original_result = result;

        result = result / 2;
        // result is now 2
        System.out.println(original_result + " / 2 = " + result);
        original_result = result;

        result = result + 8;
        // result is now 10
        System.out.println(original_result + " + 8 = " + result);
        original_result = result;

        result = result % 7;
        // result is now 3
        System.out.println(original_result + " % 7 = " + result);
    }
}
````

该程序打印以下内容：

````shell
1 + 2 = 3
3 - 1 = 2
2 * 2 = 4
4 / 2 = 2
2 + 8 = 10
10 % 7 = 3
````

您还可以将算术运算符与简单赋值运算符组合以创建*复合赋值*。例如，`x+=1;`与`x=x+1;`两个增量的值`x`由1。

的`+`操作者也可以用于级联（接合）两个字符串在一起，如示于下述 [`ConcatDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConcatDemo.java)方案：

````java
class ConcatDemo {
    public static void main(String[] args){
        String firstString = "This is";
        String secondString = " a concatenated string.";
        String thirdString = firstString+secondString;
        System.out.println(thirdString);
    }
}
````

在该程序结束时，变量`thirdString`包含“This is a concatenated string。”，它将打印到标准输出。

**一元运算符**

一元运算符只需要一个操作数; 它们执行各种操作，例如将值递增/递减1，否定表达式或反转布尔值。

| Operator | Description                              |
| -------- | ---------------------------------------- |
| `+`      | Unary plus operator; indicates positive value (numbers are positive without this, however) |
| `-`      | Unary minus operator; negates an expression |
| `++`     | Increment operator; increments a value by 1 |
| `--`     | Decrement operator; decrements a value by 1 |
| `!`      | Logical complement operator; inverts the value of a boolean |

以下程序 [`UnaryDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/UnaryDemo.java)测试一元运算符：

````java
class UnaryDemo {

    public static void main(String[] args) {

        int result = +1;
        // result is now 1
        System.out.println(result);

        result--;
        // result is now 0
        System.out.println(result);

        result++;
        // result is now 1
        System.out.println(result);

        result = -result;
        // result is now -1
        System.out.println(result);

        boolean success = false;
        // false
        System.out.println(success);
        // true
        System.out.println(!success);
    }
}
````

可以在操作数之前（前缀）或之后（后缀）应用递增/递减运算符。代码`result++;`并将`++result;`以`result`加1 结束。唯一的区别是前缀version（`++result`）计算增量值，而后缀version（`result++`）计算为原始值。如果您只是执行简单的增量/减量，那么选择哪个版本并不重要。但是，如果您在较大的表达式中使用此运算符，则您选择的运算符可能会产生显着差异。

以下程序 [`PrePostDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/PrePostDemo.java)说明了前缀/后缀一元增量运算符：

````java
class PrePostDemo {
    public static void main(String[] args){
        int i = 3;
        i++;
        // prints 4
        System.out.println(i);
        ++i;			   
        // prints 5
        System.out.println(i);
        // prints 6
        System.out.println(++i);
        // prints 6
        System.out.println(i++);
        // prints 7
        System.out.println(i);
    }
}
````

#### 相等，关系和条件运算符

**相等与关系运算符**

等于和关系运算符确定一个操作数是否大于，小于，等于或不等于另一个操作数。这些操作员中的大多数也可能看起来很熟悉。请记住，在测试两个原始值是否相等时`==`，必须使用“ ”而不是“ `=`”。

````
==      equal to
!=      not equal to
>       greater than
>=      greater than or equal to
<       less than
<=      less than or equal to
````

以下程序 [`ComparisonDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ComparisonDemo.java)测试比较运算符：

````java
class ComparisonDemo {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        if(value1 == value2)
            System.out.println("value1 == value2");
        if(value1 != value2)
            System.out.println("value1 != value2");
        if(value1 > value2)
            System.out.println("value1 > value2");
        if(value1 < value2)
            System.out.println("value1 < value2");
        if(value1 <= value2)
            System.out.println("value1 <= value2");
    }
}
````

输出：

````
value1 != value2
value1 <  value2
value1 <= value2
````

**条件操作符**

`&&`与`||` 操作符在两个布尔表达式之间进行 *有条件与*和 *有条件或*运算。这些运算符表现出“短路”行为，这意味着仅在需要时才评估第二个操作数。

````
&& Conditional-AND
|| Conditional-OR
````

以下程序 [`ConditionalDemo1`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConditionalDemo1.java)测试这些运算符：

````java
class ConditionalDemo1 {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        if((value1 == 1) && (value2 == 2))
            System.out.println("value1 is 1 AND value2 is 2");
        if((value1 == 1) || (value2 == 1))
            System.out.println("value1 is 1 OR value2 is 1");
    }
}
````

另一个条件运算符`?:`，可以被认为是`if-then-else`语句的简写（在本课程的[控制流语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)部分中讨论 ）。此运算符也称为*三元运算符，*因为它使用三个操作数。在下面的示例中，此运算符应读作：“如果`someCondition`是`true`，则赋值`value1`to `result`。否则，赋值`value2`to `result`。”

以下程序 [`ConditionalDemo2`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConditionalDemo2.java)测试`?:`运算符：

````java
class ConditionalDemo2 {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        int result;
        boolean someCondition = true;
        result = someCondition ? value1 : value2;

        System.out.println(result);
    }
}
````

因为`someCondition`是，所以该程序在屏幕上打印“1”。如果它使代码更具可读性，则使用`?:`运算符而不是`if-then-else`语句; 例如，当表达式紧凑且没有副作用（例如赋值）时。

**类型比较运算符 instanceof**

`instanceof`操作符将对象与指定类型进行比较。您可以使用它来测试对象是否是类的实例，子类的实例或实现特定接口的类的实例。

以下程序 [`InstanceofDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/InstanceofDemo.java)定义父类（已命名`Parent`），简单接口（已命名`MyInterface`）和`Child`从父进程继承并实现接口的子类（已命名）。

````java
class InstanceofDemo {
    public static void main(String[] args) {

        Parent obj1 = new Parent();
        Parent obj2 = new Child();

        System.out.println("obj1 instanceof Parent: "
            + (obj1 instanceof Parent));
        System.out.println("obj1 instanceof Child: "
            + (obj1 instanceof Child));
        System.out.println("obj1 instanceof MyInterface: "
            + (obj1 instanceof MyInterface));
        System.out.println("obj2 instanceof Parent: "
            + (obj2 instanceof Parent));
        System.out.println("obj2 instanceof Child: "
            + (obj2 instanceof Child));
        System.out.println("obj2 instanceof MyInterface: "
            + (obj2 instanceof MyInterface));
    }
}

class Parent {}
class Child extends Parent implements MyInterface {}
interface MyInterface {}
````

输出：

````
obj1 instanceof Parent: true
obj1 instanceof Child: false
obj1 instanceof MyInterface: false
obj2 instanceof Parent: true
obj2 instanceof Child: true
obj2 instanceof MyInterface: true
````

使用`instanceof`运算符时，请记住，`null`不是任何类型的实例。

#### 位运算和移位操作符

Java编程语言还提供对整数类型执行按位和位移操作的运算符。本节中讨论的运算符不太常用。因此，他们的报道很简短; 目的是让您意识到这些运算符的存在。

一元按位补码运算符“ `~`”反转位模式; 它可以应用于任何整数类型，使每个“0”为“1”，每个“1”为“0”。例如，a `byte`包含8位; 将此运算符应用于位模式为“00000000”的值会将其模式更改为“11111111”。

带符号的左移位运算符“ `<<`”将位模式向左移位，带符号的右移位运算符“ `>>`”将位模式向右移位。位模式由左侧操作数给出，位置数由右侧操作数移位。无符号右移运算符“ `>>>`”将零移动到最左边的位置，而后面的最左边位置`">>"`取决于符号扩展。

按位运算`&`符执行按位AND运算。

按位运算`^`符执行按位异或运算。

按位运算`|`符执行按位包含OR运算。

以下程序 [`BitDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BitDemo.java)使用按位AND运算符将数字“2”打印到标准输出。

````java
class BitDemo {
    public static void main(String[] args) {
        int bitmask = 0x000F;
        int val = 0x2222;
        // prints "2"
        System.out.println(val & bitmask);
    }
}
````

#### 运算符总结

以下快速参考总结了Java编程语言支持的运算符。

**简单赋值操作符**

```
=       Simple assignment operator
```

**算术运算符**

```
+       Additive operator (also used
        for String concatenation)
-       Subtraction operator
*       Multiplication operator
/       Division operator
%       Remainder operator
```

**一元操作符**

```
+       Unary plus operator; indicates
        positive value (numbers are 
        positive without this, however)
-       Unary minus operator; negates
        an expression
++      Increment operator; increments
        a value by 1
--      Decrement operator; decrements
        a value by 1
!       Logical complement operator;
        inverts the value of a boolean
```

**相等和关系运算符**

```
==      Equal to
!=      Not equal to
>       Greater than
>=      Greater than or equal to
<       Less than
<=      Less than or equal to
```

**条件操作符**

```
&&      Conditional-AND
||      Conditional-OR
?:      Ternary (shorthand for 
        if-then-else statement)
```

**类型比较操作符**

```
instanceof      Compares an object to 
                a specified type 
```

**位运算和位移操作符**

```
~       Unary bitwise complement
<<      Signed left shift
>>      Signed right shift
>>>     Unsigned right shift
&       Bitwise AND
^       Bitwise exclusive OR
|       Bitwise inclusive OR
```

### 表达式，语句和块

现在您已了解变量和运算符，现在是时候了解*表达式*，*语句*和*块*。运算符可用于构建计算值的表达式; 表达式是陈述的核心组成部分; 语句可以分组为块。

**表达式**

一个*表达式*是变量，运算符和方法调用，它们根据语言的语法，计算结果为单个值构成由一个构建体。您已经看过表达式的示例，如下面的粗体所示：

````java
int cadence = 0;
anArray[0] = 100;
System.out.println("Element 1 at index 0: " + anArray[0]);

int result = 1 + 2; // result is now 3
if (value1 == value2) 
    System.out.println("value1 == value2");
````

表达式返回的值的数据类型取决于表达式中使用的元素。表达式`cadence = 0`返回一个，`int`因为赋值运算符返回与其左侧操作数相同的数据类型的值; 在这种情况下，`cadence`是一个`int`。从其他表达式中可以看出，表达式也可以返回其他类型的值，例如`boolean`或`String`。

只要表达式的一部分所需的数据类型与另一部分的数据类型匹配，Java编程语言就允许您从各种较小的表达式构造复合表达式。以下是复合表达式的示例：

````
1 * 2 * 3
````

在这个特定的例子中，表达式的计算顺序并不重要，因为乘法的结果与顺序无关; 结果总是相同的，无论您采用乘法的顺序。但是，并非所有表达式都是如此。例如，以下表达式给出不同的结果，具体取决于您是先执行加法还是除法运算：

```
x + y / 100 // 含糊不清
```

您可以使用平衡括号精确指定表达式的计算方式:(和）。例如，要使前一个表达式明确，您可以编写以下内容：

```
（x + y）/ 100 // 明确无误，推荐
```

如果未明确指示要执行的操作的顺序，则顺序由分配给表达式中使用的运算符的优先级确定。首先评估具有更高优先级的运算符。例如，除法运算符的优先级高于加法运算符。因此，以下两个陈述是等效的：

```
x + y / 100 
x +（y / 100）//明确，推荐
```

在编写复合表达式时，请明确并用括号表示应首先评估哪些运算符。这种做法使代码更易于阅读和维护。

**语句**

语句大致相当于自然语言中的句子。一个*语句*形成一个完整的执行单元。下列类型的表达式可以通过使用终结表达式，一个分号````;````，来变成一个语句。


- 赋值表达式
- 任何使用 `++` or `--` 的表达式
- 方法调用
- 对象创建表达式

这种语句被称为*表达式语句*。下面是介个表达式语句的例子：

```
// assignment statement
aValue = 8933.234;
// increment statement
aValue++;
// method invocation statement
System.out.println("Hello World!");
// object creation statement
Bicycle myBike = new Bicycle();
```
除了表达式语句，还存在其他两种语句：*声明语句* 和 *控制流语句*。一个*声明语句*声明一个变量。你应该已经看到过很多声明语句：

```
// declaration statement
double aValue = 8933.234;
```

最后，*控制流语句*调节语句执行的顺序。您将在下一节“控制流语句”中了解 [控制流语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)。

**块**

*块*是一组成对的括号之间的零条或多个语句，并且可以在任何地方使用单个语句是允许的。以下示例 [`BlockDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BlockDemo.java)说明了块的使用：

````java
class BlockDemo {
     public static void main(String[] args) {
          boolean condition = true;
          if (condition) { // begin block 1
               System.out.println("Condition is true.");
          } // end block one
          else { // begin block 2
               System.out.println("Condition is false.");
          } // end block 2
     }
}
````

### 控制流程语句

源文件中的语句通常按照它们出现的顺序从上到下执行。但是，*控制流语句*通过使用决策，循环和分支来打破执行流程，使您的程序能够*有条件地*执行特定的代码块。本节介绍了决策声明（`if-then`，`if-then-else`，`switch`），该循环语句（`for`，`while`，`do-while`）和分支语句（`break`，`continue`，`return`）的Java编程语言的支持。

#### ````if-then````和 ````if-then-else```` 语句

**````if-then```` 语句**

````if-then```` 语句是所有控制流语句中最基本的语句。它告诉程序只有在特定测试评估为 ````true```` 时才执行某段代码。例如，只有在自行车已经运动时，自行车等级才允许制动器降低自行车的速度。 ````applyBrakes```` 方法的一种可能实现如下：

````java
void applyBrakes() {
    // the "if" clause: bicycle must be moving
    if (isMoving){ 
        // the "then" clause: decrease current speed
        currentSpeed--;
    }
}
````

如果此测试评估为 ````false````（意味着自行车未运动），则控制跳转到 ````if-then```` 语句的末尾。

此外，只要 “then” 子句只包含一个语句，开括号和结束括号是可选的：

````java
void applyBrakes() {
    // same as above, but without braces 
    if (isMoving)
        currentSpeed--;
}
````

决定何时省略大括号是个人品味的问题。省略它们会使代码变得更脆弱。如果稍后将第二个语句添加到 “then” 子句中，则常见的错误是忘记添加新所需的大括号。编译器无法捕获这种错误，你会得到错误的结果。

**````if-then-else```` 语句**

````if-then-else```` 语句在 “if” 子句求值为 ````false```` 时提供辅助执行路径。如果在自行车不运动时应用制动器，则可以在 ````applyBrakes```` 方法中使用 ````if-then-else```` 语句来执行某些操作。在这种情况下，操作是简单地打印一条错误消息，指出自行车已经停止。

````java
void applyBrakes() {
    if (isMoving) {
        currentSpeed--;
    } else {
        System.err.println("The bicycle has already stopped!");
    } 
}
````

以下程序 [`IfElseDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/IfElseDemo.java) 根据测试分数的值分配等级：分数为90％或以上的是A，分数为80％或以上的是B，依此类推。

````java
class IfElseDemo {
    public static void main(String[] args) {

        int testscore = 76;
        char grade;

        if (testscore >= 90) {
            grade = 'A';
        } else if (testscore >= 80) {
            grade = 'B';
        } else if (testscore >= 70) {
            grade = 'C';
        } else if (testscore >= 60) {
            grade = 'D';
        } else {
            grade = 'F';
        }
        System.out.println("Grade = " + grade);
    }
}
````

输出是：

````
Grade = C
````

您可能已经注意到 ````testscore```` 的值可以满足复合语句中的多个表达式：76> = 70 和 76> = 60。但是，一旦满足条件，就会执行相应的语句（````grade ='C';```` ）并且不评估剩余的条件。

#### ````swith```` 语句

与 ````if-then```` 和 ````if-then-else```` 语句不同，````switch```` 语句可以有许多可能的执行路径。````switch```` 语句使用 ````byte````，````short````，````char```` 和 ````int```` 原始数据类型。它也适用于枚举类型（在[Enum Types](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)中讨论），[`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) 类，以及一些包含某些基本类型的特殊类： [`Character`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html), [`Byte`](https://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html), [`Short`](https://docs.oracle.com/javase/8/docs/api/java/lang/Short.html), and[`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html) （在[Numbers and Strings](https://docs.oracle.com/javase/tutorial/java/data/index.html)中讨论）。

以下代码示例 [`SwitchDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemo.java) 声明了一个名为 ````month```` 的 ````int````，其值表示月份。 代码使用 ````switch```` 语句根据 ````month```` 的值显示月份的名称。

````java
public class SwitchDemo {
    public static void main(String[] args) {

        int month = 8;
        String monthString;
        switch (month) {
            case 1:  monthString = "January";
                     break;
            case 2:  monthString = "February";
                     break;
            case 3:  monthString = "March";
                     break;
            case 4:  monthString = "April";
                     break;
            case 5:  monthString = "May";
                     break;
            case 6:  monthString = "June";
                     break;
            case 7:  monthString = "July";
                     break;
            case 8:  monthString = "August";
                     break;
            case 9:  monthString = "September";
                     break;
            case 10: monthString = "October";
                     break;
            case 11: monthString = "November";
                     break;
            case 12: monthString = "December";
                     break;
            default: monthString = "Invalid month";
                     break;
        }
        System.out.println(monthString);
    }
}
````

这种情况下，标准输出中打印 ````August```` 。

````switch```` 语句的主体称为 *switch块*。 可以使用一个或多个 ````case```` 或 ````default```` 标签来标记 ````switch```` 块中的语句。````switch```` 语句计算其表达式，然后执行匹配的 ````case```` 标签后面的所有语句。

您还可以使用 ````if-then-else```` 语句显示月份的名称：

````java
int month = 8;
if (month == 1) {
    System.out.println("January");
} else if (month == 2) {
    System.out.println("February");
}
...  // and so on
````

决定使用 ````if-then-else```` 语句还是 ````switch```` 语句是基于程序可读性和语句测试的表达式两方面考虑。````if-then-else```` 语句可以基于值或条件的范围来测试表达式，而 ````switch```` 语句仅基于单个整数，枚举值或 ````String```` 对象来测试表达式。

另一个关键点是 ````break```` 语句。每个 ````break```` 语句都会终止包含它的 ````switch```` 语句。控制流程继续执行 ````switch```` 块后面的第一个语句。````break```` 语句是必需的，因为没有它们，````switch```` 块中的语句都会被穿透：匹配的 ````case```` 标签之后的所有语句都按顺序执行，而不管后续 ````case```` 标签的表达式，直到遇到 ````break```` 语句。程序 [`SwitchDemoFallThrough`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemoFallThrough.java) 显示 ````switch```` 块中的语句穿透。该程序显示对应于整数 ````month```` 的月份和该年份中的后续月份：

````java
public class SwitchDemoFallThrough {

    public static void main(String[] args) {
        java.util.ArrayList<String> futureMonths =
            new java.util.ArrayList<String>();

        int month = 8;

        switch (month) {
            case 1:  futureMonths.add("January");
            case 2:  futureMonths.add("February");
            case 3:  futureMonths.add("March");
            case 4:  futureMonths.add("April");
            case 5:  futureMonths.add("May");
            case 6:  futureMonths.add("June");
            case 7:  futureMonths.add("July");
            case 8:  futureMonths.add("August");
            case 9:  futureMonths.add("September");
            case 10: futureMonths.add("October");
            case 11: futureMonths.add("November");
            case 12: futureMonths.add("December");
                     break;
            default: break;
        }

        if (futureMonths.isEmpty()) {
            System.out.println("Invalid month number");
        } else {
            for (String monthName : futureMonths) {
               System.out.println(monthName);
            }
        }
    }
}
````

程序输出：

````
August
September
October
November
December
````

从技术上讲，不需要最后的 ````break````，因为后续流程不属于 ````switch```` 语句。 建议在最后使用 ````break````，以便更容易修改代码并减少错误。````default```` 部分处理 ````case```` 部分未明确处理的所有值。

以下代码示例 [`SwitchDemo2`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemo2.java) 显示了语句如何具有多个 ````case```` 标签。代码示例计算特定月份的天数：

````java
class SwitchDemo2 {
    public static void main(String[] args) {

        int month = 2;
        int year = 2000;
        int numDays = 0;

        switch (month) {
            case 1: case 3: case 5:
            case 7: case 8: case 10:
            case 12:
                numDays = 31;
                break;
            case 4: case 6:
            case 9: case 11:
                numDays = 30;
                break;
            case 2:
                if (((year % 4 == 0) && 
                     !(year % 100 == 0))
                     || (year % 400 == 0))
                    numDays = 29;
                else
                    numDays = 28;
                break;
            default:
                System.out.println("Invalid month.");
                break;
        }
        System.out.println("Number of Days = "
                           + numDays);
    }
}
````

程序输出：

````
Number of Days = 29
````

**在 ````switch```` 语句中使用 ````String````**

在 Java 7 及后续版本中，````switch```` 语句中的表达式中可以使用 ````String ```` 对象。下面的例子 [`StringSwitchDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/StringSwitchDemo.java) 展示了根据 ````String```` 类型的月份名称计算当月天数：

````java
public class StringSwitchDemo {

    public static int getMonthNumber(String month) {

        int monthNumber = 0;

        if (month == null) {
            return monthNumber;
        }

        switch (month.toLowerCase()) {
            case "january":
                monthNumber = 1;
                break;
            case "february":
                monthNumber = 2;
                break;
            case "march":
                monthNumber = 3;
                break;
            case "april":
                monthNumber = 4;
                break;
            case "may":
                monthNumber = 5;
                break;
            case "june":
                monthNumber = 6;
                break;
            case "july":
                monthNumber = 7;
                break;
            case "august":
                monthNumber = 8;
                break;
            case "september":
                monthNumber = 9;
                break;
            case "october":
                monthNumber = 10;
                break;
            case "november":
                monthNumber = 11;
                break;
            case "december":
                monthNumber = 12;
                break;
            default: 
                monthNumber = 0;
                break;
        }

        return monthNumber;
    }

    public static void main(String[] args) {

        String month = "August";

        int returnedMonthNumber =
            StringSwitchDemo.getMonthNumber(month);

        if (returnedMonthNumber == 0) {
            System.out.println("Invalid month");
        } else {
            System.out.println(returnedMonthNumber);
        }
    }
}
````

程序的输出是 8 。

将 ````switch```` 表达式中的 ````String```` 与每个 ````case```` 标签关联的表达式进行比较，就好像正在使用 [`String.equals`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-) 方法一样。为了使 ````StringSwitchDemo```` 示例无论何种情况都接受任何月份，月份将转换为小写（使用 [`toLowerCase`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toLowerCase--) 方法），并且与 ````case```` 标签关联的所有字符串均为小写。

注意：此示例检查 ````switch```` 语句中的表达式是否为 ````null````。确保任何 ````switch```` 语句中的表达式不为 ````null````，以防止抛出 ````NullPointerException````。

#### ````while```` 和 ````do-while```` 语句

````while```` 语句在特定条件为真时继续执行语句块。 其语法可表示为：

````java
while (expression) {
     statement(s)
}
````

````while```` 语句计算表达式，该表达式必须返回一个布尔值。如果表达式的计算结果为 ````true````，则 ````while```` 语句将执行 ````while```` 块中的语句。````while```` 语句持续测试表达式并执行其中的语句块，直到表达式求值为 ````false````。使用 ````while```` 语句打印1到10之间的值可以在以下 [`WhileDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/WhileDemo.java) 程序中完成：

````java
class WhileDemo {
    public static void main(String[] args){
        int count = 1;
        while (count < 11) {
            System.out.println("Count is: " + count);
            count++;
        }
    }
}
````

你可以像下面这样使用 ````while```` 语句实现死循环：

````java
while (true){
    // your code goes here
}
````

Java 语言还提供了 ````do-while```` 语句，可以表示如下：

````java
do {
     statement(s)
} while (expression);
````

````do-while```` 和 ````while```` 之间的区别在于 ````do-while```` 在循环的底部而不是顶部计算它的表达式。因此，````do```` 块中的语句总是至少执行一次，如下面的 [`DoWhileDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/DoWhileDemo.java) 程序所示：

````java
class DoWhileDemo {
    public static void main(String[] args){
        int count = 1;
        do {
            System.out.println("Count is: " + count);
            count++;
        } while (count < 11);
    }
}
````

#### ````for```` 语句

````for```` 语句提供了一种迭代一系列值的简洁方法。程序员经常将其称为 “for循环”，因为它反复循环直到满足特定条件。````for```` 语句的一般形式可表示如下：

````java
for (initialization; termination;
     increment) {
    statement(s)
}
````

使用此版本的 ````for```` 语句时，请记住：

* 初始化表达式初始化循环， 循环开始时，它执行一次。
* 当终止表达式求值为 ````false```` 时，循环终止。
* 每次迭代循环后调用 ````increment```` 表达式， 这个表达式增加或减少一个值是完全可以接受的。

下面的例子 [`ForDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ForDemo.java) 使用普通形式的 ````for```` 语句将 1 到 10 打印到标准输出中：

````java
class ForDemo {
    public static void main(String[] args){
         for(int i=1; i<11; i++){
              System.out.println("Count is: " + i);
         }
    }
}
````

输出：

````
Count is: 1
Count is: 2
Count is: 3
Count is: 4
Count is: 5
Count is: 6
Count is: 7
Count is: 8
Count is: 9
Count is: 10
````

注意代码如何在初始化表达式中声明变量。 此变量的作用域从其声明扩展到由 ````for```` 语句控制的块的末尾，因此它也可以用在终止和增量表达式中。如果在循环外部不需要控制 ````for```` 语句的变量，则最好在初始化表达式中声明该变量。名称 i，j 和 k 通常用于控制循环。在初始化表达式中声明它们会限制它们的生命周期并减少错误。

````for```` 循环中的 3 个表达式都是可选的，可以如下创建一个无限循环：

````java
// infinite loop
for ( ; ; ) {
    
    // your code goes here
}
````

````for```` 语句还有另一种用于迭代 [Collections](https://docs.oracle.com/javase/tutorial/collections/index.html) 和 [arrays](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html) 的形式。这种形式有时被称为增强````for````语句，可用于使循环更紧凑和易于阅读。要演示，请考虑以下数组，其中包含数字1到10：

````java
int[] numbers = {1,2,3,4,5,6,7,8,9,10};
````

下面的例子，[`EnhancedForDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/EnhancedForDemo.java) 使用增强型 ````for```` 循环遍历上面的数组：

````java
class EnhancedForDemo {
    public static void main(String[] args){
         int[] numbers = 
             {1,2,3,4,5,6,7,8,9,10};
         for (int item : numbers) {
             System.out.println("Count is: " + item);
         }
    }
}
````

程序输出：

````
Count is: 1
Count is: 2
Count is: 3
Count is: 4
Count is: 5
Count is: 6
Count is: 7
Count is: 8
Count is: 9
Count is: 10
````

我们推荐你尽可能使用增强型 ````for```` 循环。

#### 分支语句

**````break```` 语句**

````break```` 语句有两种形式：有标签的和无标签的。你在先前的 ````switch```` 语句的例子中已经看到过无标签的形式。你也可以使用无标签的 ````break```` 语句来终止 ````for```` 、````while```` 或者 ````do-while```` 循环，如下面例子所示：

````java
class BreakDemo {
    public static void main(String[] args) {

        int[] arrayOfInts = 
            { 32, 87, 3, 589,
              12, 1076, 2000,
              8, 622, 127 };
        int searchfor = 12;

        int i;
        boolean foundIt = false;

        for (i = 0; i < arrayOfInts.length; i++) {
            if (arrayOfInts[i] == searchfor) {
                foundIt = true;
                break;
            }
        }

        if (foundIt) {
            System.out.println("Found " + searchfor + " at index " + i);
        } else {
            System.out.println(searchfor + " not in the array");
        }
    }
}
````

上面的程序在数组中搜索数字 12 。````break```` 语句在改值被找到时立即终止 ````for```` 循环。控制流程就转移到 ````for```` 循环之后的语句。程序输出：

````
Found 12 at index 4
````

无标签的 ````break```` 语句终止内层  ````for```` 、````while```` 或者 ````do-while```` 循环，而有标签的 ````break```` 语句终止外层  ````for```` 、````while```` 或者 ````do-while```` 循环。下面的程序 [`BreakWithLabelDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BreakWithLabelDemo.java) ，类似于上面的程序，不过使用了内层的 ````for```` 循环在二维数组中搜索目标值。当目标值被找到，有标签的 ````break```` 语句（标签为 “search”）将终止外部的 ````for```` 循环:

````java
class BreakWithLabelDemo {
    public static void main(String[] args) {

        int[][] arrayOfInts = { 
            { 32, 87, 3, 589 },
            { 12, 1076, 2000, 8 },
            { 622, 127, 77, 955 }
        };
        int searchfor = 12;

        int i;
        int j = 0;
        boolean foundIt = false;

    search:
        for (i = 0; i < arrayOfInts.length; i++) {
            for (j = 0; j < arrayOfInts[i].length;
                 j++) {
                if (arrayOfInts[i][j] == searchfor) {
                    foundIt = true;
                    break search;
                }
            }
        }

        if (foundIt) {
            System.out.println("Found " + searchfor + " at " + i + ", " + j);
        } else {
            System.out.println(searchfor + " not in the array");
        }
    }
}
````

程序的输出：

````
Found 12 at 1, 0
````

````break```` 语句终止有标签的语句，它并不是将流程控制转移到标签处的语句，而是转移到标签语句的下一条语句。

**````continue```` 语句**

````continue```` 语句跳过  ````for```` 、````while```` 或者 ````do-while```` 循环的当前迭代器。无标签的形式跳到内层循环体的末尾然后计算循环控制表达式的 ````boolean```` 值。下面的程序 [`ContinueDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ContinueDemo.java) ，遍历一个 ````String```` ，统计其中的字符 "p" 出现的次数。如果当前字符不是 “p”，则 ````continue```` 语句跳过循环的剩余部分并继续处理下一个字符。如果当前字符是“p”，则程序为字符计数加一。

````java
class ContinueDemo {
    public static void main(String[] args) {

        String searchMe = "peter piper picked a " + "peck of pickled peppers";
        int max = searchMe.length();
        int numPs = 0;

        for (int i = 0; i < max; i++) {
            // interested only in p's
            if (searchMe.charAt(i) != 'p')
                continue;

            // process p's
            numPs++;
        }
        System.out.println("Found " + numPs + " p's in the string.");
    }
}
````

程序输出：

````
Found 9 p's in the string.
````

为了更清楚地看出语句的效果，你可以删除其中的 ````continue```` 语句然后重新编译。再次运行程序，将输出错误的结果 35。

有标签的 ````continue```` 语句跳过标签表示的外层循环的当前迭代器。下面的例子 ContinueWithLabelDemo 使用内层循环来搜索包含某个特定字符串的子字符串。需要两个内层循环，一个迭代子字符串，另一个迭代需要搜索的目标字符串。下面的程序，[`ContinueWithLabelDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ContinueWithLabelDemo.java) ，使用有标签的 ````continue```` 形式来跳过外层循环迭代器。

````java
class ContinueWithLabelDemo {
    public static void main(String[] args) {

        String searchMe = "Look for a substring in me";
        String substring = "sub";
        boolean foundIt = false;

        int max = searchMe.length() - 
                  substring.length();

    test:
        for (int i = 0; i <= max; i++) {
            int n = substring.length();
            int j = i;
            int k = 0;
            while (n-- != 0) {
                if (searchMe.charAt(j++) != substring.charAt(k++)) {
                    continue test;
                }
            }
            foundIt = true;
                break test;
        }
        System.out.println(foundIt ? "Found it" : "Didn't find it");
    }
}
````

程序输出：

````
Found it
````

**````return```` 语句**

最后一个分支语句是 ````return```` 语句。该语句退出当前方法，程序控制流返回该方法被调用的位置。该语句有两种形式：有返回值的和无返回值的。为了返回一个值，简单地在 ````return```` 关键字之后放置一个值或者计算该值的表达式即可。

````
return ++count;
````

返回值的类型必须符合该方法声明的返回值类型。当方法声明为 ````void```` ，使用无返回值的 ````return```` 形式。

接下来的 [Classes and Objects](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html) 将覆盖你写方法需要了解的所有知识。

#### 控制流语句总结

````if-then```` 语句是所有控制流语句中最基本的语句。它告诉程序只有在特定测试评估为 ````true```` 时才执行某段代码。 ````if-then-else```` 语句在 “if” 子句求值为 ````false```` 时提供辅助执行路径。与 ````if-then```` 和 ````if-then-else```` 不同，````switch```` 语句允许任意数量的可能执行路径。````while```` 和 ````do-while```` 语句在特定条件为真时不断执行语句块。````do-while```` 和 ````while```` 之间的区别在于 ````do-while```` 在循环的底部而不是顶部计算它的表达式。因此，````do```` 块中的语句总是至少执行一次。````for```` 语句提供了一种迭代一系列值的简洁方法。它有两种形式，其中一种用于循环集合和数组。

## 类和对象

你现在具有了 Java 编程语言的基础知识，可以开始写你自己的类。被章节中，你将学到有关定义你自己的类的信息，包括声明成员变量、方法以及构造器。

你将学到使用你类创建对象，然后使用你创建的对象。

本章节还包括位于其它类内部的内部类，以及枚举类型。

* [类型](https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html)

本章节剖析类型，同时讲述如何声明字段、方法以及构造器。

* [对象](https://docs.oracle.com/javase/tutorial/java/javaOO/objects.html)

本章节覆盖创建和使用对象。你将学到如何实例化一个对象，然后，一旦实例化，如何使用 ````dot```` 操作符访问该对象实例的变量和方法。

* [有关类型的更多话题](https://docs.oracle.com/javase/tutorial/java/javaOO/more.html)

本章节介绍依赖于使用对象引用的类的更多方面以及您在上一节中学习的 ````dot```` 运算符：从方法返回的值，````this```` 关键字，类成员变量与实例变量以及访问控制。

* [内部类](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)

静态内部类，内部类，匿名内部类，局部类，lambda 表达式。同时讨论何时使用何种方式。

* [枚举类型](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)

本章节覆盖枚举类型，这是一种特殊类型，允许你定义并使用一系列的常量。

### 类

[面向对象编程概念](https://docs.oracle.com/javase/tutorial/java/concepts/index.html) 章节中使用了自行车类型作为例子，具有赛车、山地车以及串联自行车等子类型。下面是一个可能的 ````Bicycle```` 类型的实现，向你展示一个完整的类型声明。本章节后续内容将逐步介绍其中的所有内容，现在不需要纠结细节。

````java
public class Bicycle {
        
    // the Bicycle class has
    // three fields
    public int cadence;
    public int gear;
    public int speed;
        
    // the Bicycle class has
    // one constructor
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    // the Bicycle class has
    // four methods
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}
````

其子类 ````MountainBike```` 类型可能如下：

````java
public class MountainBike extends Bicycle {
        
    // the MountainBike subclass has
    // one field
    public int seatHeight;

    // the MountainBike subclass has
    // one constructor
    public MountainBike(int startHeight, int startCadence,
                        int startSpeed, int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // the MountainBike subclass has
    // one method
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   

}
````

````MountainBike```` 继承了 ````Bicycle```` 的所有字段和方法，同时添加了 ````seatHeight```` 字段和该字段的 ````set```` 方法。

#### 类声明

你已经看到可以如下形式声明类型：

````java
class MyClass {
    // field, constructor, and 
    // method declarations
}
````

这是一个*类声明*。 类主体（大括号之间的区域）包含为从该类创建的对象的生命周期提供的所有代码：用于初始化新对象的构造函数，用于提供类及其对象的状态的字段的声明，以及 实现类及其对象行为的方法。

前面的类声明是最小的。 它仅包含所需的类声明的那些必需组件。您可以在类声明的开头提供有关该类的更多信息，例如其超类的名称，是否实现任何接口等。例如：

````java
class MyClass extends MySuperClass implements YourInterface {
    // field, constructor, and
    // method declarations
}
````

意味着 ````MyClass```` 是 ````MySuperClass```` 类的子类，同时它实现了 ````YourInterface```` 接口。

您也可以在一开始就添加 ````public```` 或 ````private```` 等修饰符 - 这样您就可以看到类声明的开头行可能变得非常复杂。````public```` 和 ````private```` 修饰符决定了哪些类可以访问 ````MyClass```` 的内容，本课程稍后将对此进行讨论。关于接口和继承的课程将解释如何以及为什么在类声明中使用 ````extends```` 和 `````implements````` 关键字。目前你不需要担心这些额外的并发症。

通常，类声明可以按顺序包含这些组件：

1. 修改器，例如 ````public````，````private```` 以及稍后您将遇到的许多其他修饰符。
2. 类名，首字母大写。
3. 类的父级（超类）的名称（如果有）以关键字 ````extends```` 开头。一个类只能扩展（子类）一个父类。
4. 由类实现的以逗号分隔的接口列表（如果有），前面是关键字 ````implements````。一个类可以实现多个接口。
5. 类主体，被大括号 ````{}```` 围绕。

#### 声明成员变量

有几种变量：

* 类的成员变量—它们被称为*字段*。
* 方法或者代码块中的变量—它们被称为*局部变量*。
* 方法声明中的变量—它们被称为*参数*。

````Bicycle```` 类使用下面的代码来定义它的字段：

````java
public int cadence;
public int gear;
public int speed;
````

字段声明由三部分组成，依次是：

1. 0 个或者更多访问修饰符，比如 ````public```` 或者 ````private````。
2. 字段类型。
3. 字段名称。

````Bicycle```` 类的字段命名为 ````cadence```` 、````gear```` 和 ````speed```` ，都是整型类型 ````int```` 。````public```` 访问修饰符表示这些字段是公开成员，所有可以访问该类型的对象都可以访问这些字段。

**访问修饰符**

变量声明语句开头的访问修饰符使得你可以控制哪些类可以访问该成员字段。目前，只考虑 ````public```` 和 ````private```` 两个，其它的访问修饰符后面会讨论。

* ````public```` — 该字段可以从所有其它类访问。
* ````private```` — 该字段只能被它所在的类内部访问。

本着封装精神，通常会将字段限制为 ````private```` 的。这意味着它们只能直接从 ````Bicycle```` 类访问。不过我们仍然需要访问这些值。那么就可以通过间接的方式来实现，添加 ````public ```` 方法来获取这些字段值：

````java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear() {
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}
````

**数据类型**

所有的变量必需都有数据类型。你可以使用基本数据类型，比如 ````int```` ，````float````，````boolean```` 等等。或者你可以使用引用类型，比如字符串，数组或者对象。

**变量名称**

所有变量，不论是字段，局部变量还是参数，遵守相同的命名规则，命名传统在 [变量命名](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming) 中介绍。

本章节中，注意方法和类命名遵循相同的规则和传统，除了：

* 类名的首字母应该大写，同时
* 方法名的首个词（或唯一词）应该是动词

#### 方法定义

下面是一个典型的方法声明：

```java
public double calculateAnswer(double wingSpan, int numberOfEngines,
                              double length, double grossTons) {
    //do the calculation here
}

```

方法声明只强制需要以下这些内容，方法返回值类型，名称，一对括号 `()`，以及位于大括号 `{}` 内部的方法体。

更一般地，方法声明包含六种元素，依次为：

1. 访问修饰符—比如 `public`， `private`， 其它几种你随后将会学习到。
2. 返回值类型—方法返回的值的数据类型，或者 `void` 如果方法不返回任何值。
3. 方法名—命名规则和传统与变量命名类似，虽然稍微有些不同。
4. 括号中的参数列表—逗号分隔的输入参数列表，由它们的数据类型开头，被括号 `()` 包围。如果方法不需要参数，你仍然必须使用空括号。
5. 异常列表—稍后讨论。
6. 大括号包围的方法体—方法的逻辑代码，包括局部变量声明等。

访问修饰符、返回值类型和参数将在本章节稍后讨论。异常在下一章节讨论。

------

**定义：**方法声明的两个元素构成了*方法签名*—方法的名称和参数类型。

------

上面方法的方法签名是：

```
calculateAnswer(double, int, double, double)
```

**命名一个方法**

虽然方法名称可以是任何合法标识符，但代码约定限制方法名称。按照惯例，方法名称应该是小写的动词或以小写的动词开头的多词名称，后跟形容词，名词等。在多词名称中，每个第二个和后一个词的第一个字母 应该大写。 这里有些例子：

````java
run
runFast
getBackground
getFinalData
compareTo
setX
isEmpty
````

通常，方法在其类中具有唯一名称。但是，由于方法重载，方法可能与其他方法具有相同的名称。

**方法重载**

Java编程语言支持重载方法，Java可以区分具有不同方法签名的方法。这意味着如果类中的方法具有不同的参数列表，则它们可以具有相同的名称（有一些规范，将在标题为“接口和继承”的课程中讨论）。

假设您有一个类可以使用书法来绘制各种类型的数据（字符串，整数等），并且包含绘制每种数据类型的方法。为每个方法使用新名称很麻烦 - 例如，````drawString````，````drawInteger````，````drawFloat```` 等。在 Java 编程语言中，您可以对所有绘图方法使用相同的名称，但将不同的参数列表传递给每个方法。因此，数据绘制类可能会声明四个名为````draw```` 的方法，每个方法都有一个不同的参数列表。

```java
public class DataArtist {
    ...
    public void draw(String s) {
        ...
    }
    public void draw(int i) {
        ...
    }
    public void draw(double f) {
        ...
    }
    public void draw(int i, double f) {
        ...
    }
}

```

重载方法由传递给方法的参数的数量和类型区分。在代码示例中，````draw(String s)```` 和 ````draw(int i)```` 是不同且唯一的方法，因为它们需要不同的参数类型。

您不能声明多个具有相同名称和相同数量和类型的参数的方法，因为编译器无法区分它们。

在区分方法时，编译器不考虑返回类型，因此即使它们具有不同的返回类型，也不能使用相同的签名声明两个方法。

------

**注意：**应谨慎使用重载方法，因为它们会使代码的可读性降低。

------

#### 为你的类提供构造器

一个累包含构造器，该构造器被调用来从该类蓝图创建对象。构造器声明类似于方法声明—除了它们使用类的名称同时没有返回值类型。比如，````Bicycle```` 拥有一个构造器：

```java
public Bicycle(int startCadence, int startSpeed, int startGear) {
    gear = startGear;
    cadence = startCadence;
    speed = startSpeed;
}
```

为了创建一个新的 `Bicycle` 对象，名为 `myBike` ，构造器被 `new` 操作符调用：

```java
Bicycle myBike = new Bicycle(30, 0, 8);
```

`new Bicycle(30, 0, 8)` 为新的对象分配内存空间并初始化它的字段。

尽管 `Bicycle` 只有一个构造器，实际上它还可以拥有其他构造器，包括一个无参数构造器：

```java
public Bicycle() {
    gear = 1;
    cadence = 10;
    speed = 0;
}
```

`Bicycle yourBike = new Bicycle();` 调用该无参数构造器创建一个新的 `Bicycle` 对象名为 `yourBike`。

两个构造函数都可以在`Bicycle`中声明，因为它们具有不同的参数列表。与方法一样，Java 平台根据列表中的参数数量及其类型来区分构造函数。您不能为同一个类编写两个具有相同数量和类型的参数的构造函数，因为平台无法区分它们。这样做会导致编译时错误。

您不必为您的类提供任何构造函数，但在执行此操作时必须小心。编译器自动为没有构造函数的任何类提供无参数的默认构造函数。此默认构造函数将调用超类的无参数构造函数。在这种情况下，如果超类没有无参数构造函数，编译器将会抱怨，因此您必须验证它是否存在。如果你的类没有显式的超类，那么它有一个隐含的超类 ````Object````，*肯定*具有无参数的构造函数。

您可以自己使用超类构造函数。本章节开头的 ````MountainBike```` 类就是这样做的。稍后将在接口和继承章节中对此进行讨论。

您可以在构造函数的声明中使用访问修饰符来控制哪些其他类可以调用构造函数。

------
**注意：**如果别的类不能调用 ````MyClass```` 构造器，它就不能直接创建 ````MyClass```` 对象。

------

#### 向方法或者构造器传递信息

方法或构造函数的声明声明了该方法或构造函数的参数的数量和类型。例如，以下是根据贷款金额，利率，贷款期限（期数）和贷款的未来价值计算住房贷款的每月付款的方法：

```java
public double computePayment(
                  double loanAmt,
                  double rate,
                  double futureValue,
                  int numPeriods) {
    double interest = rate / 100.0;
    double partial1 = Math.pow((1 + interest), 
                    - numPeriods);
    double denominator = (1 - partial1) / interest;
    double answer = (-loanAmt / denominator)
                    - ((futureValue * partial1) / denominator);
    return answer;
}
```

该方法有四个参数：贷款金额，利率，未来价值和期数。前三个是双精度浮点数，第四个是整数。参数在方法体中使用，并且在运行时将采用传入的参数的值。

------

**注意：**参数是指方法声明中的变量列表。 参数是调用方法时传递的实际值。 调用方法时，使用的参数必须与类型和顺序中的声明参数匹配。

------

**参数类型**

您可以将任何数据类型用于方法或构造函数的参数。这包括原始数据类型，如双精度，浮点数和整数，如在`computePayment`方法中看到的，以及引用数据类型，如对象和数组。

这是一个接受数组作为参数的方法示例。在这个例子中，该方法创建一个新的 `Polygon` 对象并从`Point`对象数组初始化它（假设`Point`是一个表示x，y坐标的类）：

```java
public Polygon polygonFrom(Point[] corners) {
    // method body goes here
}
```

------

**注意:** 如果你希望将一个方法传递给另一个方法，使用 [lambda expression](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 或者 [method reference](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html) 。

------

**任意数量的参数**

您可以使用名为 *varargs* 的构造将任意数量的值传递给方法。当您不知道将多少特定类型的参数传递给该方法时，您可以使用 *varargs*。这是手动创建数组的快捷方式（前一种方法可能使用了 *varargs* 而不是数组）。

要使用 varargs，请使用省略号（三个点，...），一个空格和参数名称，放在最后一个参数的类型之后。然后可以使用任何数量的参数调用该方法，包括none。

```java
public Polygon polygonFrom(Point... corners) {
    int numberOfSides = corners.length;
    double squareOfSide1, lengthOfSide1;
    squareOfSide1 = (corners[1].x - corners[0].x)
                     * (corners[1].x - corners[0].x) 
                     + (corners[1].y - corners[0].y)
                     * (corners[1].y - corners[0].y);
    lengthOfSide1 = Math.sqrt(squareOfSide1);

    // more method body code follows that creates and returns a 
    // polygon connecting the Points
}
```

你可以看到，在方法中，`corner`被视为一个数组。可以使用数组或参数序列调用该方法。在任何一种情况下，方法体中的代码都会将参数视为数组。

您最常见的是打印方法使用的 varargs 。例如，这个`printf`方法：

```java
public PrintStream printf(String format, Object... args)
```

允许你将任意数量的对象打印出来。它可以被如下调用：

```java
System.out.printf("%s: %d, %s%n", name, idnum, address);
```

或者：

```java
System.out.printf("%s: %d, %s, %s, %s%n", name, idnum, address, phone, email);
```

或者使用不同数量的参数。

**参数名称**

向方法或构造函数声明参数时，可以为该参数提供名称。此名称在方法体内用于引用传入的参数。

参数名称在它的作用域中必须是唯一的。它不能与同一方法或构造函数的另一个参数的名称相同，也不能是方法或构造函数中的局部变量的名称。

参数可以与类的某个字段具有相同的名称。如果是这种情况，则该参数称为 *shadow* 字段。 阴影字段可能使您的代码难以阅读，并且通常仅在设置特定字段的构造函数和方法中使用。例如，考虑以下`Circle`类及其`setOrigin`方法：

```java
public class Circle {
    private int x, y, radius;
    public void setOrigin(int x, int y) {
        ...
    }
}
```

````Circle```` 类有三个字段：````x````，````y```` 和 ````radius````。 ````setOrigin```` 方法有两个参数，每个参数与其中一个字段具有相同的名称。每个方法参数都会遮蔽共享其名称的字段。因此，在方法体内使用简单名称 ````x```` 或 ````y```` 指的是参数，而不是字段。要访问该字段，您必须使用限定名称。这将在本课程后面的标题为“使用 ````this```` 关键字”一节中讨论。

**传递基本类型参数**

原始参数，例如`int`或`double`，通过*值*传递给方法。 这意味着对参数值的任何更改都仅存在于方法的范围内。方法返回时，参数消失，对它们的任何更改都将丢失。这是一个例子：

```java
public class PassPrimitiveByValue {

    public static void main(String[] args) {
           
        int x = 3;
           
        // invoke passMethod() with 
        // x as argument
        passMethod(x);
           
        // print x to see if its 
        // value has changed
        System.out.println("After invoking passMethod, x = " + x);
           
    }
        
    // change parameter in passMethod()
    public static void passMethod(int p) {
        p = 10;
    }
}
```

程序输出：

```
After invoking passMethod, x = 3
```

**传递引用类型参数**

引用数据类型参数（如对象）也通过*值*传递给方法。这意味着当方法返回时，传入的引用仍然引用与以前相同的对象。*但是*，如果对象的字段的值具有适当的访问级别，则可以在方法中更改它们的值。

例如，考虑一个移动`Circle`对象的任意类中的方法：

```java
public void moveCircle(Circle circle, int deltaX, int deltaY) {
    // code to move origin of circle to x+deltaX, y+deltaY
    circle.setX(circle.getX() + deltaX);
    circle.setY(circle.getY() + deltaY);
        
    // code to assign a new reference to circle
    circle = new Circle(0, 0);
}
```

如下调用该方法：

```
moveCircle(myCircle, 23, 56)
```

在方法内部，````circle````最初是指 ````myCircle````。 该方法将 ````circle````引用的对象的 x 和 y 坐标（即 ````myCircle````）分别改变为23和56。方法返回时，这些更改将保持不变。然后 ````circle```` 被赋予对 ````x = y = 0```` 的新`Circle`对象的引用。但是，这种重新分配没有永久性，因为引用是按值传递的，不能更改。在方法中，````circle```` 指向的对象已经改变，但是，当方法返回时，`myCircle`仍然引用与调用方法之前相同的`Circle`对象。

### 对象

典型的 Java 程序会创建许多对象，如您所知，通过调用方法进行交互。通过这些对象交互，程序可以执行各种任务，例如实现 GUI，运行动画，或通过网络发送和接收信息。一旦对象完成了它的工作，它的资源就会被回收以供其他对象使用。

下面是个示例小程序，名为 [`CreateObjectDemo`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/CreateObjectDemo.java) ，创建三个对象：一个[`Point`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Point.java) 对象和两个 [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java) 对象。你需要这三个类的源文件来编译此程序。

```java
public class CreateObjectDemo {

    public static void main(String[] args) {
		
        // Declare and create a point object and two rectangle objects.
        Point originOne = new Point(23, 94);
        Rectangle rectOne = new Rectangle(originOne, 100, 200);
        Rectangle rectTwo = new Rectangle(50, 100);
		
        // display rectOne's width, height, and area
        System.out.println("Width of rectOne: " + rectOne.width);
        System.out.println("Height of rectOne: " + rectOne.height);
        System.out.println("Area of rectOne: " + rectOne.getArea());
		
        // set rectTwo's position
        rectTwo.origin = originOne;
		
        // display rectTwo's position
        System.out.println("X Position of rectTwo: " + rectTwo.origin.x);
        System.out.println("Y Position of rectTwo: " + rectTwo.origin.y);
		
        // move rectTwo and display its new position
        rectTwo.move(40, 72);
        System.out.println("X Position of rectTwo: " + rectTwo.origin.x);
        System.out.println("Y Position of rectTwo: " + rectTwo.origin.y);
    }
}

```

程序输出：

```
Width of rectOne: 100
Height of rectOne: 200
Area of rectOne: 20000
X Position of rectTwo: 23
Y Position of rectTwo: 94
X Position of rectTwo: 40
Y Position of rectTwo: 72

```

以下三节使用上面的示例来描述程序中对象的生命周期。通过它们，您将学习如何编写在您自己的程序中创建和使用对象的代码。您还将了解系统在对象生命周期结束后如何清理它们。

#### 创建对象

如你所见，类为对象提供了一张蓝图，你可以从类创建对象，下面的语句来自程序 [`CreateObjectDemo`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/CreateObjectDemo.java) 创建一个对象然后将它分配给一个变量：

```java
Point originOne = new Point(23, 94);
Rectangle rectOne = new Rectangle(originOne, 100, 200);
Rectangle rectTwo = new Rectangle(50, 100);

```

第一行创建一个 [`Point`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Point.java) 类对象，第二句和第三句分别创建一个 [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java) 类对象。

这些语句都包含三个部分（其中细节随后讨论）：

1. **申明**：变量名和对象类型组成变量声明。
2. **实例化**：`new` 关键字是 Java 语言的对象创建操作符。
3. **初始化**：`new` 操作符后面跟随对构造器的调用，用来初始化新创建的对象。

**创建变量来引用对象**

前面你已经学到如何声明变量：

```java
type name;
```

这行代码通知编译器你将要使用 *name* 来引用类型为 *type* 的数据。对基本类型的变量，这个声明语句同时也会为该变量分配合适的内存空间。

你也可以在单独一行代码中声明一个引用变量。比如：

```java
Point originOne;
```

如果你这样声明`originOne` ，在一个对象实际被创建并分配给该变量之前，该变量的值都是未定的。简单地声明一个引用类型变量并不会创建对象。因此，你需要使用 `new` 操作符，如下一节中所述。在使用该变量之前你必须分配一个对象给 `originOne` 。否则，你将得到一个编译错误。

此状态中的变量（当前不引用任何对象）可以如下所示（变量名称，````originOne````，以及未指向任何内容的引用）：

![originOne is null.](https://docs.oracle.com/javase/tutorial/figures/java/objects-null.gif)

**实例化一个类**

`new` 操作符通过为一个新的对象分配内存空间并返回该内存空间的引用的方式来实例化一个类。````new```` 操作符还调用该对象的构造器。

------

**注意：**阶段 “实例化一个类” 的含义与 “创建一个对象” 是相同的。当你创建一个对象，也就是创建该类的一个实例，因而也就是 “实例化” 一个类。

------

`new` 操作符需要一个单独的后缀参数：一个对构造器的调用。该构造器的名称提供了要实例化的类的名称。

`new` 操作符返回新创建的对象的引用。该引用通常被分配给一个相应数据类型的变量。如下所示：

```java
Point originOne = new Point(23, 94);
```

`new` 操作符返回的新对象的引用并不是必须分配给一个变量，也可以直接在表达式中使用。比如：

```java
int height = new Rectangle().height;
```

这个语句将在下一节中讨论。

**初始化一个对象**

`Point` 类代码：

```java
public class Point {
    public int x = 0;
    public int y = 0;
    //constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }
}
```

这个类包含一个构造器，你可以认出这个构造器，因为它的声明使用了类名称并且没有返回值类型。该构造器有两个整型参数，声明为 `(int a, int b)`。接下来的语句为这些参数提供了具体的值：

```java
Point originOne = new Point(23, 94);
```

这条语句的执行结果如下图所示：

![originOne now points to a Point object.](https://docs.oracle.com/javase/tutorial/figures/java/objects-oneRef.gif)

`Rectangle` 类代码，包含四个构造器：

````java
public class Rectangle {
    public int width = 0;
    public int height = 0;
    public Point origin;

    // four constructors
    public Rectangle() {
        origin = new Point(0, 0);
    }
    public Rectangle(Point p) {
        origin = p;
    }
    public Rectangle(int w, int h) {
        origin = new Point(0, 0);
        width = w;
        height = h;
    }
    public Rectangle(Point p, int w, int h) {
        origin = p;
        width = w;
        height = h;
    }

    // a method for moving the rectangle
    public void move(int x, int y) {
        origin.x = x;
        origin.y = y;
    }

    // a method for computing the area of the rectangle
    public int getArea() {
        return width * height;
    }
}
````

每个构造函数都允许您使用基本类型和引用类型为矩形的原点，宽度和高度提供初始值。如果一个类有多个构造函数，则它们必须具有不同的签名。Java 编译器根据参数的数量和类型区分构造函数。当 Java 编译器遇到以下代码时，它知道在 ````Rectangle```` 类中调用构造函数，该类需要一个 ````Point```` 参数，后跟两个整数参数：

```java
Rectangle rectOne = new Rectangle(originOne, 100, 200);
```

这会调用 ````Rectangle```` 的一个构造函数，它将 ````origin```` 初始化为 ````originOne````。此外，构造函数将 ````width```` 设置为100，将 ````height```` 设置为200。现在有两个对同一 ````Point```` 对象的引用 - 一个对象可以有多个引用，如下图所示：

![Now the rectangle's origin variable also points to the Point.](https://docs.oracle.com/javase/tutorial/figures/java/objects-multipleRefs.gif)

以下代码行调用 ````Rectangle```` 构造函数，该构造函数需要两个整数参数，这些参数提供 ````width```` 和 ````height```` 的初始值。如果检查构造函数中的代码，您将看到它创建了一个新的 ````Point```` 对象，其 ````x```` 和 ````y```` 值初始化为0：

```java
Rectangle rectTwo = new Rectangle(50, 100);
```

下面代码中使用的构造器没有使用任何参数，因此它被称为*无参构造器*：

```java
Rectangle rect = new Rectangle();
```

所有类至少有一个构造函数。如果类没有显式声明任何类，那么 Java 编译器会自动提供一个无参构造函数，称为*默认构造函数* 。此默认构造函数调用父类的无参数构造函数，如果类没有其他父级，则调用 ````Object```` 构造函数。如果父级没有构造函数（````Object```` 确实有构造函数），编译器将拒绝该程序。

#### 使用对象

一旦你创建了一个对象，你可能想要用它来做些事情。您可能需要使用其中一个字段的值，更改其中一个字段，或调用其中一个方法来执行操作。

**引用一个对象的字段**

对象字段通过它们的名称访问。你必须使用无歧义的字段名称。

你可以在字段所在的类内部使用简单的字段名称。比如，我们可以在 ````Rectangle```` 类中添加语句来打印 ````width```` 和 ````height```` ：

```java
System.out.println("Width and height are: " + width + ", " + height);
```

这种情况下， `width` 和 `height` 就是简单名称。

对象类之外的代码必须使用一个对象引用或者表达式，后面跟随点操作符 ````.```` ，后跟简单字段名。如下所示：

```java
objectReference.fieldName
```

例如，`CreateObjectDemo` 类中的代码位于 `Rectangle` 类的代码之外。因此，要引用名为 `rectOne` 的 `Rectangle` 对象中的 `origin`，`width` 和 `height` 字段，`CreateObjectDemo` 类必须分别使用名称`rectOne.origin`，`rectOne.width` 和 `rectOne.height`。该程序使用其中两个名称来显示`rectOne` 的 `width` 和 `height`：

```java
System.out.println("Width of rectOne: "  + rectOne.width);
System.out.println("Height of rectOne: " + rectOne.height);
```

尝试在 `CreateObjectDemo` 类中的代码中使用的简单名称 `width`和 `height` 没有意义 - 这些字段仅存在于对象中 - 并导致编译器错误。

稍后，该程序使用类似的代码来显示有关 `rectTwo` 的信息。相同类型的对象具有自己的相同实例字段的副本。因此，每个 `Rectangle` 对象都有名为 `origin`，`width` 和 `height` 的字段。通过对象引用访问实例字段时，将引用该特定对象的字段。`CreateObjectDemo` 程序中的两个对象 `rectOne` 和 `rectTwo` 具有不同的 `origin`，`width` 和 `height` 字段。

要访问字段，可以使用对象的命名引用（如前面的示例所示），也可以使用任何返回对象引用的表达式。回想一下 `newoperator` 返回对象的引用。因此，您可以使用 `new` 返回的值来访问新对象的字段：

```java
int height = new Rectangle().height;
```

该语句创建一个新的 `Rectangle` 对象并立即获得其高度。实质上，该语句计算 `Rectangle` 的默认高度。请注意，在执行此语句之后，程序不再具有对创建的 `Rectangle` 的引用，因为程序从未将引用存储在任何位置。该对象未被引用，其资源可由 Java 虚拟机自由回收。

**调用对象方法**

您还可以使用对象引用来调用对象的方法。将方法的简单名称附加到对象引用，并使用插入点运算符 `.`。此外，您在括号内提供该方法的任何参数。如果方法不需要任何参数，请使用空括号。

```java
objectReference.methodName(argumentList);
```

或者：

```java
objectReference.methodName();
```

`Rectangle` 类包含两个方法： `getArea()` 来计算长方形的面积， `move()` 用来改变长方形的位置。下面的代码展示了如何调用这两个方法：

```java
System.out.println("Area of rectOne: " + rectOne.getArea());
...
rectTwo.move(40, 72);
```

第一个语句调用 `rectOne` 的 `getArea()` 方法并显示结果。第二行移动 `rectTwo`，因为 `move()` 方法为对象的 `origin.x` 和 `origin.y` 分配新值。

与实例字段一样，`objectReference` 必须是对象的引用。您可以使用变量名称，但也可以使用任何返回对象引用的表达式。`new` 运算符返回一个对象引用，因此您可以使用 `new` 返回的值来调用新对象的方法：

```java
new Rectangle(100, 50).getArea()
```

表达式 `new Rectangle(100,50)` 返回引用 `Rectangle` 对象的对象引用。如图所示，您可以使用点表示法来调用新的 `Rectangle` 的 `getArea()` 方法来计算新矩形的面积。

某些方法（如 `getArea()`）返回一个值。对于返回值的方法，可以在表达式中使用方法调用。您可以将返回值分配给变量，使用它来做出决策或控制循环。此代码将 `getArea()` 返回的值赋给变量 `areaOfRectangle`：

```java
int areaOfRectangle = new Rectangle(100, 50).getArea();
```

请记住，在特定对象上调用方法与向该对象发送消息相同。在这种情况下，调用 `getArea()` 的对象就是构造函数返回的矩形。

**垃圾收集器**

某些面向对象的语言要求您跟踪所创建的所有对象，并在不再需要时明确销毁它们。明确地管理内存是单调乏味且容易出错的。Java平台允许您根据需要创建任意数量的对象（当然，受限于系统可以处理的对象），您不必担心会破坏它们。Java运行时环境在确定不再使用对象时删除对象。此过程称为垃圾回收。

当没有对该对象的引用时，对象有资格进行垃圾回收。当变量退出作用域时，通常会删除变量中保存的引用。或者，您可以通过将变量设置为特殊值 `null` 来显式删除对象引用。请记住，程序可以对同一个对象进行多次引用；在对象符合垃圾回收条件之前，必须删除对对象的所有引用。

Java 运行时环境具有垃圾收集器，可以定期释放不再引用的对象使用的内存。垃圾收集器在它认为合适的时机正确时自动完成其工作。

### 关于类的更多话题

本节介绍依赖于使用对象引用的类的更多方面以及您在前面的对象部分中了解到的 `.`运算符：

* 从方法返回值。
* `this`关键字。
* 类与实例成员。
* 访问控制。

#### 从方法返回值

一个方法返回调用它的代码的时机：

- 方法中所有的语句都执行完成，
- 执行到一个 `return` 语句，或者，
- 抛出一个异常 (稍后讨论)。

无论哪个首先发生都无所谓。

你在方法声明中声明方法的返回值类型。在方法体中，你使用 `return` 语句来返回值。

声明 `void` 的方法不返回任何值。它不需要包含 `return` 语句，不过它也可以包含。这种情况下，其中的 `return` 语句的作用是跳出控制流块同时退出该方法。可以简单地写成下面的形式：

```java
return;
```

如果你尝试从声明为 `void` 的方法中返回一个值，你将得到一个编译错误。

任何没有声明为 `void` 的方法都必须包含 `return` 语句并返回相应类型的返回值，如下：

```java
return returnValue;
```

返回的值的数据类型必须符合方法声明的返回值类型，你不能在声明返回布尔值的方法中返回整形数据。

 [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java) 类中的 `getArea()` 方法返回一个整型数：

```java
// a method for computing the area of the rectangle
public int getArea() {
  return width * height;
}
```

这个方法返回表达式 `width*height` 的计算结果。

`getArea` 方法返回一个基本数据类型。方法也可以返回引用类型。比如，在一个维护 `Bicycle` 对象的程序中，我们可以有下面的方法：

```java
public Bicycle seeWhosFastest(Bicycle myBike, Bicycle yourBike, Environment env) {
    Bicycle fastest;
    // code to calculate which bike is 
    // faster, given each bike's gear 
    // and cadence and given the 
    // environment (terrain and wind)
    return fastest;
}
```

**返回一个类或者接口**

如果此部分让您感到困惑，请跳过它并在完成接口和继承课程后返回该部分。

当方法使用类名作为其返回类型（例如 `whosFastest`）时，返回对象的类型类必须是返回类型的子类或该类本身。假设您有一个类层次结构，其中 `ImaginaryNumber` 是 `java.lang.Number` 的子类，而 `java.lang.Number` 又是 `Object` 的子类，如下图所示。

![The class hierarchy for ImaginaryNumber](https://docs.oracle.com/javase/tutorial/figures/java/classes-hierarchy.gif)

`ImaginaryNumber` 的类继承层级结构。

现在假定你有一个方法声明返回一个 `Number` ：

```java
public Number returnANumber() {
    ...
}
```

`returnANumber` 方法可以返回 `ImaginaryNumber` 但是不能返回 `Object` 。 `ImaginaryNumber` 是一个 `Number` 因为它是 `Number` 的子类。但是，`Object` 不一定是 `Number`   - 它可以是 `String` 或其他类型。

您可以覆盖方法并定义它以返回原始方法的返回类型的子类，如下所示：

```java
public ImaginaryNumber returnANumber() {
    ...
}
```

这种称为*协变返回类型* 的技术意味着允许返回类型在与子类相同的方向上变化。

------

**注意:** 你也可以使用接口名称作为返回类型。这种情况下，返回的对象必须实现该接口。

------

#### 使用 `this` 关键字

在实例方法或者构造器内部，`this` 是*当前对象*的引用—该对象的方法或者构造器正在被调用。你可以使用 `this` 关键字在实例方法或者构造器中引用当前对象的任何成员。

**和字段共同使用 `this`**

最常见的使用 `this` 关键字的原因是字段被方法或者构造器参数遮蔽。

b比如，`Point` 类写成如下形式：

```java
public class Point {
    public int x = 0;
    public int y = 0;
        
    //constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }
}

```

也可能写成这样：

```java
public class Point {
    public int x = 0;
    public int y = 0;
        
    //constructor
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

```

构造函数的每个参数都会遮蔽对象的一个字段 - 构造函数内部的 `x` 是构造函数的第一个参数的本地副本。要引用`Point` 的字段 `x`，构造函数必须使用 `this.x` 。

**和构造器共同使用 `this`**

在构造器内部，你也可以使用 `this` 关键字调用该类的其它构造器。这种调用叫做*显式构造器调用*。下面是另一种形式的 `Rectangle` 类：

```java
public class Rectangle {
    private int x, y;
    private int width, height;
        
    public Rectangle() {
        this(0, 0, 1, 1);
    }
    public Rectangle(int width, int height) {
        this(0, 0, width, height);
    }
    public Rectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    ...
}
```

该类包含一组构造函数。每个构造函数都初始化一些或所有矩形的成员变量。构造函数为任何成员变量提供默认值，其初始值不是由参数提供的。例如，无参数构造函数在坐标 `0,0` 处创建 `1x1` 矩形。双参数构造函数调用四参数构造函数，传递宽度和高度，但始终使用 `0,0` 坐标。和以前一样，编译器根据参数的数量和类型确定要调用的构造函数。

如果存在，则另一个构造函数的调用必须是构造函数中的第一行。

#### 类成员的访问控制

访问级别修饰符决定其它类是否可以使用类的特定字段或者调用类的特定方法。下面是两种访问控制级别：

- 处于顶级水平 — `public` ，或者 *package-private* （隐式访问控制修饰符）。
- 处于成员的水平 — `public` ，`private` ， `protected` ，或者 *package-private* （隐式访问控制修饰符）。

可以使用修饰符 `public` 声明一个类，在这种情况下，该类对于所有类都可见。如果一个类没有修饰符（默认，也称为*包私有*），它只在自己的包中可见（包是相关类的命名组 - 您将在后面的课程中了解它们。）

在成员级别，您也可以使用 `public` 修饰符或隐式修饰符（*package-private*），就像使用顶级类一样，并且具有相同的含义。对于成员，还有两个额外的访问修饰符：`private` 和 `protected`。 `private` 修饰符指定只能在自己的类中访问该成员。`protected` 修饰符指定只能在其自己的包中访问该成员（与 *package-private* 一样），此外，还可以在另一个包中通过其类的子类访问该成员。

下表显示了每个修饰符允许的成员访问权限。

| Modifier    | Class | Package | Subclass | World |
| ----------- | ----- | ------- | -------- | ----- |
| `public`    | Y     | Y       | Y        | Y     |
| `protected` | Y     | Y       | Y        | N     |
| no modifier | Y     | Y       | N        | N     |
| `private`   | Y     | N       | N        | N     |

第一个数据列指示类本身是否可以访问由访问级别定义的成员。如您所见，类始终可以访问自己的成员。第二列指示与该类相同的包中的类（无论其父级是否有）可以访问该成员。第三列指示在此包外声明的类的子类是否可以访问该成员。第四列指示是否所有类都可以访问该成员。

访问级别以两种方式影响您。首先，当您使用来自其他源的类（例如 Java 平台中的类）时，访问级别将确定您自己的类可以使用的这些类的哪些成员。其次，当您编写一个类时，您需要确定每个成员变量和类中的每个方法应具有的访问级别。

让我们看一下类的集合，看看访问级别如何影响可见性。下图显示了此示例中的四个类以及它们之间的关系。

![Classes and Packages of the Example Used to Illustrate Access Levels](https://docs.oracle.com/javase/tutorial/figures/java/classes-access.gif)

用于说明访问级别的示例的类和包。

下表显示了Alpha类的成员对于可应用于它们的每个访问修饰符的可见性。

| Modifier    | Alpha | Beta | Alphasub | Gamma |
| ----------- | ----- | ---- | -------- | ----- |
| `public`    | Y     | Y    | Y        | Y     |
| `protected` | Y     | Y    | Y        | N     |
| no modifier | Y     | Y    | N        | N     |
| `private`   | Y     | N    | N        | N     |

------

选择访问级别的建议：

如果其他程序员使用您的类，您希望确保不会发生滥用错误。访问级别控制可以帮助您实现。

 - 使用对特定成员有意义的最严格的访问级别。使用 `private` ，除非你有充分的理由不使用它。
 - 避免除常量之外的 `public` 字段。（本教程中的许多示例都使用 `public` 字段。这可能有助于简明地说明某些要点，但不建议用于生产代码。）公共字段倾向于将您绑定到特定实现，并限制您更改代码的灵活性。

------

#### 理解类成员

本节中，我们讨论使用 `static` 关键字来创建属于类的字段和方法，而不属于该类的实例。

**类变量**

当从同一个类蓝图创建许多对象时，它们每个都有自己不同的实例变量副本。在`Bicycle`类的情况下，实例变量是 `cadence`，`gear` 和 `speed`。每个 `Bicycle` 对象都有自己的值，这些变量存储在不同的内存位置。

有时，您希望拥有所有对象共有的变量。这是通过 `static` 修饰符完成的。在声明中具有 `static` 修饰符的字段称为静态字段或类变量。它们与类相关联，而不是与任何对象相关联。该类的每个实例共享一个类变量，该变量位于内存中的一个固定位置。任何对象都可以更改类变量的值，但也可以在不创建类实例的情况下操作类变量。

例如，假设您要创建多个 `Bicycle` 对象并为每个对象分配序列号，从第一个对象开始为1。此 ID 号对每个对象都是唯一的，因此是一个实例变量。同时，您需要一个字段来跟踪已创建的 `Bicycle` 对象的数量，以便您知道要分配给下一个对象的 ID。这样的字段与任何单个对象无关，而与整个类相关。为此，您需要一个类变量 `numberOfBicycles`，如下所示：

````java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    // add an instance variable for the object ID
    private int id;
    
    // add a class variable for the
    // number of Bicycle objects instantiated
    private static int numberOfBicycles = 0;
        ...
}
````

类变量通过它所在的类名和它自己的名字引用：

```java
Bicycle.numberOfBicycles
```

这样就将它们是类变量表现的很清楚。

------

**注意：** 你也可以用一个对象引用来引用静态字段，如下：

```java
myBike.numberOfBicycles
```

不过我们不建议这种做法，因为这样不能很清楚地表示它们是类变量。

------

你可以使用 `Bicycle` 构造器来设定 `id` 实例变量并增加 `numberOfBicycles` 类变量：

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
    private int id;
    private static int numberOfBicycles = 0;
        
    public Bicycle(int startCadence, int startSpeed, int startGear){
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        // increment number of Bicycles
        // and assign ID number
        id = ++numberOfBicycles;
    }

    // new method to return the ID instance variable
    public int getID() {
        return id;
    }
        ...
}
```

**类方法**

Java 语言支持 `static` 变量的同时，还支持 `static` 方法。`static` 方法，就是在其声明中包含 `static` 修饰符，应该通过类名调用，而不需要创建类实例。如下：

```java
ClassName.methodName(args)
```

------

**注意：** 你也可以用一个对象引用来引用静态方法，如下：

```java
instanceName.methodName(args)
```

不过我们不建议这种做法，因为这样不能很清楚地表示它们是类方法。

------

`static` 方法的通常用来访问 `static` 字段。比如，我们可以在 `Bicycle` 类中添加一个 `static` 方法来访问 `numberOfBicycles` `static` 变量：

```java
public static int getNumberOfBicycles() {
    return numberOfBicycles;
}
```

并非所有实例和类变量和方法的组合都是允许的：

 - 实例方法可以直接访问实例变量和实例方法。
 - 实例方法可以直接访问类变量和类方法。
 - 类方法可以直接访问类变量和类方法。
 - 类方法**不能**直接访问实例变量或实例方法 - 它们必须使用对象引用。此外，类方法不能使用 `this` 关键字，因为没有 `this` 的实例可以引用。

**常量**

`static` 访问修饰符，与 `final` 访问修饰符结合使用，用来定义常量。`final` 修饰符表示该字段的值不能改变。

比如，下面的变量声明定义了一个名为 `PI` 的常量，其值为圆周率的近似值。

````java
static final double PI = 3.141592653589793
````

这种方式定义的常量不能被赋值，如果你的程序试图这么做就会发生编译错误。传统上，常量值的名称通常都是由大写字母组成。如果该名称由一个以上的词组成，则这些词由下划线 `_` 连接。

------

**注意：** 如果基本数据类型或者字符串被定义为常量，同时其值在编译期确定，编译器就会将代码中所有的该常量的名称替换为它的值。这被称为*编译期*常量。如果外部世界中的常量的值已经改变，则你需要重新编译所有使用该常量的类以获取该常量的当前值。

------

**`Bicycle` 类**

经过这一节的修改，`Bicycle` 类变成了：

````java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    private int id;
    
    private static int numberOfBicycles = 0;

        
    public Bicycle(int startCadence,
                   int startSpeed,
                   int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        id = ++numberOfBicycles;
    }

    public int getID() {
        return id;
    }

    public static int getNumberOfBicycles() {
        return numberOfBicycles;
    }

    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear(){
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}
````

#### 初始化字段

如你所见，你通常可以在声明字段时提供一个初始值：

````java
public class BedAndBreakfast {

    // initialize to 10
    public static int capacity = 10;

    // initialize to false
    private boolean full = false;
}
````

当初始化值可用并且初始化可以放在一行上时，这很有效。然而，这种形式的初始化由于其简单性而具有局限性。如果初始化需要一些逻辑（例如，错误处理或 `for` 循环来填充复杂的数组），则简单的赋值是不合适的。实例变量可以在构造函数中初始化，其中可以使用错误处理或其他逻辑。为了为类变量提供相同的功能，Java 编程语言包括静态初始化块。

------

**注意：** 没有必要在类定义的开头处声明字段，虽然这种做法是最常见的做法。不过在使用它们之前声明和初始化它们是必须的。

------

**静态初始化块**

*静态初始化块* 是由大括号包围起来的普通代码块，以 `static` 关键字引导。下面是个例子：

````java
static {
  // whatevet code is needed for initialization goes here
}
````

一个类可以包含任意数量的静态初始化块，它们可以出现在类主体的任意位置。运行时系统保证静态初始化块会按照它们在源代码中出现的顺序被调用。

另外一种静态代码块，你可以写一个私有静态方法：

````java
class Whatever {
    public static varType myVar = initializeClassVariable();
        
    private static varType initializeClassVariable() {

        // initialization code goes here
    }
}
````

私有静态方法的优点是，它们可以随后被重新使用，如果你需要重新初始化类变量。

**初始化实例成员**

通常，你可以将实例化和初始化变量的代码放入构造器。存在两种不同的方法来使用构造器来实例化变量：初始化块和 `final` 方法。

实例变量的初始化块看起来类似于静态初始化块，只是没有 `static` 关键字：

````java
{
  // whatever code is needed for initialization goes here
}
````

Java 编译器将初始化块复制到每个构造器中。因此，这种方法可以用来在多个构造器之间共享代码块。

`final` 方法不能在子类中被覆盖。这一点将在接口和继承章节中讨论。下面是使用 `final` 方法初始化实例变量的例子：

````java
class Whatever {
    private varType myVar = initializeInstanceVariable();
        
    protected final varType initializeInstanceVariable() {

        // initialization code goes here
    }
}
````

如果子类可能希望重用初始化方法，这尤其有用。该方法是 `final` 的，因为在实例初始化期间调用非 `final` 方法可能会导致问题。

#### 创建和使用类和对象小结

类声明为类命名，并用大括号包含类主体。类名称可以由修饰符引导。类主体包含字段、方法以及类的构造器。类使用字段保持静态信息，使用方法实现行为。构造器初始化类的实例，使用类名作为名称，形如一个没有返回值类型的方法。

控制类和成员的访问的方法相同：在它们的声明中使用访问修饰符，比如 `public` 等。

通过在成员声明中使用 `static` 关键字，你可以指定类变量或者类方法。没有声明为 `static` 的成员就隐式作为实例变量。类变量由所有类实例共享，可以通过类名称或者实例引用访问。类的实例获取每个实例变量的自己的副本，必须通过实例引用访问它们。

你可以使用 `new` 操作符和构造器从类创建对象。`new` 操作符返回新创建的对象的引用。你可以将该引用赋值给一个变量或者直接使用它。

可以通过使用限定名称来引用在声明它们的类之外的代码可访问的实例变量和方法。实例变量的限定名称如下所示：

````
objectReference.variableName
````

方法的全限定名称形如：

````
objectReference.methodName(argumentList)
````

或者：

````
objectReference.methodName()
````

垃圾收集器会自动清理未使用的对象。如果程序不再包含对它的引用，则不使用该对象。您可以通过将包含引用的变量设置为 `null`来显式删除引用。

### 嵌套类

Java 语言允许你在类内部定义另一个类。这种位于其它类内部的类被称为*内部类*，形如：

````java
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}
````

------

**术语：** 内部类分为两种：静态的和非静态的。声明为 `static` 的就是*静态嵌套类*。其它的称为*内部类*。

------

````java
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
````

嵌套类是它所在的类的成员。非静态的嵌套类（内部类）可以访问它所在的类的其它成员，即使它们被声明为 `private` 的。静态嵌套类不能访问它们所在的类的其它成员。作为 `OuterClass` 的成员，嵌套类可以被声明为 `private` ，`public`，`protected` 或者*package private* 。（回想一下，外部类只能声明为 `public` 或 `package private`）

**为什么使用嵌套类？**

使用嵌套类的令人信服的理由包括：

* **它是一种逻辑类分组仅在一个地方使用的方法**：如果一个类只对另一个类有用，那么将它嵌入该类并将两者保持在一起是合乎逻辑的。嵌套这样的“帮助类”使得它们的包更加简化。
* **它增加了封装**：考虑两个顶级类A和B，其中B需要访问A的成员，否则这些成员将被声明为私有。通过将类B隐藏在类A中，可以将A的成员声明为私有，并且B可以访问它们。另外，B本身可以对外部隐藏。
* **它可以带来更易读和可维护的代码**：在顶级类中嵌套小类会使代码更接近于使用它的位置。

**静态嵌套类**

与类方法和变量一样，静态嵌套类与其外部类相关联。和静态类方法一样，静态嵌套类不能直接引用其封闭类中定义的实例变量或方法：它只能通过对象引用来使用它们。

------

**注意：**静态嵌套类与其外部类（和其他类）的实例成员交互，就像任何其他顶级类一样。 实际上，静态嵌套类在行为上是一个顶级类，它已嵌套在另一个顶级类中以方便打包。

------

静态嵌套类通过包含它的类名访问：

```java
OuterClass.StaticNestedClass
```

比如，使用下面的语法来闯进静态嵌套类的对象：

```java
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
```

**内部类**

与实例方法和变量一样，内部类与其所在的类的实例相关联，并且可以直接访问该对象的方法和字段。此外，由于内部类与实例相关联，因此本身无法定义任何静态成员。

作为内部类的实例的对象存在于外部类的实例中。 考虑以下类：

````java
class OuterClass {
    ...
    class InnerClass {
        ...
    }
}
````

`InnerClass` 的实例只能存在于 `OuterClass` 的实例中，并且可以直接访问其所在类实例的方法和字段。

要实例化内部类，必须首先实例化外部类。然后，使用以下语法在外部对象中创建内部对象：

````java
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
````

有两种特殊的内部类： [local classes](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html) 和 [anonymous classes](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)。

**遮蔽**

如果特定作用域（例如内部类或方法定义）中的类型声明（例如成员变量或参数名称）与包含它的外部作用域中的另一个声明具有相同的名称，则内部作用域中的声明将遮蔽外部作用域中的声明。您不能仅通过其名称引用被遮蔽的声明。以下示例 `ShadowTest` 演示了这一点：

````java
public class ShadowTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            System.out.println("x = " + x);
            System.out.println("this.x = " + this.x);
            System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);
        }
    }

    public static void main(String... args) {
        ShadowTest st = new ShadowTest();
        ShadowTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}
````

程序输出：

````java
x = 23
this.x = 1
ShadowTest.this.x = 0
````

上面的例子定义了三个名为 `x` 的变量：类 `ShadowTest` 的成员变量，内部类 `FirstLevel` 的成员变量，以及方法 `methodInFirstLevel` 的参数。作为方法参数的变量 `x` 或遮蔽同名的内部类成员变量，因此，当你在方法中使用该变量时，它指的是方法参数。为了表示内部类的成员变量，可以使用 `this` 关键字表示包含当前作用域的外部作用域：

```java
System.out.println("this.x = " + this.x);
```

通过使用它们所属于的类的名称来引用更外层作用域中的成员变量。比如，下面的语句在方法`methodInFirstLevel` 中访问`ShadowTest`类的成员变量：

```java
System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);
```

**序列化**

强烈建议不要对内部类（包括本地类和匿名类）进行序列化。当Java编译器编译某些构造（如内部类）时，它会创建*合成结构* ；这些是类，方法，字段和其他在源代码中没有相应结构的结构。合成结构使 Java 编译器能够在不更改 JVM 的情况下实现新的 Java 语言功能。但是，合成结构可以在不同的 Java 编译器实现之间变化，这意味着 `.class` 文件也可以在不同的实现之间变化。因此，如果序列化内部类，然后使用不同的 JRE 实现反序列化，则可能存在兼容性问题。有关在编译内部类时生成的合成结构的更多信息，请参阅获  [Obtaining Names of Method Parameters](https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html) 一节中的  [Implicit and Synthetic Parameters](https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html#implcit_and_synthetic) 部分。

#### 内部类示例

为了观察使用中的内部类，首先考虑数组。在下面的例子中，你创建一个数组，用整型数值填满它，然后以升序输出其中偶数下标的数值。

[`DataStructure.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java) 例子由以下内容组成：

- `DataStructure` 外部类，包含一个构造器来创建 `DataStructure` 的实例，该实例包含一个填满顺序整型数值的数组，同时还包含一个方法将数组中偶数下标元素值打印出来。
- `EvenIterator` 内部类，实现了 `DataStructureIterator`  接口，继承了 [`Iterator`](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)`<` [`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)`>` 接口。迭代器被用来遍历一个数据结构，同时还有相应的方法来检测是否到达最后一个元素、获取当前元素以及删除下一个元素。
- `main` 方法实例化一个 `DataStructure` 对象(`ds`)，然后调用 `printEven` 方法来打印数组 `arrayOfInts` 中偶数下标的元素值。

````java
public class DataStructure {
    
    // Create an array
    private final static int SIZE = 15;
    private int[] arrayOfInts = new int[SIZE];
    
    public DataStructure() {
        // fill the array with ascending integer values
        for (int i = 0; i < SIZE; i++) {
            arrayOfInts[i] = i;
        }
    }
    
    public void printEven() {
        
        // Print out values of even indices of the array
        DataStructureIterator iterator = this.new EvenIterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
    }
    
    interface DataStructureIterator extends java.util.Iterator<Integer> { } 

    // Inner class implements the DataStructureIterator interface,
    // which extends the Iterator<Integer> interface
    
    private class EvenIterator implements DataStructureIterator {
        
        // Start stepping through the array from the beginning
        private int nextIndex = 0;
        
        public boolean hasNext() {
            
            // Check if the current element is the last in the array
            return (nextIndex <= SIZE - 1);
        }        
        
        public Integer next() {
            
            // Record a value of an even index of the array
            Integer retValue = Integer.valueOf(arrayOfInts[nextIndex]);
            
            // Get the next even element
            nextIndex += 2;
            return retValue;
        }
    }
    
    public static void main(String s[]) {
        
        // Fill the array with integer values and print out only
        // values of even indices
        DataStructure ds = new DataStructure();
        ds.printEven();
    }
}
````

程序输出：

````
0 2 4 6 8 10 12 14 
````

请注意，`EvenIterator` 类直接引用 `DataStructure` 对象的 `arrayOfInts` 实例变量。

您可以使用内部类来实现帮助程序类，例如本示例中显示的帮助程序类。要处理用户界面事件，您必须知道如何使用内部类，因为事件处理机制会广泛使用它们。

**局部类和匿名类**

还有两种类型的内部类。您可以在方法体内声明内部类。这些类称为 [local classes](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html)。您还可以在方法体内声明内部类，而无需命名该类。这些类称为 [anonymous classes](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)。

**修饰符**

您可以对内部类使用与外部类的其他成员相同的修饰符。例如，您可以使用访问修饰符 `private`，`public` 和 `protected` 来限制对内部类的访问，就像您使用它们来限制对其他类成员的访问一样。

#### 局部类

局部类是在代码块中声明的类，所谓的代码块就是配对的括号包围的若干条语句。你通常可以发现定义在方法体中的局部类。

本节涵盖了以下主题：

- [声明局部类](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#declaring-local-classes)
- 访问外部类的成员
  - [遮蔽和局部类](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#shadowing-and-local-classes)
- [局部类类似于内部类](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#local-classes-are-similar-to-inner-classes)

**声明局部类**

你可以在任何代码块中定义局部类 (参考 [Expressions, Statements, and Blocks](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html) 获取更多信息)。比如，你可以在方法主体中定义局部类，在 `for` 循环内部，或者在 `if` 语句块内部。

下面的例子，[`LocalClassExample`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LocalClassExample.java)， 校验两个电话号码。它在方法 `validatePhoneNumber` 中定义局部类 `PhoneNumber` ：

```java
public class LocalClassExample {
  
    static String regularExpression = "[^0-9]";
  
    public static void validatePhoneNumber(
        String phoneNumber1, String phoneNumber2) {
      
        final int numberLength = 10;
        
        // Valid in JDK 8 and later:
       
        // int numberLength = 10;
       
        class PhoneNumber {
            
            String formattedPhoneNumber = null;

            PhoneNumber(String phoneNumber){
                // numberLength = 7;
                String currentNumber = phoneNumber.replaceAll(
                  regularExpression, "");
                if (currentNumber.length() == numberLength)
                    formattedPhoneNumber = currentNumber;
                else
                    formattedPhoneNumber = null;
            }

            public String getNumber() {
                return formattedPhoneNumber;
            }
            
            // Valid in JDK 8 and later:

//            public void printOriginalNumbers() {
//                System.out.println("Original numbers are " + phoneNumber1 +
//                    " and " + phoneNumber2);
//            }
        }

        PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);
        PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);
        
        // Valid in JDK 8 and later:

//        myNumber1.printOriginalNumbers();

        if (myNumber1.getNumber() == null) 
            System.out.println("First number is invalid");
        else
            System.out.println("First number is " + myNumber1.getNumber());
        if (myNumber2.getNumber() == null)
            System.out.println("Second number is invalid");
        else
            System.out.println("Second number is " + myNumber2.getNumber());

    }

    public static void main(String... args) {
        validatePhoneNumber("123-456-7890", "456-7890");
    }
}
```

该示例通过首先从电话号码中删除除0到9之外的所有字符来验证电话号码。之后，它检查电话号码是否包含正好十位数（北美电话号码的长度）。此示例打印以下内容：

```java
First number is 1234567890
Second number is invalid
```

**访问外部类成员**

局部类可以访问它的外部类的成员。在上面的例子中，`PhoneNumber` 构造器访问成员 `LocalClassExample.regularExpression`。

另外，局部类可以访问局部变量。不过局部类只能访问声明为 `final` 的局部变量。当局部类访问包围它的代码块中的局部变量或者参数时，它*捕获*那些变量和参数。比如， `PhoneNumber` 构造器可以访问局部变量 `numberLength` 因为它被声明为 `final`；`numberLength` 是*被捕获*的变量。

但是，从Java SE 8开始，本地类可以访问包围它的代码块的 `final` 或者等效 `final` 的局部变量和参数。在初始化之后其值永远不会改变的变量或参数就是等效 `final` 的。例如，假设变量 `numberLength` 未声明为 `final`，并且您在`PhoneNumber` 构造函数中添加下面例子中的赋值语句，以将有效电话号码的长度更改为7位数：

```java
PhoneNumber(String phoneNumber) {
    numberLength = 7;
    String currentNumber = phoneNumber.replaceAll(
        regularExpression, "");
    if (currentNumber.length() == numberLength)
        formattedPhoneNumber = currentNumber;
    else
        formattedPhoneNumber = null;
}
```

由于这个赋值语句，变量 `numberLength` 不再是 `final` 等效的。因此，Java编译器生成类似于 “local variables referenced from an inner class must be final or effectively final" 的错误消息，其中内部类 `PhoneNumber` 尝试访问`numberLength` 变量：

```java
if (currentNumber.length() == numberLength)
```

从Java SE 8开始，如果在方法中声明本地类，它可以访问方法的参数。例如，您可以在 `PhoneNumberlocal` 类中定义以下方法：

```java
public void printOriginalNumbers() {
    System.out.println("Original numbers are " + phoneNumber1 +
        " and " + phoneNumber2);
}
```

`printOriginalNumbers` 方法访问 `validatePhoneNumber` 方法的参数 `phoneNumber1` 和 `phoneNumber2` 。

**遮蔽和局部类**

在一个局部类中的类型声明（比如一个变量）遮蔽外部作用域中的同名声明。参考 [Shadowing](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing) 获取更多信息。

**局部类类似于内部类**

局部类类似于内部类，因为他们不能定义或者声明任何静态成员。静态方法中的局部类，比如上面的 `PhoneNumber` 类，定义在静态方法 `validatePhoneNumber` 内部，只能引用外部类中的静态成员。例如，如果你没有将成员变量 `regularExpression` 定义为静态变量，则 Java 编译器会产生类似于 "no-static variable regularExpression cannot be referenced from a static context" 的错误信息。

局部类是非静态的，因为它们访问外部代码块的实例成员。因此它们不能包含大多数种类的静态声明。

你不能在一个代码块中声明一个接口，接口本质上是静态的。比如，下面的代码块无法通过编译：

````java
public void greetInEnglish() {
    interface HelloThere {
       public void greet();
    }
    class EnglishHelloThere implements HelloThere {
        public void greet() {
           System.out.println("Hello " + name);
        }
    }
    HelloThere myGreeting = new EnglishHelloThere();
    myGreeting.greet();
}
````

你不能在一个局部类中声明静态初始化器或者静态成员接口。下面的代码同样不能通过编译。编译器将会产生类似于 "modifier 'static' is only allowed in constant variable declaration" ，当它遇到该方法定义：

````java
public void sayGoodbyeInEnglish() {
    class EnglishGoodbye {
        public static void sayGoodbye() {
            System.out.println("Bye bye");
        }
    }
    EnglishGoodbye.sayGoodbye();
}
````

局部类可以具有静态成员，前提是它们是常量变量。（常量变量是基本类型或 `String` 类型的变量，声明为 `final` 并使用编译时常量表达式初始化。编译时常量表达式通常是可在编译时计算的字符串或算术表达式。参考  [Understanding Class Members](https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html) 了解更多信息。）以下代码可以通过编译，因为静态成员 `EnglishGoodbye.farewell` 是一个常量变量：

````java
public void sayGoodbyeInEnglish() {
    class EnglishGoodbye {
        public static final String farewell = "Bye bye";
        public void sayGoodbye() {
            System.out.println(farewell);
        }
    }
    EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();
    myEnglishGoodbye.sayGoodbye();
}
````

#### 匿名类

匿名类使您可以使代码更简洁。它们使您能够同时声明和实例化一个类。它们就像局部类，除了它们没有名字。如果您只需要使用局部类一次，请使用它们。

本节包括以下主题

- [声明匿名类](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#declaring-anonymous-classes)
- [匿名类的语法](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#syntax-of-anonymous-classes)
- [访问外部作用域的局部变量，以及声明和访问匿名类的成员](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#accessing)
- [匿名类的示例](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#examples-of-anonymous-classes)

**声明匿名类**

虽然局部类是类声明，但匿名类是表达式，这意味着您在另一个表达式中定义该类。以下示例[`HelloWorldAnonymousClasses`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/HelloWorldAnonymousClasses.java) 在局部变量 `frenchGreeting` 和 `spanishGreeting` 的初始化语句中使用匿名类，但使用本地类来初始化变量 `englishGreeting`：

````java
public class HelloWorldAnonymousClasses {
  
    interface HelloWorld {
        public void greet();
        public void greetSomeone(String someone);
    }
  
    public void sayHello() {
        
        class EnglishGreeting implements HelloWorld {
            String name = "world";
            public void greet() {
                greetSomeone("world");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Hello " + name);
            }
        }
      
        HelloWorld englishGreeting = new EnglishGreeting();
        
        HelloWorld frenchGreeting = new HelloWorld() {
            String name = "tout le monde";
            public void greet() {
                greetSomeone("tout le monde");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Salut " + name);
            }
        };
        
        HelloWorld spanishGreeting = new HelloWorld() {
            String name = "mundo";
            public void greet() {
                greetSomeone("mundo");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Hola, " + name);
            }
        };
        englishGreeting.greet();
        frenchGreeting.greetSomeone("Fred");
        spanishGreeting.greet();
    }

    public static void main(String... args) {
        HelloWorldAnonymousClasses myApp =
            new HelloWorldAnonymousClasses();
        myApp.sayHello();
    }            
}
````

**匿名类语法**

如前所述，一个匿名类是一个表达式。匿名类表达式的语法看起来像是调用构造器，除了该代码块中包含一个类定义。

考虑 `frenchGreeting` 对象的实例化：

````java
HelloWorld frenchGreeting = new HelloWorld() {
    String name = "tout le monde";
    public void greet() {
        greetSomeone("tout le monde");
    }
    public void greetSomeone(String someone) {
        name = someone;
        System.out.println("Salut " + name);
    }
};
````

匿名类表达式由以下部分组成：

* `new` 操作符

* 类实现的接口名称或者类扩展的类名称。在上述例子中，匿名类实现了 `HelloWorld` 接口。
* 包含构造函数的参数的括号，就像普通的类实例创建表达式一样。注意：实现接口时，没有构造函数，因此您使用一对空括号，如本例所示。
* 一个主体，类声明主体。更特殊的，在这个主体中，允许方法声明，而不允许语句。

因为匿名类定义是一个表达式，它必须是一条语句的一部分。在这个例子中，匿名类表达式是 `frenchGreeting` 对象实例化语句的一部分。(这就是为什么在右大括号之后是一个分号)

**访问外部作用域的局部变量，以及声明和访问匿名类的成员**

类似于局部类，匿名类能够 [捕获变量](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#accessing-members-of-an-enclosing-class) ；它们同样可以访问外围作用域中的局部变量：

- 匿名类可以访问包围它的类的成员。
- 匿名类不能访问包围它的外围作用域中的没有声明为 `final` 和等效 `final` 的局部变量。
- 类似于嵌套类，匿名类中的类型声明（比如一个变量）会遮蔽外围作用域中的同名声明。参考 [Shadowing](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing) 获取更多信息。

匿名类作为局部类起成员也有相同的限制：

* 您不能在匿名类中声明静态初始化程序或成员接口。
* 匿名类可以具有静态成员，前提是它们是常量变量。

注意你可以在匿名类中声明下以下内容：

- 字段
- 额外的方法（即使他们没有实现超类型的任何方法）
- 实例初始化器
- 局部类

不过，你不能在匿名类中声明构造器。

**匿名类示例**

匿名类通常用于图形用户界面程序开发。

考虑下面的 JavaFX 例子 [`HelloWorld.java`](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) (来自 [Hello World, JavaFX Style](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) 在 [Getting Started with JavaFX](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/javafx_get_started.htm))。该例子创建了一个框架包含 **Say 'Hello World'** 按钮：

````java

import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
 
public class HelloWorld extends Application {
    public static void main(String[] args) {
        launch(args);
    }
    
    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Hello World!");
        Button btn = new Button();
        btn.setText("Say 'Hello World'");
        btn.setOnAction(new EventHandler<ActionEvent>() {
 
            @Override
            public void handle(ActionEvent event) {
                System.out.println("Hello World!");
            }
        });
        
        StackPane root = new StackPane();
        root.getChildren().add(btn);
        primaryStage.setScene(new Scene(root, 300, 250));
        primaryStage.show();
    }
}
````

在此示例中，方法调用 `btn.setOnAction` 指定在选择 **Say“Hello World”** 按钮时发生的情况。此方法需要 `EventHandler <ActionEvent>` 类型的对象。`EventHandler <ActionEvent>` 接口只包含一个方法 `handle`。该示例使用匿名类表达式，而不是使用新类实现此方法。请注意，此表达式是传递给 `btn.setOnAction` 方法的参数。

因为 `EventHandler <ActionEvent>` 接口只包含一个方法，所以可以使用 lambda 表达式而不是匿名类表达式。有关更多信息，请参阅[Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)表达式一节。

匿名类是实现包含两个或更多方法的接口的理想选择。以下 JavaFX 示例来自 UI 控件的自定义部分。突出显示的代码创建一个仅接受数值的文本字段。它通过重写从 `TextInputControl` 类继承的 `replaceText` 和 `replaceSelection` 方法，使用匿名类重新定义 `TextField` 类的默认实现。

````java
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class CustomTextFieldSample extends Application {
    
    final static Label label = new Label();
 
    @Override
    public void start(Stage stage) {
        Group root = new Group();
        Scene scene = new Scene(root, 300, 150);
        stage.setScene(scene);
        stage.setTitle("Text Field Sample");
 
        GridPane grid = new GridPane();
        grid.setPadding(new Insets(10, 10, 10, 10));
        grid.setVgap(5);
        grid.setHgap(5);
 
        scene.setRoot(grid);
        final Label dollar = new Label("$");
        GridPane.setConstraints(dollar, 0, 0);
        grid.getChildren().add(dollar);
        
        final TextField sum = new TextField() {
            @Override
            public void replaceText(int start, int end, String text) {
                if (!text.matches("[a-z, A-Z]")) {
                    super.replaceText(start, end, text);                     
                }
                label.setText("Enter a numeric value");
            }
 
            @Override
            public void replaceSelection(String text) {
                if (!text.matches("[a-z, A-Z]")) {
                    super.replaceSelection(text);
                }
            }
        };
 
        sum.setPromptText("Enter the total");
        sum.setPrefColumnCount(10);
        GridPane.setConstraints(sum, 1, 0);
        grid.getChildren().add(sum);
        
        Button submit = new Button("Submit");
        GridPane.setConstraints(submit, 2, 0);
        grid.getChildren().add(submit);
        
        submit.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                label.setText(null);
            }
        });
        
        GridPane.setConstraints(label, 0, 1);
        GridPane.setColumnSpan(label, 3);
        grid.getChildren().add(label);
        
        scene.setRoot(grid);
        stage.show();
    }
 
    public static void main(String[] args) {
        launch(args);
    }
}
````

#### Lambda 表达式

匿名类的一个问题是，如果匿名类的实现非常简单，例如只包含一个方法的接口，那么匿名类的语法可能看起来不实用且不清楚。 在这些情况下，您通常会尝试将功能作为参数传递给另一个方法，例如当有人单击按钮时应采取的操作。Lambda表达式使您可以执行此操作，将功能视为方法参数，或将代码视为数据。

前面一个小节，[Anonymous Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)，向你展示了如何实现一个基类而必须要给它一个名称。尽管这通常比命名类要简洁一些，但是即使是对只包含一个方法的类来说，匿名类都似乎仍然有些复杂和繁琐。Lambda 表达式允许你更简洁地表达单方法类的实例。

本小节包含以下主体：

- [Lambda表达式的理想用例](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#use-case)
  - [方法1：创建搜索匹配一个特征的成员的方法](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach1)
  - [方法2：创建更多广义搜索方法](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach2)
  - [方法3：在局部类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3)
  - [方法4：在匿名类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach4)
  - [方法5：使用Lambda表达式指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach5)
  - [方法6：将标准函数式接口与Lambda表达式一起使用](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach6)
  - [方法7：在整个应用程序中使用Lambda表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach7)
  - [方法8：更广泛地使用泛型](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach8)
  - [方法9：使用接受Lambda表达式作为参数的聚合操作](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach9)
- [GUI应用程序中的Lambda表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#lambda-expressions-in-gui-applications)
- [Lambda表达式的语法](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax)
- [访问外围作用域的局部变量](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#accessing-local-variables)
- [目标类型](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing)
  - [目标类型和方法参数](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-types-and-method-arguments)
- [序列化](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#serialization)

**Lambda表达式的理想用例**

假设您正在创建社交网络应用程序。您希望创建一项功能，使管理员能够对满足特定条件的社交网络应用程序成员执行任何类型的操作，例如发送消息。下表详细描述了此用例：

| 字段     | 描述                                       |
| ------ | ---------------------------------------- |
| 名字     | 在选中的成员上执行动作                              |
| 主操作员   | 管理员                                      |
| 前置条件   | 管理员登入系统                                  |
| 后置条件   | 动作只在符合特定条件的成员身上执行                        |
| 主要成功场景 | 管理员指定要对其执行特定操作的成员的条件。管理员指定要对这些选定成员执行的操作。管理员选择**提交**按钮。系统查找符合指定条件的所有成员。系统执行指定的操作。对所有匹配成员采取行动。 |
| 扩展     | 1A。管理员可以选择在指定要执行的操作之前或选择**提交**按钮之前预览符合指定条件的成员。 |
| fa     | mei                                      |

假设此社交网络应用程序的成员由以下 [`Person`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Person.java)类表示：

````java
public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }

    public void printPerson() {
        // ...
    }
}
````

假设您的社交网络应用程序的成员存储在 `List <Person>` 实例中。

本节首先介绍这种用例的简单方法。它使用局部类和匿名类改进了这种方法，然后使用 lambda 表达式以高效和简洁的方法完成。在示例 `RosterTest` 中找到本节中描述的代码。

**方法1：创建搜索匹配一个特征的成员的方法**

一种简单的方法是创建几种方法 ，每种方法都会搜索与一个特征匹配的成员，例如性别或年龄。以下方法打印超过指定年龄的会员：

```java
public static void printPersonsOlderThan(List<Person> roster, int age) {
    for (Person p : roster) {
        if (p.getAge() >= age) {
            p.printPerson();
        }
    }
}
```

**注意**:  [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) 是一个有序 [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)。一个 *集合* 是一个对象，它将多个元素组织称为一个单独的单元。集合用来存储、查询、操作依据传输聚合数据。有关集合的更多信息，参考 [Collections](https://docs.oracle.com/javase/tutorial/collections/index.html) 。

这种方法可能会使您的应用程序变得脆弱，这是由于引入了更新（例如更新的数据类型）导致应用程序无法工作的可能性。假设您升级应用程序并更改 `Person` 类的结构，使其包含不同的成员变量，也许该类记录和测量年龄与不同的数据类型或算法。您必须重写大量 API 以适应此更改。此外，这种方法是不必要的限制。例如，如果您想要打印年龄小于某个年龄的会员，该怎么办？

**方法2：创建更多广义搜索方法**

下面的方法比 `printPersonOlderThan` 更一般，打印特定年龄范围的会员：

```java
public static void printPersonsWithinAgeRange(
    List<Person> roster, int low, int high) {
    for (Person p : roster) {
        if (low <= p.getAge() && p.getAge() < high) {
            p.printPerson();
        }
    }
}
```

如果您想要打印指定性别的成员，或指定性别和年龄范围的组合，该怎么办？如果您决定更改 `Person` 类并添加其他属性（如关系状态或地理位置），该怎么办？虽然这种方法比 `printPersonsOlderThan` 更通用，但是尝试为每个可能的搜索查询创建单独的方法仍然会导致代码脆弱。您可以将在不同类中按照不同条件进行搜索的代码分开。

**方法3：在局部类中指定搜索条件代码**

下面的方法打印匹配到你指定 的搜索条件的会员：

```java
public static void printPersons(
    List<Person> roster, CheckPerson tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}
```

此方法通过调用`tester.test`方法检查`List`参数`roster`中包含的每个`Person`实例是否满足`CheckPerson`参数`tester`中指定的搜索条件。如果方法`tester.test`返回`true`值，则在`Person`实例上调用方法`printPersons`。

要指定搜索条件，请实现`CheckPerson`接口：

```
interface CheckPerson {
    boolean test(Person p);
}
```

下面的类通过指定方法`test`的实现来实现`CheckPerson`接口。此方法筛选符合美国选择性服务条件的会员：如果其`Person`参数为男性且年龄介于18和25之间，则返回`true`值：

```java
class CheckPersonEligibleForSelectiveService implements CheckPerson {
    public boolean test(Person p) {
        return p.gender == Person.Sex.MALE &&
            p.getAge() >= 18 &&
            p.getAge() <= 25;
    }
}
```

为了使用这个类，你创建一个它的新的实例病调用 `printPersons` 方法：

```java
printPersons(
    roster, new CheckPersonEligibleForSelectiveService());
```

虽然这种方法不那么脆弱 - 如果你改变`Person`的结构，你不必重写方法 - 你还有其他代码：你计划在你的应用程序中执行的每个搜索的新接口和局部类。因为`CheckPersonEligibleForSelectiveService`实现了一个接口，所以您可以使用匿名类而不是局部类，并且无需为每次搜索声明一个新类。

**方法4：在匿名类中指定搜索条件代码**

以下调用方法`printPersons`的一个参数是一个匿名类，它过滤了符合美国选择性服务条件的成员：男性和年龄在18到25岁之间：

```java
printPersons(
    roster,
    new CheckPerson() {
        public boolean test(Person p) {
            return p.getGender() == Person.Sex.MALE
                && p.getAge() >= 18
                && p.getAge() <= 25;
        }
    }
);
```

此方法减少了所需的代码量，因为您不必为要执行的每个搜索创建新类。但是，考虑到`CheckPerson`接口只包含一个方法，匿名类的语法很笨重。在这种情况下，您可以使用lambda表达式而不是匿名类，如下一节中所述。

**方法5：使用Lambda表达式指定搜索条件代码**

`CheckPerson` 接口是一个*函数式接口*。函数式接口指的是仅仅包含一个[abstract method](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html) （函数式接口可以包含一个或者多个 [default methods](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html) 或者 [static methods](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static) 。）的任何接口。因为函数式接口只包含一个抽象方法，当你实现该接口时就可以忽略该方法名称。为了这样做，不再使用匿名类表达式，而是使用*lambda 表达式*，如下面例子所示：

```java
printPersons(
    roster,
    (Person p) -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);
```

参考 [Syntax of Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax) 获取更多有关如何定义 lambda 表达式的信息。

您可以使用标准函数式接口代替`CheckPerson`接口，这可以进一步减少所需的代码量。

**方法6：将标准函数式接口与Lambda表达式一起使用**

重新考虑 `CheckPerson` 接口：

```java
interface CheckPerson {
    boolean test(Person p);
}
```

这是一个非常简单的接口。它是一个函数式接口，因为只包含一个抽象方法。该方法携带一个参数并返回一个 `boolean` 值。该方法太简单而不值得在你的应用中定义一个。因此，JDK 定义了若干标准函数式接口，放在包 `java.util.function` 中。

比如，你可以使用 `Predicate<T>` 接口来替换 `CheckPerson` 。该接口包含方法 `boolean test(T t)`：

```java
interface Predicate<T> {
    boolean test(T t);
}
```

接口 `Predicate<T>` 是一个泛型接口的例子。(有关泛型的更多信息，参考 [Generics (Updated)](https://docs.oracle.com/javase/tutorial/java/generics/index.html) 章节。) 泛型类型 (比如泛型接口) 在尖括号 (`<>`)中指定一个或者多个类型参数。该接口值包含一个类型参数， `T` 。当你使用实际类型参数声明或者实例化一个泛型类型时，你将拥有一个参数化类型。比如，下面的例子是参数化类型 `Predicate<Person>` ：

```java
interface Predicate<Person> {
    boolean test(Person t);
}
```

参数化类型包含一个方法，该方法的返回类型和参数与 `CheckPerson.boolean test(Person p)` 相同。接下来，你可以使用 `Predicate<T>` 替代 `CheckPerson` 如下面例子所示：

```java
public static void printPersonsWithPredicate(
    List<Person> roster, Predicate<Person> tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}
```

由此，下面的方法调用与你在 [方法3：在局部类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3) 中调用 `printPersons` 一样可以获取符合选择性服务条件的会员：

```java
printPersonsWithPredicate(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);
```

这并不是在方法中使用 lambda 表达式的唯一方式。下面的内容将介绍使用 lambda 表达式的其它方式。

**方法7：在整个应用程序中使用Lambda表达式**

重新考虑方法 `printPersonsWithPredicate` 以查看可以使用 lambda 表达式的其他位置：

```java
public static void printPersonsWithPredicate(
    List<Person> roster, Predicate<Person> tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}
```

此方法检查 `List` 参数名单中包含的每个 `Person` 实例是否满足 `Predicate` 参数测试器中指定的条件。如果 `Personinstance` 确实满足 `tester` 所指定的条件，则在 `Person` 实例上调用 `printPersron` 方法。

您可以指定在满足测试人员指定条件的 `Person` 实例上执行的不同操作，而不是调用方法 `printPerson` 。您可以使用 lambda 表达式指定此操作。假设你想要一个类似于 `printPerson` 的 lambda 表达式，它接受一个参数（`Person` 类型的对象）并返回 `void` 。请记住，要使用 lambda 表达式，您需要实现一个函数式接口。在这种情况下，您需要一个包含抽象方法的函数式接口，该方法可以接受一个 `Person` 类型的参数并返回 `void` 。 `Consumer <T>` 接口包含具有这些特征的 `void accept(T t)`方法。以下方法将调用 `p.printPerson()` 替换为调用方法 `accept` 的 `Consumer <Person>` 实例：

```java
public static void processPersons(
    List<Person> roster,
    Predicate<Person> tester,
    Consumer<Person> block) {
        for (Person p : roster) {
            if (tester.test(p)) {
                block.accept(p);
            }
        }
}
```

由此，下面的方法调用与你在 [方法3：在局部类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3) 中调用 `printPersons` 一样可以获取符合选择性服务条件的会员。用于打印会员的 lambda 表达式如下：

```java
processPersons(
     roster,
     p -> p.getGender() == Person.Sex.MALE
         && p.getAge() >= 18
         && p.getAge() <= 25,
     p -> p.printPerson()
);
```

如果您想要对会员的个人资料进行更多操作而不是打印出来，该怎么办？ 假设您要验证成员的个人资料或检索他们的联系信息？ 在这种情况下，您需要一个包含返回值的抽象方法的函数式接口。 `Function <T，R>` 接口包含方法 `R apply(T t)` 。 以下方法检索参数 `mapper` 指定的数据，然后在其上执行参数 `block` 指定的操作：

```java
public static void processPersonsWithFunction(
    List<Person> roster,
    Predicate<Person> tester,
    Function<Person, String> mapper,
    Consumer<String> block) {
    for (Person p : roster) {
        if (tester.test(p)) {
            String data = mapper.apply(p);
            block.accept(data);
        }
    }
}
```

以下方法从有资格获得选择性服务的名册中包含的每个成员检索电子邮件地址，然后将其打印出来：

```java
processPersonsWithFunction(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);
```

**方法8：更广泛地使用泛型**

重新考虑方法 `processPersonsWithFunction` 。以下是它的通用版本，它接受包含任何数据类型元素的集合作为参数：

```java
public static <X, Y> void processElements(
    Iterable<X> source,
    Predicate<X> tester,
    Function <X, Y> mapper,
    Consumer<Y> block) {
    for (X p : source) {
        if (tester.test(p)) {
            Y data = mapper.apply(p);
            block.accept(data);
        }
    }
}
```

要打印有资格获得选择性服务的成员的电子邮件地址，请按如下方式调用 `processElements` 方法：

```java
processElements(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);
```

此方法调用执行以下操作：

1. 从集合 `source` 中获取对象源。在此示例中，它从集合 `roster` 中获取 `Person` 对象的源。请注意，集合 `roster` 是 `List` 类型的集合，也是 `Iterable` 类型的对象。
2. 过滤与 `Predicate` 类型 `tester` 匹配的对象。在此示例中，`Predicate` 对象是一个 lambda 表达式，指定哪些成员有资格获得选择性服务。
3. 将每个筛选对象映射到 `Function` 类型对象 `mapper` 指定的值。在此示例中，`Function` 对象是一个 lambda 表达式，它返回成员的电子邮件地址。
4. 对 `Consumer` 对象 `block` 指定的每个映射对象执行操作。在此示例中，`Consumer` 对象是一个 lambda 表达式，用于输出字符串，该字符串是 `Function` 对象返回的电子邮件地址。

您可以使用聚合操作替换每个操作。

**方法9：使用接受Lambda表达式作为参数的聚合操作**

以下示例使用聚合操作来打印有资格获得选择性服务的集合 `roster` 中包含的成员的电子邮件地址：

```java
roster
    .stream()
    .filter(
        p -> p.getGender() == Person.Sex.MALE
            && p.getAge() >= 18
            && p.getAge() <= 25)
    .map(p -> p.getEmailAddress())
    .forEach(email -> System.out.println(email));
```

下表将方法 `processElements` 执行的每个操作映射到相应的聚合操作：

| `processElements` Action    | Aggregate Operation                      |
| --------------------------- | ---------------------------------------- |
| 获取对象的源                      | `Stream<E> stream ()`                    |
| 过滤匹配到 `Predicate` 的对象       | `Stream<T> filter(Predicate<? super T> predicate)` |
| 将对象映射到 `Function` 对象指定的另一个值 | `<R> Stream<R> map(Function<? super T,? extends R> mapper)` |
| 执行一个由 `Consumer` 指定的操作      | `void forEach(Consumer<? super T> action)` |

操作 `filter`，`map` 和 `forEach` 是*聚合操作*。聚合操作处理流中的元素，而不是直接来自集合（这是在此示例中调用的第一个方法是 `stream` 的原因）。流是一系列元素。与集合不同，它不是存储元素的数据结构。相反，流通过管道携带来自源（例如集合）的值。*管道*是一系列流操作，在此示例中为 `filter-map-forEach` 。此外，聚合操作通常接受 lambda 表达式作为参数，使您可以自定义它们的行为方式。

关于聚合操作的完整讨论，参考 [Aggregate Operations](https://docs.oracle.com/javase/tutorial/collections/streams/index.html) 章节。

**GUI应用程序中的Lambda表达式**

要处理图形用户界面（GUI）应用程序中的事件（例如键盘操作，鼠标操作和滚动操作），通常会创建事件处理程序，这通常涉及实现特定接口。通常，事件处理程序接口是功能接口，他们往往只有一种方法。

在 JavaFX 示例 [`HelloWorld.java`](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) (在前面章节 [Anonymous Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html) 中讨论过)，你可以将匿名内部类替换为 lambda 表达式语句：

```java
        btn.setOnAction(new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                System.out.println("Hello World!");
            }
        });
```

方法调用 `btn.setOnAction` 指定当您选择 `btn` 对象表示的按钮时会发生什么。此方法需要 `EventHandler <ActionEvent>` 类型的对象。`EventHandler <ActionEvent>` 接口只包含一个方法，`void handle(T event)`。此接口是一个函数式接口，因此您可以使用以下突出显示的 lambda 表达式来替换它：

```java
        btn.setOnAction(
          event -> System.out.println("Hello World!")
        );
```

**Lambda表达式的语法**

一个 lambda 表达式由以下部分组成：

- 括号中用逗号分隔的形式参数列表。 `CheckPerson.test` 方法包含一个参数 `p` ，它表示 `thePerson` 类的一个实例。

  **注意**: 您可以省略 lambda 表达式中参数的数据类型。此外，如果只有一个参数，则可以省略括号。例如，以下 lambda 表达式也是有效的：

  ```java
  p -> p.getGender() == Person.Sex.MALE 
      && p.getAge() >= 18
      && p.getAge() <= 25
  ```

- 箭头符号 `->`

- 一个主体，由单个表达式或语句块组成。此示例使用以下表达式：

  ```java
  p.getGender() == Person.Sex.MALE 
      && p.getAge() >= 18
      && p.getAge() <= 25
  ```

  如果指定单个表达式，则Java运行时将计算表达式，然后返回其值。或者，您可以使用 `return` 语句：

  ```java
  p -> {
      return p.getGender() == Person.Sex.MALE
          && p.getAge() >= 18
          && p.getAge() <= 25;
  }
  ```

  `return` 语句不是表达式；在 lambda 表达式中，必须将语句括在大括号（{}）中。但是，您不必在大括号中包含 `void` 方法调用。例如，以下是有效的 lambda 表达式：

  ```java
  email -> System.out.println(email)
  ```

请注意，lambda 表达式看起来很像方法声明；您可以将 lambda 表达式视为匿名方法 - 没有名称的方法。

下面的例子 [`Calculator`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Calculator.java) ，是一个 lambda 表达式的示例，它采用多个形式参数：

```java
public class Calculator {
  
    interface IntegerMath {
        int operation(int a, int b);   
    }
  
    public int operateBinary(int a, int b, IntegerMath op) {
        return op.operation(a, b);
    }
 
    public static void main(String... args) {
    
        Calculator myApp = new Calculator();
        IntegerMath addition = (a, b) -> a + b;
        IntegerMath subtraction = (a, b) -> a - b;
        System.out.println("40 + 2 = " +
            myApp.operateBinary(40, 2, addition));
        System.out.println("20 - 10 = " +
            myApp.operateBinary(20, 10, subtraction));    
    }
}
```

方法 `operateBinary` 对两个整数操作数执行数学运算。操作本身由 `IntegerMath` 实例指定。该示例使用 lambda 表达式，加法和减法定义了两个操作。该示例打印以下内容：

```java
40 + 2 = 42
20 - 10 = 10
```

**访问外围作用域的局部变量**

像局部类和匿名类一样，lambda 表达式可以捕获变量；它们对封闭范围的局部变量具有相同的访问权限。但是，与局部类和匿名类不同，lambda 表达式没有任何遮蔽问题（有关更多信息，请参阅 [Shadowing](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing)  ）。Lambda 表达式是词法范围的。这意味着它们不会从超类继承任何名称或引入新级别的作用域。lambda 表达式中的声明与封闭环境中的声明一样被解释。以下示例 [`LambdaScopeTest`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LambdaScopeTest.java) 演示了这一点：

```java
import java.util.function.Consumer;

public class LambdaScopeTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            
            // The following statement causes the compiler to generate
            // the error "local variables referenced from a lambda expression
            // must be final or effectively final" in statement A:
            //
            // x = 99;
            
            Consumer<Integer> myConsumer = (y) -> 
            {
                System.out.println("x = " + x); // Statement A
                System.out.println("y = " + y);
                System.out.println("this.x = " + this.x);
                System.out.println("LambdaScopeTest.this.x = " +
                    LambdaScopeTest.this.x);
            };

            myConsumer.accept(x);

        }
    }

    public static void main(String... args) {
        LambdaScopeTest st = new LambdaScopeTest();
        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}
```

程序输出：

```shell
x = 23
y = 23
this.x = 1
LambdaScopeTest.this.x = 0
```

如果在 lambda 表达式 `myConsumer` 的声明中用参数 `x` 代替 `y`，则编译器会生成错误：

```java
Consumer<Integer> myConsumer = (x) -> {
    // ...
}
```

编译器生成错误 “variable x is already defined in method methodInFirstLevel(int)” ，因为 lambda 表达式不会引入新的作用域级别。因此，您可以直接访问封闭范围的字段，方法和局部变量。例如，lambda 表达式直接访问 `methodInFirstLevel` 方法的参数 `x` 。要访问封闭类中的变量，请使用关键字 `this` 。在此示例中，`this.x` 引用成员变量 `FirstLevel.x` 。

但是，与局部类和匿名类一样，lambda 表达式只能访问最终或最终等效的封闭块的局部变量和参数。例如，假设您在`methodInFirstLevel` 定义语句之后立即添加以下赋值语句：

```java
void methodInFirstLevel(int x) {
    x = 99;
    // ...
}
```

由于这个赋值语句，变量 `FirstLevel.x` 不再是等效 `final` 的。因此，Java编译器生成类似于 “local variables referenced from a lambda expression must be final or effectively final” 的错误消息，其中 lambda 表达式 `myConsumer` 尝试访问 `FirstLevel.x` 变量：

```java
System.out.println("x = " + x);
```

**目标类型**

你如何确定一个 lambda 表达式的类型？回想选择年龄在 18 到 25 岁之间的男性会员的 lambda 表达式：

```java
p -> p.getGender() == Person.Sex.MALE
    && p.getAge() >= 18
    && p.getAge() <= 25
```

该 lambda 表达式使用在下面两个方法中：

- `public static void printPersons(List<Person> roster, CheckPerson tester)` in [方法3：在局部类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3)
- `public void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester)` in [方法6：将标准函数式接口与Lambda表达式一起使用](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach6)

当Java运行时调用方法`printPersons`时，它期望数据类型为`CheckPerson`，因此lambda表达式属于这种类型。但是，当Java运行时调用方法`printPersonsWithPredicate`时，它期望数据类型为`Predicate <Person>`，因此lambda表达式属于这种类型。这些方法所期望的数据类型称为*目标类型*。要确定lambda表达式的类型，Java编译器将使用发现lambda表达式的上下文或情境的目标类型。因此，您只能在Java编译器可以确定目标类型的情况下使用lambda表达式：

- 变量声明
- 赋值
- 返回语句
- 数组初始化器
- 方法或者构造器函数
- Lambda 表达式主体
- 条件表达式， `?:`
- 转换表达式

**目标类型和方法参数**

对于方法参数，Java编译器使用另外两种语言特性确定目标类型：重载解析和类型参数推断。

考虑下面的两个函数式接口 ( [`java.lang.Runnable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html) 和 [`java.util.concurrent.Callable`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html))：

```java
public interface Runnable {
    void run();
}

public interface Callable<V> {
    V call();
}
```

方法 `Runnable.run` 不返回值，但是 `Callable<V>.call` 返回值。

假定你已经重载了方法 `invoke` 如下 (参考 [Defining Methods](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html) 获取更多方法重载的信息)：

```java
void invoke(Runnable r) {
    r.run();
}

<T> T invoke(Callable<T> c) {
    return c.call();
}
```

下面的语句调用的是哪个方法？

```java
String s = invoke(() -> "done");
```

将调用方法`invoke(Callable <T>)`，因为该方法返回一个值；方法`invoke(Runnable)`没有。在这种情况下，lambda表达式`() - >“done”`的类型是`Callable <T>`。

**序列化**

You can [serialize](https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html) a lambda expression if its target type and its captured arguments are serializable. However, like [inner classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#serialization), the serialization of lambda expressions is strongly discouraged.

你可以 [序列化](https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html) 一个 lambda 表达式，如果它的目标类型和它捕获的参数是可以序列化的。不过，类似于 [inner classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#serialization) ，我们并不推荐对 lambda 表达式进行序列化。

##### 方法引用

你使用 [lambda expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 来创建匿名方法。不过，有时候 lambda 表达式仅仅只是调用一个现成的方法。这些场景下，通常可以很清楚地用方法名称表示现有的方法。方法引用使得你可以这么做。它们是紧凑的、容易阅读的关于拥有名称的方法的 lambda 表达式。

再次考虑在 [Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 章节中讨论过的 [`Person`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Person.java) 类：

```java
public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }
    
    public Calendar getBirthday() {
        return birthday;
    }    

    public static int compareByAge(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }}
```

Suppose that the members of your social networking application are contained in an array, and you want to sort the array by age. You could use the following code (find the code excerpts described in this section in the example [`MethodReferencesTest`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/MethodReferencesTest.java)):

假设您的社交网络应用程序的成员包含在一个数组中，并且您希望按年龄对数组进行排序。您可以使用以下代码（查找示例 [`MethodReferencesTest`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/MethodReferencesTest.java) 中本节中描述的代码摘录）：

```java
Person[] rosterAsArray = roster.toArray(new Person[roster.size()]);

class PersonAgeComparator implements Comparator<Person> {
    public int compare(Person a, Person b) {
        return a.getBirthday().compareTo(b.getBirthday());
    }
}
        
Arrays.sort(rosterAsArray, new PersonAgeComparator());
```

这个 `sort` 调用的方法签名如下：

```java
static <T> void sort(T[] a, Comparator<? super T> c)
```

Notice that the interface `Comparator` is a functional interface. Therefore, you could use a lambda expression instead of defining and then creating a new instance of a class that implements `Comparator`:

请注意，接口`Comparator`是一个函数式接口。因此，您可以使用 lambda 表达式而不是定义然后创建实现`Comparator`的类的新实例：

```java
Arrays.sort(rosterAsArray,
    (Person a, Person b) -> {
        return a.getBirthday().compareTo(b.getBirthday());
    }
);
```

但是，这种比较两个`Person`实例的出生日期的方法已经存在为`Person.compareByAge`。您可以在lambda表达式的主体中调用此方法：

```java
Arrays.sort(rosterAsArray,
    (a, b) -> Person.compareByAge(a, b)
);
```

因为此lambda表达式调用现有方法，所以可以使用方法引用而不是lambda表达式：

```java
Arrays.sort(rosterAsArray, Person::compareByAge);
```

方法引用`Person :: compareByAge`在语义上与lambda表达式`（a，b） - > Person.compareByAge（a，b）`相同。每个都有以下特点：

 - 它的形式参数列表是从`Comparator <Person> .compare`复制的，它是`（Person，Person）`。
 - 它的主体调用方法`Person.compareByAge`。

**方法引用种类**

方法引用有四种：

| Kind                                     | Example                                |
| ---------------------------------------- | -------------------------------------- |
| Reference to a static method             | `ContainingClass::staticMethodName`    |
| Reference to an instance method of a particular object | `containingObject::instanceMethodName` |
| Reference to an instance method of an arbitrary object of a particular type | `ContainingType::methodName`           |
| Reference to a constructor               | `ClassName::new`                       |

**静态方法引用**

 `Person::compareByAge` 就是一个静态方法引用。

**特定对象实例方法的引用**

例子：

```java
class ComparisonProvider {
    public int compareByName(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
        
    public int compareByAge(Person a, Person b) {
        return a.getBirthday().compareTo(b.getBirthday());
    }
}
ComparisonProvider myComparisonProvider = new ComparisonProvider();
Arrays.sort(rosterAsArray, myComparisonProvider::compareByName);
```

方法引用`myComparisonProvider :: compareByName`调用方法`compareByName`，它是对象`myComparisonProvider`的一部分。JRE推断出方法类型参数，在本例中是`（Person，Person）`。

**特定类型任意对象的实例方法引用**

例子：

```java
String[] stringArray = { "Barbara", "James", "Mary", "John",
    "Patricia", "Robert", "Michael", "Linda" };
Arrays.sort(stringArray, String::compareToIgnoreCase);
```

方法引用`String :: compareToIgnoreCase`的等效lambda表达式将具有形式参数列表`（String a，String b）`，其中`a`和`b`是用于更好地描述此示例的任意名称。方法引用将调用方法`a.compareToIgnoreCase（b）`。

**构造器引用**

您可以使用名称`new`以与静态方法相同的方式引用构造函数。 以下方法将元素从一个集合复制到另一个集合：

```java
public static <T, SOURCE extends Collection<T>, DEST extends Collection<T>>
    DEST transferElements(
        SOURCE sourceCollection,
        Supplier<DEST> collectionFactory) {
        
        DEST result = collectionFactory.get();
        for (T t : sourceCollection) {
            result.add(t);
        }
        return result;
}
```

函数式接口`Supplier`包含一个不带参数的`get`方法并返回一个对象。因此，您可以使用lambda表达式调用方法`transferElements`，如下所示：

```java
Set<Person> rosterSetLambda =
    transferElements(roster, () -> { return ；new HashSet<>(); });
```

你可以如下使用构造器引用替换其中的 lambda 表达式：

```java
Set<Person> rosterSet = transferElements(roster, HashSet::new);
```

Java编译器推断您要创建一个包含`Person`类型元素的`HashSet`集合。或者，您可以按如下方式指定：

```java
Set<Person> rosterSet = transferElements(roster, HashSet<Person>::new);
```

##### 何时使用嵌套类、局部类、匿名类或者 lambda 表达式

如 [嵌套类](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html) 一节所述，嵌套类使您能够对仅在一个地方使用的类进行逻辑分组，增加封装的使用，并创建更易读和可维护的代码。局部类，匿名类和 lambda 表达式也具有这些优点;但是，它们旨在用于更具体的情况：

*  [局部类](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html) ：如果您需要创建多个类的实例，访问其构造函数或引入新的命名类型（例如，您需要稍后调用其他方法），请使用它。
* [匿名类](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)：如果需要声明字段或其他方法，请使用它。
* [Lambda 表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) ：
  *  如果要封装要传递给其他代码的单个行为单元，请使用它。例如，如果希望对集合的每个元素执行某个操作，完成进程或进程遇到错误，则可以使用lambda表达式。
  * 如果您需要一个简单的功能接口实例并且不应用任何前述条件（例如，您不需要构造函数，命名类型，字段或其他方法），请使用它。
* [嵌套类](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)：如果您的要求与本地类的要求类似，则使用它，您希望使类型更广泛可用，并且您不需要访问局部变量或方法参数。
  * 如果需要访问封闭实例的非公共字段和方法，请使用非静态嵌套类（或内部类）。如果不需要此访问权限，请使用静态嵌套类。

#### 枚举类型

*枚举类型*是一种特殊的数据类型，它使变量成为一组预定义的常量。变量必须等于为其预定义的值之一。常见示例包括罗盘方向（NORTH，SOUTH，EAST和WEST的值）和星期几。

因为它们都是常量，因此枚举类型字段名都是大写字母组成。

在 Java 语言中，你可以使用 `enum` 关键字来定义枚举类型。比如，你可以指定一个星期几枚举类型如下：

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY 
}
```

您需要在需要表示一组固定常量时使用枚举类型。这包括自然枚举类型，例如太阳系中的行星和数据集，您可以在编译时知道所有可能的值 - 例如，菜单上的选项，命令行标志等。

下面的代码向你展示如何使用上面定义的 `Day` 枚举类型：

```java
public class EnumTest {
    Day day;
    
    public EnumTest(Day day) {
        this.day = day;
    }
    
    public void tellItLikeItIs() {
        switch (day) {
            case MONDAY:
                System.out.println("Mondays are bad.");
                break;
                    
            case FRIDAY:
                System.out.println("Fridays are better.");
                break;
                         
            case SATURDAY: case SUNDAY:
                System.out.println("Weekends are best.");
                break;
                        
            default:
                System.out.println("Midweek days are so-so.");
                break;
        }
    }
    
    public static void main(String[] args) {
        EnumTest firstDay = new EnumTest(Day.MONDAY);
        firstDay.tellItLikeItIs();
        EnumTest thirdDay = new EnumTest(Day.WEDNESDAY);
        thirdDay.tellItLikeItIs();
        EnumTest fifthDay = new EnumTest(Day.FRIDAY);
        fifthDay.tellItLikeItIs();
        EnumTest sixthDay = new EnumTest(Day.SATURDAY);
        sixthDay.tellItLikeItIs();
        EnumTest seventhDay = new EnumTest(Day.SUNDAY);
        seventhDay.tellItLikeItIs();
    }
}
```

输出：

```shell
Mondays are bad.
Midweek days are so-so.
Fridays are better.
Weekends are best.
Weekends are best.
```

Java编程语言枚举类型比其他语言中的对应类型更强大。枚举声明定义了一个类（称为枚举类型）。枚举类主体可以包括方法和其他字段。编译器在创建枚举时会自动添加一些特殊方法。例如，它们具有静态 `values` 方法，该方法返回一个数组，该数组按照声明的顺序包含枚举的所有值。此方法通常与 for-each 构造结合使用，以迭代枚举类型的值。例如，下面 `Planet` 类示例中的代码迭代太阳系中的所有行星。

```java
for (Planet p : Planet.values()) {
    System.out.printf("Your weight on %s is %f%n",
                      p, p.surfaceWeight(mass));
}
```

------

**注意:** *所有*枚举类型隐含继承 `java.lang.Enum`。由于一个类只能有一个父类（参考 [Declaring Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html)），Java 语言不支持多继承状态 (参考 [多继承状态，实现以及类型](https://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.html))，因此枚举类不能扩展任何其它内容。

------

在以下示例中，`Planet` 是一种枚举类型，表示太阳系中的行星。它们具有恒定的质量和半径属性。

每个枚举常量都声明为质量和半径参数的值。创建常量时，这些值将传递给构造函数。 Java要求在任何字段或方法之前首先定义常量。此外，当存在字段和方法时，枚举常量列表必须以分号结尾。

------

**注意：**枚举类型的构造函数必须是包私有或私有访问。 它会自动创建在枚举主体开头定义的常量。 您不能自己调用枚举构造函数。

------

除了它的属性和构造函数之外，`Planet` 还有一些方法可以让您检索每个行星上物体的表面重力和重量。这是一个示例程序，它可以减轻地球上的重量（以任何单位）并计算并打印所有行星上的重量（以同一单位）：

```java
public enum Planet {
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }

    // universal gravitational constant  (m3 kg-1 s-2)
    public static final double G = 6.67300E-11;

    double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    double surfaceWeight(double otherMass) {
        return otherMass * surfaceGravity();
    }
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java Planet <earth_weight>");
            System.exit(-1);
        }
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight/EARTH.surfaceGravity();
        for (Planet p : Planet.values())
           System.out.printf("Your weight on %s is %f%n",
                             p, p.surfaceWeight(mass));
    }
}
```

如果从命令行运行 `Planet.class`，参数为175，则会得到以下输出：

```shell
$ java Planet 175
Your weight on MERCURY is 66.107583
Your weight on VENUS is 158.374842
Your weight on EARTH is 175.000000
Your weight on MARS is 66.279007
Your weight on JUPITER is 442.847567
Your weight on SATURN is 186.552719
Your weight on URANUS is 158.397260
Your weight on NEPTUNE is 199.207413
```

# 注解

*注解* ，一种元数据形式，提供有关不属于程序本身的程序的数据。注解对它们修饰的代码的操作没有直接影响。

注解有许多用途，其中包括：

* **给编译器的信息**- 编译器可以使用注解来检测错误或抑制警告。
* **编译期和部署时处理** - 软件工具可以处理注解信息以生成代码，XML文件等。
* **运行时处理** - 可以在运行时检查某些注解。

本课程介绍了可以使用注解的位置，如何应用注解，Java平台，标准版（Java SE API）中可用的预定义注解类型，类型注解如何与可插拔类型系统结合使用以编写更强大的代码类型检查，以及如何实现可重复注解。

