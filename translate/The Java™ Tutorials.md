# Java™教程

[主页](https://docs.oracle.com/javase/tutorial/index.html)

## Java教程学习路径

> Java教程是为JDK 8编写的。本页描述的示例和实践没有利用后续版本中引入的改进。

## 入门

- [入门](https://docs.oracle.com/javase/tutorial/getStarted/index.html) - 介绍Java技术和安装Java开发软件并使用它来创建简单程序的课程。
- [学习Java语言](https://docs.oracle.com/javase/tutorial/java/index.html) - 描述基本概念（如类，对象，继承，数据类型，泛型和包）的课程。
- [基本Java类](https://docs.oracle.com/javase/tutorial/essential/index.html) - 有关异常，基本输入/输出，并发，正则表达式和平台环境的课程。

## 基础

- [集合](https://docs.oracle.com/javase/tutorial/collections/index.html) - 使用和扩展Java集合框架的经验教训。
- [Lambda表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)：了解如何以及为何在应用程序中使用Lambda表达式。
- [聚合操作](https://docs.oracle.com/javase/tutorial/collections/streams/index.html)：探索聚合操作，流和Lambda表达式如何协同工作以提供强大的过滤功能。
- [JAR文件中的打包程序](https://docs.oracle.com/javase/tutorial/deployment/jar/index.html) - 有关创建和签署JAR文件的课程。
- [国际化](https://docs.oracle.com/javase/tutorial/i18n/index.html) - 设计软件的介绍，以便可以轻松地适应（本地化）各种语言和区域。
- [反射](https://docs.oracle.com/javase/tutorial/reflect/index.html) - 表示（“反映”）当前Java虚拟机中的类，接口和对象的API。
- [安全性](https://docs.oracle.com/javase/tutorial/security/index.html) - Java平台功能，有助于保护应用程序免受恶意软
- [JavaBeans](https://docs.oracle.com/javase/tutorial/javabeans/index.html) - Java平台的组件技术。
- [扩展机制](https://docs.oracle.com/javase/tutorial/ext/index.html) - 如何使Java平台上运行的所有应用程序都可以使用自定义API。
- [泛型](https://docs.oracle.com/javase/tutorial/extra/generics/index.html) - 对类型系统的增强，支持对各种类型的对象的操作，同时提供编译时类型安全性。

## 客户端开发

- [JavaFX入门](http://www.oracle.com/pls/topic/lookup?ctx=javase80&id=JFXST804) - 一组示例应用程序，旨在帮助您开始使用常见的JavaFX任务
- [Scene Builder入门](http://www.oracle.com/pls/topic/lookup?ctx=javase80&id=JSBGS101) - 逐步向您展示如何使用JavaFX Scene Builder工具创建简单的问题跟踪应用程序。
- [使用Swing创建GUI](https://docs.oracle.com/javase/tutorial/uiswing/index.html) - 全面介绍Java平台上的GUI创建。
- [部署](https://docs.oracle.com/javase/tutorial/deployment/index.html) - 如何使用JAR文件打包应用程序和applet，并使用Java Web Start和Java Plug-in进行部署。
- [2D图形](https://docs.oracle.com/javase/tutorial/2d/index.html) - 如何在应用程序中显示和打印2D图形。
- [全屏独占模式API](https://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html) - 如何编写更充分利用用户图形硬件的应用程序。

## 服务端开发

- [JDBC数据库访问](https://docs.oracle.com/javase/tutorial/jdbc/index.html) - 介绍用于Java应用程序与各种数据库和数据源之间的连接的API。
- [JMX](https://docs.oracle.com/javase/tutorial/jmx/index.html) - Java Management Extensions提供了一种管理应用程序，设备和服务等资源的标准方法。
- [JNDI](https://docs.oracle.com/javase/tutorial/jndi/index.html) - Java命名和目录接口支持访问DNS和LDAP等命名和目录服务。
- [JAXP](https://docs.oracle.com/javase/tutorial/jaxp/index.html) - 介绍用于XML处理的Java API（JAXP）1.4技术。
- [RMI](https://docs.oracle.com/javase/tutorial/rmi/index.html) - 远程方法调用API允许对象调用在另一个Java虚拟机上运行的对象的方法。
- [并发](https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html) - Java平台具有API，可帮助您开发多线程程序。

# 入门

这一部分提供了有关Java编程语言入门的所有知识。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/getStartedIcon.gif)**Java技术现象**](https://docs.oracle.com/javase/tutorial/getStarted/intro/index.html)提供Java技术的整体概述。它讨论了Java编程语言和平台，提供了该技术可以做什么以及如何使您的生活更轻松的广泛概述。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/getStartedIcon.gif)**“Hello World！” 应用程序**](https://docs.oracle.com/javase/tutorial/getStarted/cupojava/index.html)这种实用的方法描述了创建简单的“Hello World！”的下载内容，安装内容和输入内容。应用。它为NetBeans™集成开发环境（NetBeans IDE），Microsoft Windows，Solaris™操作系统（Solaris OS），Linux和Mac用户提供单独的说明。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/getStartedIcon.gif)**仔细看看“Hello World！”** ](https://docs.oracle.com/javase/tutorial/getStarted/application/index.html)讨论“Hello World！” 应用程序，详细描述每段代码。它包括源代码注释，`HelloWorldApp`类定义块和`main`方法。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/getStartedIcon.gif)**常见问题（及其解决方案）**](https://docs.oracle.com/javase/tutorial/getStarted/problems/index.html)如果您在此路径中编译或运行程序时遇到问题，那么这就是您要去的地方。

## Java技术现象

谈论Java技术似乎无处不在，但究竟是什么呢？以下部分解释了Java技术如何既是编程语言又是平台，并概述了该技术可以为您做什么。

- [关于Java技术](https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html)
- [Java技术可以做什么？](https://docs.oracle.com/javase/tutorial/getStarted/intro/cando.html)
- [Java技术将如何改变我的生活？](https://docs.oracle.com/javase/tutorial/getStarted/intro/changemylife.html)

### 关于Java技术

Java技术既是一种编程语言，也是一种平台。

**Java编程语言**

Java编程语言是一种高级语言，可以通过以下所有流行语来表征：

- 简单
- 面向对象
- 分布式
- 多线程
- 动态
- 架构中立
- 可移植
- 高性能
- 鲁棒性
- 安全

前面的每个流行语都在[*Java语言环境*](http://www.oracle.com/technetwork/java/langenv-140151.html)中进行了解释， 它是由James Gosling和Henry McGilton编写的白皮书。

在Java编程语言中，所有源代码首先以用`.java`扩展名结尾的纯文本文件编写。然后，编译器将这些源文件编译成`.class`文件`javac`。一个`.class`文件不包含的代码是原产于你的处理器; 它包含*字节码* - Java虚拟机[1](https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html#FOOT)（Java VM）的机器语言。然后，`java`启动器工具使用Java虚拟机实例运行应用程序。

![image-20190504114539193](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504114539193.png)

由于Java VM可用于许多不同的操作系统，因此相同的`.class`文件能够在Microsoft Windows，Solaris™操作系统（Solaris OS），Linux或Mac OS上运行。某些虚拟机（例如 [Java SE HotSpot概览）会](http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136373.html)在运行时执行其他步骤，从而为您的应用程序提供性能提升。这包括各种任务，例如查找性能瓶颈和重新编译（对本机代码）经常使用的代码段。

![image-20190504114555283](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504114555283.png)

**Java平台**

一个*平台*是在程序运行的硬件或软件环境。我们已经提到了一些最受欢迎的平台，如Microsoft Windows，Linux，Solaris OS和Mac OS。大多数平台可以描述为操作系统和底层硬件的组合。Java平台与大多数其他平台的不同之处在于，它是一个纯软件平台，可以在其他基于硬件的平台上运行。

Java平台有两个组件：

- 在*Java虚拟机*
- 在*Java应用程序编程接口*（API）

您已经了解了Java虚拟机; 它是Java平台的基础，并移植到各种基于硬件的平台上。

API是大量现成的软件组件，提供许多有用的功能。它被分为相关类和接口的库; 这些库称为*包*。下一节， [Java Technology可以做什么？](https://docs.oracle.com/javase/tutorial/getStarted/intro/cando.html)重点介绍了API提供的一些功能。

![image-20190504114610831](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504114610831.png)

作为独立于平台的环境，Java平台可能比本机代码慢一点。但是，编译器和虚拟机技术的进步使性能接近本机代码的性能而不会威胁到可移植性。

术语“Java虚拟机”和“JVM”表示Java平台的虚拟机。

### Java技术可以做什么？

通用的高级Java编程语言是一个功能强大的软件平台。Java平台的每个完整实现都为您提供以下功能：

- **开发工具**：开发工具提供编译，运行，监视，调试和记录应用程序所需的一切。作为一名新开发人员，您将使用的主要工具是`javac`编译器，`java`启动器和`javadoc`文档工具。
- **应用程序编程接口（API）**：API提供Java编程语言的核心功能。它提供了各种有用的类，可以在您自己的应用程序中使用。它涵盖了从基本对象到网络和安全性，XML生成和数据库访问等所有内容。核心API非常大; 要了解它包含的内容，请参阅 [Java平台标准版8文档](https://docs.oracle.com/javase/8/docs/index.html)。
- **部署技术**：JDK软件提供标准机制，例如Java Web Start软件和Java Plug-In软件，用于将应用程序部署到最终用户。
- **用户界面工具包**：JavaFX，Swing和Java 2D工具包可以创建复杂的图形用户界面（GUI）。
- **集成库**：集成库，例如Java IDL API，JDBC API，Java命名和目录接口（JNDI）API，Java RMI和基于Internet的ORB间协议技术的Java远程方法调用（Java RMI-IIOP技术），支持数据库访问和远程对象的操纵。

### Java技术将如何改变我的生活？

如果你学习Java编程语言，我们不能保证你的名声，财富甚至是工作。尽管如此，它可能会使您的程序更好，并且比其他语言需要更少的工作量。我们相信Java技术将帮助您执行以下操作：

- **快速入门**：尽管Java编程语言是一种功能强大的面向对象语言，但它易于学习，特别是对于已经熟悉C或C ++的程序员。
- **编写更少的代码**：程序指标（类计数，方法计数等）的比较表明，用Java编程语言编写的程序可以比用C ++编写的相同程序小四倍。
- **编写更好的代码**：Java编程语言鼓励良好的编码实践，自动垃圾收集可以帮助您避免内存泄漏。它的面向对象，JavaBeans™组件架构及其广泛，易于扩展的API使您可以重用现有的，经过测试的代码并减少错误。
- **更快地开发程序**：Java编程语言比C ++更简单，因此，在编写时，您的开发时间可能快两倍。您的程序还需要更少的代码行。
- **避免平台依赖**：您可以通过避免使用其他语言编写的库来保持程序的可移植性。
- **编写一次，随处运行**：因为用Java编程语言编写的应用程序被编译成与机器无关的字节码，所以它们在任何Java平台上都能一致地运行。
- **更轻松地分发软件**：使用Java Web Start软件，用户只需单击鼠标即可启动应用程序。启动时的自动版本检查可确保用户始终了解最新版本的软件。如果有可用更新，Java Web Start软件将自动更新其安装。

# 学习Java语言

该路径涵盖了Java编程语言中编程的基础知识。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**面向对象的编程概念**](https://docs.oracle.com/javase/tutorial/java/concepts/index.html)向您介绍[**面向对象编程**](https://docs.oracle.com/javase/tutorial/java/concepts/index.html)背后的核心概念：对象，消息，类和继承。本课程将向您展示这些概念如何转化为代码。如果您已熟悉面向对象的编程，请随意跳过本课程。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**语言基础知识**](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html)描述了[**语言**](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html)的传统特性，包括变量，数组，数据类型，运算符和控制流。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**类和对象**](https://docs.oracle.com/javase/tutorial/java/javaOO/index.html)描述了如何编写从中创建对象的类，以及如何创建和使用对象。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**注释**](https://docs.oracle.com/javase/tutorial/java/annotations/index.html)是元数据的一种形式，为编译器提供信息。本课程描述了在程序中有效使用注释的位置和方法。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**接口和继承**](https://docs.oracle.com/javase/tutorial/java/IandI/index.html)描述了接口 - 它们是什么，为什么要编写接口，以及如何编写接口。本节还介绍了从另一个类派生一个类的方法。也就是说，*子类*如何从*超类*继承字段和方法。您将了解到所有类都是从类派生的`Object`，以及如何修改子类从超类继承的方法。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**数字和字符串**](https://docs.oracle.com/javase/tutorial/java/data/index.html)本课程介绍如何使用`Number`和`String`对象本课程还介绍如何格式化输出数据。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**泛型**](https://docs.oracle.com/javase/tutorial/java/generics/index.html)是Java编程语言的强大功能。它们可以提高代码的类型安全性，使您可以在编译时检测到更多错误。

[![小道图标](https://docs.oracle.com/javase/tutorial/images/javaIcon.gif)**包**](https://docs.oracle.com/javase/tutorial/java/package/index.html)是Java编程语言的一个特性，它可以帮助您组织和构建类及其相互之间的关系。

## 面向对象的编程概念

如果您以前从未使用过面向对象的编程语言，那么在开始编写任何代码之前，您需要学习一些基本概念。本课将向您介绍对象，类，继承，接口和包。每个讨论都关注这些概念如何与现实世界相关，同时介绍Java编程语言的语法。

* [什么是对象？](https://docs.oracle.com/javase/tutorial/java/concepts/object.html)

对象是相关状态和行为的软件包。软件对象通常用于模拟您在日常生活中发现的真实世界对象。本课程解释了如何在对象中表示状态和行为，介绍数据封装的概念，并解释以这种方式设计软件的好处。

* [什么是类？](https://docs.oracle.com/javase/tutorial/java/concepts/class.html)

类是创建对象的蓝图或原型。本节定义了一个模拟现实世界对象的状态和行为的类。它故意专注于基础知识，展示一个简单的类如何能够清晰地模拟状态和行为。

* [什么是继承？](https://docs.oracle.com/javase/tutorial/java/concepts/inheritance.html)

继承为组织和构建软件提供了强大而自然的机制。本节介绍了类如何从超类继承状态和行为，并解释了如何使用Java编程语言提供的简单语法从另一个类派生一个类。

* [什么是接口？](https://docs.oracle.com/javase/tutorial/java/concepts/interface.html)

接口是一个类和外部世界之间的契约。当类实现接口时，它承诺提供该接口发布的行为。本节定义了一个简单的接口，并解释了实现它的任何类的必要更改。

* [什么是包？](https://docs.oracle.com/javase/tutorial/java/concepts/package.html)

包是用于以逻辑方式组织类和接口的命名空间。将代码放入包中可以使大型软件项目更易于管理。本节解释了这有用的原因，并向您介绍Java平台提供的应用程序编程接口（API）。

* [问题与练习：面向对象的编程概念](https://docs.oracle.com/javase/tutorial/java/concepts/QandE/questions.html)

使用本节中提供的问题和练习来测试您对对象，类，继承，接口和包的理解

### 什么是对象？

对象是理解*面向对象*技术的关键。现在环顾四周，你会发现许多真实物体的例子：你的狗，你的桌子，你的电视机，你的自行车。

真实世界的对象共享两个特征：它们都具有*状态*和*行为*。狗有状态（名称，颜色，品种，饥饿）和行为（吠叫，取出，摇尾）。自行车还具有状态（当前档位，当前踏板节奏，当前速度）和行为（改变档位，改变踏板节奏，应用制动器）。识别真实世界对象的状态和行为是开始思考面向对象编程的好方法。

现在花点时间观察您附近区域的真实物体。对于您看到的每个对象，请问自己两个问题：“这个对象可能存在哪些状态？” 和“这个对象可以执行什么样的行为？”。一定要记下你的观察结果。和你一样，你会发现现实世界的物体的复杂程度各不相同; 您的桌面灯可能只有两种可能的状态（打开和关闭）和两种可能的行为（打开，关闭），但您的桌面电台可能有其他状态（开，关，当前音量，当前电台）和行为（打开） ，关闭，增加音量，减少音量，搜索，扫描和调整）。您可能还会注意到，某些对象反过来也会包含其他对象。这些现实世界的观察都转化为面向对象编程的世界。

![image-20190504120734194](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504120734194.png)

软件对象在概念上类似于现实世界的对象：它们也包括状态和相关行为。对象将其状态存储在*字段*（某些编程语言中的变量）中，并通过*方法*（某些编程语言中的函数）公开其行为。方法对对象的内部状态进行操作，并作为对象到对象通信的主要机制。隐藏内部状态并要求通过对象的方法执行所有交互称为*数据封装* - 面向对象编程的基本原则。

考虑一下自行车，例如：

![image-20190504120757739](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504120757739.png)

通过归因于状态（当前速度，当前踏板节奏和当前档位）并提供改变该状态的方法，该对象仍然控制外部世界如何被允许使用它。例如，如果自行车仅具有6个档位，则换档的方法可以拒绝小于1或大于6的任何值。

将代码捆绑到单个软件对象中可带来许多好处，包括：

1. 模块化：可以独立于其他对象的源代码编写和维护对象的源代码。一旦创建，对象就可以轻松地在系统内部传递。
2. 信息隐藏：通过仅与对象的方法交互，其内部实现的细节仍然隐藏在外部世界之外。
3. 代码重用：如果对象已存在（可能由其他软件开发人员编写），则可以在程序中使用该对象。这允许专家实现/测试/调试复杂的，特定于任务的对象，然后您可以信任这些对象在您自己的代码中运行。
4. 可插拔性和调试简便性：如果某个特定对象有问题，您只需将其从应用程序中删除，然后插入另一个对象作为替代对象。这类似于解决现实世界中的机械问题。如果螺栓断裂，则更换*它*，而不是整个机器。

### 什么是类？

在现实世界中，您经常会发现许多相同类型的单个对象。可能存在数千种其他自行车，所有相同的品牌和型号。每辆自行车都是使用相同的蓝图构建的，因此包含相同的组件。在面向对象的术语，我们说你的自行车是一个*实例*中的*类的对象*被称为自行车。一*类*是从中创建单个对象的蓝图。

以下 [`Bicycle`](https://docs.oracle.com/javase/tutorial/java/concepts/examples/Bicycle.java)类是自行车的一种可能实现：

````java
class Bicycle {

    int cadence = 0;
    int speed = 0;
    int gear = 1;

    void changeCadence(int newValue) {
         cadence = newValue;
    }

    void changeGear(int newValue) {
         gear = newValue;
    }

    void speedUp(int increment) {
         speed = speed + increment;   
    }

    void applyBrakes(int decrement) {
         speed = speed - decrement;
    }

    void printStates() {
         System.out.println("cadence:" +
             cadence + " speed:" + 
             speed + " gear:" + gear);
    }
}
````

Java编程语言的语法对您来说很新，但这个类的设计基于之前对自行车对象的讨论。的字段`cadence`，`speed`和`gear`表示该对象的状态，并且这些方法（`changeCadence`，`changeGear`，`speedUp`等）限定与外部世界的相互作用。

您可能已经注意到`Bicycle`该类不包含`main`方法。那是因为它不是一个完整的应用程序; 它只是可能在应用程序中*使用的*自行车蓝图。创建和使用新`Bicycle`对象的责任属于应用程序中的其他类。

这是一个 [`BicycleDemo`](https://docs.oracle.com/javase/tutorial/java/concepts/examples/BicycleDemo.java)创建两个独立`Bicycle`对象并调用其方法的类：

````java
class BicycleDemo {
    public static void main(String[] args) {

        // Create two different 
        // Bicycle objects
        Bicycle bike1 = new Bicycle();
        Bicycle bike2 = new Bicycle();

        // Invoke methods on 
        // those objects
        bike1.changeCadence(50);
        bike1.speedUp(10);
        bike1.changeGear(2);
        bike1.printStates();

        bike2.changeCadence(50);
        bike2.speedUp(10);
        bike2.changeGear(2);
        bike2.changeCadence(40);
        bike2.speedUp(10);
        bike2.changeGear(3);
        bike2.printStates();
    }
}
````

此测试的输出打印两辆自行车的结束踏板节奏，速度和档位：

````shell
cadence:50 speed:10 gear:2
cadence:40 speed:20 gear:3
````

### 什么是继承？

不同种类的物体通常彼此具有一定的共同量。例如，山地自行车，公路自行车和双人自行车都具有自行车的特性（当前速度，当前踏板节奏，当前档位）。然而，每个还定义了使它们与众不同的其他功能：双人自行车有两个座位和两套车把; 公路自行车有把手下降; 一些山地自行车有一个额外的链环，使它们的齿轮比更低。

面向对象编程允许类*继承*其他类中常用的状态和行为。在这个例子中，`Bicycle`现在变成了*父*的`MountainBike`，`RoadBike`和`TandemBike`。在Java编程语言中，允许每个类具有一个直接超类，并且每个超类都有可能存在无限数量的*子类*：

![image-20190504121528340](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504121528340.png)

创建子类的语法很简单。在类声明的开头，使用`extends`关键字，后跟要继承的类的名称：

````java
class MountainBike extends Bicycle {

    // new fields and methods defining 
    // a mountain bike would go here

}
````

这提供了`MountainBike`所有相同的字段和方法`Bicycle`，但允许其代码专注于使其独特的功能。这使您的子类代码易于阅读。但是，您必须注意正确记录每个超类定义的状态和行为，因为该代码不会出现在每个子类的源文件中。

### 什么是接口？

正如您已经了解的那样，对象通过它们公开的方法定义它们与外部世界的交互。方法形成对象与外界的*界面* ; 例如，电视机正面的按钮是您与塑料外壳另一侧电线之间的接口。按“电源”按钮打开和关闭电视。

在最常见的形式中，接口是一组具有空体的相关方法。自行车的行为（如果指定为界面）可能如下所示：

````java
interface Bicycle {

    //每分钟转数
    void changeCadence（int newValue）;

    void changeGear（int newValue）;

    void speedUp（int increment）;

    void applyBrakes（int decrement）;
}
````

要实现此接口，您的类的名称将更改（例如，特定品牌的自行车`ACMEBicycle`），并且您将在类声明中使用````implements````关键字：

````java
class ACMEBicycle implements Bicycle {

    int cadence = 0;
    int speed = 0;
    int gear = 1;

   // The compiler will now require that methods
   // changeCadence, changeGear, speedUp, and applyBrakes
   // all be implemented. Compilation will fail if those
   // methods are missing from this class.

    void changeCadence(int newValue) {
         cadence = newValue;
    }

    void changeGear(int newValue) {
         gear = newValue;
    }

    void speedUp(int increment) {
         speed = speed + increment;   
    }

    void applyBrakes(int decrement) {
         speed = speed - decrement;
    }

    void printStates() {
         System.out.println("cadence:" +
             cadence + " speed:" + 
             speed + " gear:" + gear);
    }
}
````

实现接口允许类对其承诺提供的行为变得更加正式。接口在类和外部世界之间形成契约，并且该合同在构建时由编译器强制执行。如果您的类声称实现了一个接口，那么该接口定义的所有方法必须在其成功编译之前出现在其源代码中。

**注意：**  要实际编译`ACMEBicycle`该类，您需要将`public`关键字添加到已实现的接口方法的开头。稍后您将在有关[类和对象](https://docs.oracle.com/javase/tutorial/java/javaOO/index.html)以及 [接口和继承](https://docs.oracle.com/javase/tutorial/java/IandI/index.html)的课程中了解相关原因 。

### 什么是包？

包是一个命名空间，用于组织一组相关的类和接口。从概念上讲，您可以将包视为与计算机上的不同文件夹类似。您可以将HTML页面保留在一个文件夹中，将图像保存在另一个文件夹中，将脚本或应 因为用Java编程语言编写的软件可以由数百或*数千个*单独的类组成，所以通过将相关的类和接口放入包来保持组织是有意义的。

Java平台提供了一个巨大的类库（一组包），适合在您自己的应用程序中使用。该库称为“应用程序编程接口”，简称“API”。它的包代表了最常用于通用编程的任务。例如，`String`对象包含字符串的状态和行为; 一个`File`对象允许程序员轻松地创建，删除，检查，比较或修改文件系统上的文件; 一个`Socket`object允许创建和使用网络套接字; 各种GUI对象控制按钮和复选框以及与图形用户界面相关的任何其他内容。有数以千计的课程可供选择。这使程序员可以专注于特定应用程序的设计，而不是使其工作所需的基础结构。

在 [Java平台API规范](https://docs.oracle.com/javase/8/docs/api/index.html)包含了所有的包，接口，类，字段和Java SE平台提供的方法完整列表。在浏览器中加载页面并为其添加书签。作为程序员，它将成为您最重要的参考文档。

## 语言基础知识

* [ 变量](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html)

您已经了解到对象将其状态存储在字段中。但是，Java编程语言也使用术语“变量”。本节讨论此关系，变量命名规则和约定，基本数据类型（基本类型，字符串和数组），默认值和文字。

* [运算符](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)

本节介绍Java编程语言的运算符。它首先介绍了最常用的运算符，并且不常用的运算符持续存在。每个讨论都包含可以编译和运行的代码示例。

* [表达式，语句和块](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html)

运算符可用于构建计算值的表达式; 表达式是陈述的核心组成部分; 语句可以分组为块。本节讨论使用您已经看过的示例代码的表达式，语句和块。

* [控制流程语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)

本节介绍Java编程语言支持的控制流语句。它涵盖了决策制定，循环和分支语句，使您的程序能够有条件地执行特定的代码块。

### 变量

正如您在上一课中所了解到的，对象将其状态存储在*字段中*。

````java
int cadence = 0;
int speed = 0;
int gear = 1;
````

在 [什么是对象？](https://docs.oracle.com/javase/tutorial/java/concepts/object.html)讨论向您介绍了字段，但您可能还有一些问题，例如：命名字段的规则和约定是什么？此外`int`，还有哪些其他数据类型？在声明字段时是否必须初始化字段？如果未明确初始化字段，是否为字段分配了默认值？我们将在本课中探讨这些问题的答案，但在我们开始之前，您必须首先了解一些技术差异。在Java编程语言中，使用术语“字段”和“变量”; 这是新开发者之间混淆的常见原因，因为两者往往都是指同一件事。

Java编程语言定义了以下几种变量：

- **实例变量（非静态字段）**从技术上讲，对象将其各个状态存储在“非静态字段”中，即，不使用`static`关键字声明的字段。非静态字段也称为*实例变量，*因为它们的值对于类的每个*实例*是唯一的（换句话说，对于每个对象）; 的`currentSpeed`一个自行车的是独立于`currentSpeed`另一个。
- **类变量（静态字段）**甲*类变量*是与声明任何字段`static`改性剂; 这告诉编译器这个变量只有一个副本存在，无论该类被实例化多少次。定义特定种类的自行车的齿轮数的字段可以标记为`static`从概念上相同数量的齿轮将适用于所有实例。代码`static int numGears = 6;`将创建这样的静态字段。此外，`final`可以添加关键字以指示齿轮的数量永远不会改变。
- **局部变量**类似于对象如何在字段中存储其状态，方法通常会将其临时状态存储在*局部变量中*。声明局部变量的语法类似于声明字段（例如，`int count = 0;`）。没有特殊的关键字将变量指定为本地变量; 该决定完全来自声明变量的位置 - 它位于方法的开始和结束括号之间。因此，局部变量只对声明它们的方法可见; 他们无法从课堂上的其他人那里获得。
- **参数**您已经在“Hello World！” 的`Bicycle`类和`main`方法中看到过参数的示例。应用。回想一下该`main`方法的签名是`public static void main(String[] args)`。这里，`args`变量是此方法的参数。要记住的重要一点是参数总是被分类为“变量”而不是“字段”。这也适用于其他参数接受构造（例如构造函数和异常处理程序），您将在本教程后面学习。

话虽如此，本教程的其余部分在讨论字段和变量时使用以下一般准则。如果我们谈论的是“一般的字段”（不包括局部变量和参数），我们可以简单地说“字段”。如果讨论适用于“以上所有”，我们可以简单地说“变量”。如果上下文要求区分，我们将酌情使用特定术语（静态字段，局部变量等）。您也可能偶尔会看到使用“成员”一词。类型的字段，方法和嵌套类型统称为其*成员*。

**命名**

每种编程语言都有自己的规则和约定，适用于您允许使用的各种名称，Java编程语言也不例外。命名变量的规则和约定可归纳如下：

- 变量名称区分大小写。变量的名称可以是任何合法标识符 - Unicode字母和数字的无限长度序列，以字母，美元符号“ `$`”或下划线字符“ `_`” 开头。但是，惯例是始终用字母开头，而不是“ `$`”或“ `_`”。此外，按照惯例，美元符号字符根本不会被使用。您可能会发现某些情况，其中自动生成的名称将包含美元符号，但您的变量名称应始终避免使用它。对于下划线字符存在类似的约定; 虽然用“ `_`” 开始你的变量名称在技术上是合法的，但是这种做法是不鼓励的。不允许有空白区域。
- 后续字符可以是字母，数字，美元符号或下划线字符。约定（和常识）也适用于此规则。为变量选择名称时，请使用完整单词而不是隐藏缩写。这样做可以使您的代码更易于阅读和理解。在许多情况下，它还会使您的代码自我记录; 田命名`cadence`，`speed`和`gear`，例如，比缩写版本，如更直观`s`，`c`和`g`。另请注意，您选择的名称不得是 [关键字或保留字](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)。
- 如果您选择的名称只包含一个单词，则以全小写字母拼写该单词。如果它由多个单词组成，则将每个后续单词的首字母大写。名称`gearRatio`和`currentGear`是这个惯例的主要例子。如果您的变量存储一个常量值，例如`static final int NUM_GEARS = 6`，约定会略有变化，将每个字母大写并用后突字符分隔后续单词。按照惯例，下划线字符从未在别处使用过。

#### 原始数据类型

Java编程语言是静态类型的，这意味着必须首先声明所有变量才能使用它们。这包括声明变量的类型和名称，如您所见：

````java
int gear = 1;
````

这样做会告诉程序一个名为“gear”的字段存在，保存数字数据，初始值为“1”。变量的数据类型确定它可能包含的值，以及可能对其执行的操作。除此之外`int`，Java编程语言还支持其他七种*原始数据类型*。基本类型由语言预定义，并由保留关键字命名。原始值不与其他原始值共享状态。Java编程语言支持的八种原始数据类型是：

- **byte**：`byte`数据类型是8位有符号二进制补码整数。它的最小值为-128，最大值为127（含）。的`byte`数据类型可以是在大型保存存储器有用 [阵列](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html)，其中存储器的节省实际上重要的。它们也可用于代替`int`其限制有助于澄清您的代码; 变量范围有限的事实可以作为一种文档形式。
- **short**：`short`数据类型是16位带符号的二进制补码整数。它的最小值为-32,768，最大值为32,767（含）。与`byte`此同样，适用相同的指导原则：`short`在内存节省确实很重要的情况下，您可以使用a 来节省大型阵列中的内存。
- **int**：默认情况下，`int`数据类型是32位带符号的二进制补码整数，其最小值为-2^31，最大值为2^31 -1。在Java SE 8及更高版本中，您可以使用`int`数据类型表示无符号的32位整数，其最小值为0，最大值为2^32 -1。使用Integer类将`int`数据类型用作无符号整数。有关更多信息，请参阅数字类一节。像静态方法`compareUnsigned`，`divideUnsigned`等已被添加到 [`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)类，以支持算术运算的无符号整数。
- **long**：`long`数据类型是64位二进制补码整数。带符号的long的最小值为-2^63，最大值为2^63 -1。在Java SE 8及更高版本中，您可以使用`long`数据类型表示无符号的64位长，其最小值为0，最大值为2^64 -1。当您需要的值范围比提供的值更宽时，请使用此数据类型`int`。本 [`Long`](https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html)类也包含类似的方法`compareUnsigned`，`divideUnsigned`等支持算术运算unsigned long类型。
- **float**：`float`数据类型是单精度32位IEEE 754浮点。其值范围超出了本讨论的范围，但在Java语言规范的 [浮点类型，格式和值](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3)部分中指定。正如所提建议`byte`和`short`，使用`float`（而不是`double`如果你需要节省内存浮点数的大型阵列）。绝不应将此数据类型用于精确值，例如货币。为此，您需要使用 [java.math.BigDecimal](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)类。 [数字和字符串](https://docs.oracle.com/javase/tutorial/java/data/index.html)涵盖`BigDecimal`Java平台提供的其他有用类。
- **double**：`double`数据类型是双精度64位IEEE 754浮点数。其值范围超出了本讨论的范围，但在Java语言规范的 [浮点类型，格式和值](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3)部分中指定。对于十进制值，此数据类型通常是默认选择。如上所述，此数据类型不应用于精确值，例如货币。
- **boolean**：`boolean`数据类型只有两个可能的值：`true`和`false`。将此数据类型用于跟踪真/假条件的简单标志。此数据类型表示一位信息，但其“大小”不是精确定义的内容。
- **char**：`char`数据类型是单个16位Unicode字符。它的最小值为`'\u0000'`（或0），最大值为`'\uffff'`（或65,535（含））。

除了上面列出的八种原始数据类型之外，Java编程语言还通过[java.lang.String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)类为字符串提供特殊支持 。将字符串括在双引号内将自动创建一个新`String`对象; 例如，`String s = "this is a string";`。`String`对象是*不可变的*，这意味着一旦创建，它们的值就无法更改。该`String`班是不是技术上原始数据类型，但考虑由语言所赋予的特殊支持，你可能会倾向于认为它是这样的。您将`String`在[Simple Data Objects中](https://docs.oracle.com/javase/tutorial/java/data/index.html)了解有关该类的 更多信息

**默认值**

声明字段时并不总是需要分配值。声明但未初始化的字段将由编译器设置为合理的默认值。一般来说，此默认值为零或`null`取决于数据类型。然而，依赖于这样的默认值通常被认为是糟糕的编程风格。

下表总结了上述数据类型的默认值。

| **Data Type**          | **Default Value (for fields)** |
| ---------------------- | ------------------------------ |
| byte                   | 0                              |
| short                  | 0                              |
| int                    | 0                              |
| long                   | 0L                             |
| float                  | 0.0f                           |
| double                 | 0.0d                           |
| char                   | '\u0000'                       |
| String (or any object) | null                           |
| boolean                | false                          |

局部变量略有不同; 编译器永远不会为未初始化的局部变量分配默认值。如果无法初始化声明它的局部变量，请确保在尝试使用它之前为其赋值。访问未初始化的局部变量将导致编译时错误。

**字面值**

您可能已经注意到`new`在初始化基本类型的变量时不使用关键字。基元类型是语言中内置的特殊数据类型; 它们不是从类创建的对象。甲*文字*是固定值的源代码表示; 文字直接在代码中表示，无需计算。如下所示，可以将文字分配给基本类型的变量：

````java
boolean result = true;
char capitalC = 'C';
byte b = 100;
short s = 10000;
int i = 100000;
````

**整型字面值**

字面的整数类型的`long`，如果它以字母`L`或`l`; 否则它是类型`int`。建议您使用大写字母，`L`因为小写字母`l`很难与数字区分开来`1`。

整型值`byte`，`short`，`int`，并且`long`可以从创造`int`文字。`long`超出范围的类型的值`int`可以从`long`文字创建。整数文字可以用这些数字系统表示：

- 十进制：基数为10，其数字由数字0到9组成; 这是您每天使用的数字系统
- 十六进制：Base 16，其数字由数字0到9和字母A到F组成
- 二进制：基数2，其数字由数字0和1组成（您可以在Java SE 7及更高版本中创建二进制文字）

对于通用编程，十进制系统可能是您将使用的唯一数字系统。但是，如果需要使用其他数字系统，以下示例将显示正确的语法。前缀`0x`表示十六进制，`0b`表示二进制：

````java
// The number 26, in decimal
int decVal = 26;
//  The number 26, in hexadecimal
int hexVal = 0x1a;
// The number 26, in binary
int binVal = 0b11010;
````

**浮点字面值**

浮点文字的类型的`float`，如果它以字母`F`或`f`; 否则它的类型是`double`，它可以选择以字母`D`或结尾`d`。

浮点类型（`float`和`double`）也可以用E或e（用于科学记数法），F或f（32位浮点字面量）和D或d（64位双字面值）表示;这是默认值，按惯例是中省略）。

````java
double d1 = 123.4;
// same value as d1, but in scientific notation
double d2 = 1.234e2;
float f1  = 123.4f;
````

**字符和字符串字面值**

类型`char`和`String`可以包含任何Unicode（UTF-16）字符。如果您的编辑器和文件系统允许，您可以直接在代码中使用这些字符。如果没有，您可以使用“Unicode转义”，例如`'\u0108'`（带有circumflex的大写C）或`"S\u00ED Se\u00F1or"`（西班牙语中的SíSeñor）。始终对`char`文字使用“单引号”，对文字使用“双引号” `String`。Unicode转义序列可以在程序的其他地方使用（例如在字段名称中），而不仅仅是在文字`char`或`String`文字中。

Java编程语言还支持一些特殊的转义序列`char`和`String`文字:( `\b`退格），`\t`（制表符），`\n`（换行），`\f`（换页），`\r`（回车），`\"`（双引号），`\'`（单引号）和`\\`（反斜杠）。

还有一个特殊的`null`文字可以用作任何参考类型的值。`null`除了基本类型的变量之外，可以将其分配给任何变量。`null`除了测试它的存在之外，你几乎无法做到超值。因此，`null`经常在程序中用作标记来指示某些对象不可用。

最后，还有一种特殊的文字，称为*类文字*，通过获取类型名称并附加“ `.class"`;例如，`String.class`。”这是指`Class`表示类型本身的对象（类型）。

**在数字字面值中使用下划线**

在Java SE 7及更高版本中，任何数量的下划线字符（`_`）都可以出现在数字文字中的数字之间的任何位置。例如，此功能可用于您。分隔数字文字中的数字组，这可以提高代码的可读性。

例如，如果您的代码包含具有多个数字的数字，则可以使用下划线字符来分隔三个组中的数字，类似于使用逗号或空格等标点符号作为分隔符的方式。

以下示例显示了在数字文字中使用下划线的其他方法：

````java
long creditCardNumber = 1234_5678_9012_3456L; 
long socialSecurityNumber = 999_99_9999L; 
float pi = 3.14_15F; 
long hexBytes = 0xFF_EC_DE_5E; 
long hexWords = 0xCAFE_BABE; 
long maxLong = 0x7fff_ffff_ffff_ffffL; 
byte nybbles = 0b0010_0101; 
long bytes = 0b11010010_01101001_10010100_10010010;
````

您只能在数字之间放置下划线; 你不能在以下地方放置下划线：

- 在数字的开头或结尾
- 与浮点文字中的小数点相邻
- 之前`F`或`L`后缀
- 在预期有一串数字的位置

以下示例演示了数字文字中有效和无效的下划线放置（突出显示）：

````java
// Invalid: cannot put underscores
// adjacent to a decimal point
float pi1 = 3_.1415F;
// Invalid: cannot put underscores 
// adjacent to a decimal point
float pi2 = 3._1415F;
// Invalid: cannot put underscores 
// prior to an L suffix
long socialSecurityNumber1 = 999_99_9999_L;

// OK (decimal literal)
int x1 = 5_2;
// Invalid: cannot put underscores
// At the end of a literal
int x2 = 52_;
// OK (decimal literal)
int x3 = 5_______2;

// Invalid: cannot put underscores
// in the 0x radix prefix
int x4 = 0_x52;
// Invalid: cannot put underscores
// at the beginning of a number
int x5 = 0x_52;
// OK (hexadecimal literal)
int x6 = 0x5_2; 
// Invalid: cannot put underscores
// at the end of a number
int x7 = 0x52_;
````

#### 数组

一个*阵列*是保持单一类型的值的固定数目的容器对象。创建数组时，将建立数组的长度。创建后，其长度是固定的。你已经在`main`“Hello World！” 的方法中看到了一个数组的例子。应用。本节更详细地讨论了数组。

![image-20190504131241768](https://raw.githubusercontent.com/shenliang-2016/article/master/translate/assets/java/image-20190504131241768.png)

数组中的每个项称为一个*元素*，每个元素都由其数字*索引*访问。如上图所示，编号从0开始。例如，第9个元素将在索引8处访问。

以下程序 [`ArrayDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArrayDemo.java)创建一个整数数组，将一些值放入数组中，并将每个值打印到标准输出。

````java
class ArrayDemo {
    public static void main(String[] args) {
        // declares an array of integers
        int[] anArray;

        // allocates memory for 10 integers
        anArray = new int[10];
           
        // initialize first element
        anArray[0] = 100;
        // initialize second element
        anArray[1] = 200;
        // and so forth
        anArray[2] = 300;
        anArray[3] = 400;
        anArray[4] = 500;
        anArray[5] = 600;
        anArray[6] = 700;
        anArray[7] = 800;
        anArray[8] = 900;
        anArray[9] = 1000;

        System.out.println("Element at index 0: "
                           + anArray[0]);
        System.out.println("Element at index 1: "
                           + anArray[1]);
        System.out.println("Element at index 2: "
                           + anArray[2]);
        System.out.println("Element at index 3: "
                           + anArray[3]);
        System.out.println("Element at index 4: "
                           + anArray[4]);
        System.out.println("Element at index 5: "
                           + anArray[5]);
        System.out.println("Element at index 6: "
                           + anArray[6]);
        System.out.println("Element at index 7: "
                           + anArray[7]);
        System.out.println("Element at index 8: "
                           + anArray[8]);
        System.out.println("Element at index 9: "
                           + anArray[9]);
    }
} 
````

该程序的输出是：

````shell
Element at index 0: 100
Element at index 1: 200
Element at index 2: 300
Element at index 3: 400
Element at index 4: 500
Element at index 5: 600
Element at index 6: 700
Element at index 7: 800
Element at index 8: 900
Element at index 9: 1000
````

在实际编程情况下，您可能会使用其中一个受支持的*循环结构*来遍历数组的每个元素，而不是像前面的示例中那样单独写入每一行。但是，该示例清楚地说明了数组语法。您将了解各种循环结构（`for`，`while`，和`do-while`在） [控制流](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)部分。

**声明变量以引用数组**

前面的程序`anArray`使用以下代码行声明一个数组（命名）：

````java
// declares an array of integers
int[] anArray;
````

与其他类型的变量的声明一样，数组声明有两个组件：数组的类型和数组的名称。数组的类型写为`*type*[]`，`*type*`包含的元素的数据类型在哪里; 括号是特殊符号，表示此变量包含数组。数组的大小不是其类型的一部分（这就是括号为空的原因）。数组的名称可以是您想要的任何名称，前提是它遵循先前在[命名](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming)部分中讨论的规则和约定 。与其他类型的变量一样，声明实际上并不创建数组; 它只是告诉编译器该变量将包含指定类型的数组。

同样，您可以声明其他类型的数组：

````java
byte[] anArrayOfBytes;
short[] anArrayOfShorts;
long[] anArrayOfLongs;
float[] anArrayOfFloats;
double[] anArrayOfDoubles;
boolean[] anArrayOfBooleans;
char[] anArrayOfChars;
String[] anArrayOfStrings;
````

您还可以将括号放在数组名称后面：

````java
// this form is discouraged
float anArrayOfFloats[];
````

但是，公约不鼓励这种形式; 括号标识数组类型，并应显示类型名称

**创建，初始化和访问数组**

创建数组的一种方法是与`new`运算符一起使用。程序中的下一个语句`ArrayDemo`为10个整数元素分配一个具有足够内存的数组，并将该数组`anArray`赋值给变量。

````java
// create an array of integers
anArray = new int[10];
````

如果缺少此语句，则编译器会输出如下错误，并且编译失败：

````java
ArrayDemo.java:4: Variable anArray may not have been initialized.
````

接下来的几行为数组的每个元素赋值：

````java
anArray[0] = 100; // initialize first element
anArray[1] = 200; // initialize second element
anArray[2] = 300; // and so forth
````

或者，您可以使用快捷语法来创建和初始化数组：

````java
int[] anArray = { 
    100, 200, 300,
    400, 500, 600, 
    700, 800, 900, 1000
};
````

这里数组的长度由大括号之间提供的值的数量确定，并用逗号分隔。

您还可以使用两组或更多组括号声明一个数组数组（也称为*多维*数组），例如`String[][] names`。因此，每个元素必须由相应数量的索引值访问。

在Java编程语言中，多维数组是一个数组，其组件本身就是数组。这与C或Fortran中的数组不同。这样做的结果是允许行的长度不同，如以下[`MultiDimArrayDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/MultiDimArrayDemo.java)程序所示 ：

````java
class MultiDimArrayDemo {
    public static void main(String[] args) {
        String[][] names = {
            {"Mr. ", "Mrs. ", "Ms. "},
            {"Smith", "Jones"}
        };
        // Mr. Smith
        System.out.println(names[0][0] + names[1][0]);
        // Ms. Jones
        System.out.println(names[0][2] + names[1][1]);
    }
}
````

该程序的输出是：

````shell
Mr. Smith
Ms. Jones
````

最后，您可以使用内置`length`属性来确定任何数组的大小。以下代码将数组的大小打印到标准输出：

````java
 System.out.println(anArray.length);
````

**复制数组**

`System`类有一个`arraycopy`，可以使用有效地将数据从一个阵列复制到另一个方法：

````java
public static void arraycopy（Object src，int srcPos，
                             Object dest，int destPos，int length）
````

这两个`Object`参数指定*要从*中复制的数组和要复制*到*的数组。这三个`int`参数指定源数组中的起始位置，目标数组中的起始位置以及要复制的数组元素的数量。

以下程序 [`ArrayCopyDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArrayCopyDemo.java)声明了一系列`char`元素，拼写单词“decafffeinated”。它使用该`System.arraycopy`方法将数组组件的子序列复制到第二个数组中。

````java
class ArrayCopyDemo { 
    public static void main（String [] args）{ 
        char [] copyFrom = {'d'，'e'，'c'，'a'，'f'，'f'，'e'，
			    'i '，'n'，'a'，'t'，'e'，'d'}; 
        char [] copyTo = new char [7]; 

        System.arraycopy（copyFrom，2，copyTo，0,7）; 
        System.out.println（new String（copyTo））; 
    } 
}
````

该程序的输出是：

````shell
caffein
````

**数组操作**

数组是编程中使用的强大而有用的概念。Java SE提供了执行与数组相关的一些最常见操作的方法。例如，该[`ArrayCopyDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArrayCopyDemo.java)示例使用类的`arraycopy`方法`System`而不是手动迭代源数组的元素并将每个元素放入目标数组中。这是在幕后执行的，使开发人员只使用一行代码来调用该方法。

为方便起见，Java SE提供了几种在类中执行数组操作（常见任务，如复制，排序和搜索数组）的方法 [`java.util.Arrays`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html)。例如，可以修改前面的示例以使用类的`copyOfRange`方法`java.util.Arrays`，如 [`ArrayCopyOfDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArrayCopyOfDemo.java)示例中所示。不同之处在于，使用该`copyOfRange`方法不需要在调用方法之前创建目标数组，因为方法返回目标数组：

````java
class ArrayCopyOfDemo { 
    public static void main（String [] args）{ 
        
        char [] copyFrom = {'d'，'e'，'c'，'a'，'f'，'f'，'e'，
            'i '，'n'，'a'，'t'，'e'，'d'}; 
            
        char [] copyTo = java.util.Arrays.copyOfRange（copyFrom，2,9）; 
        
        System.out.println（new String（copyTo））; 
    } 
}
````

正如您所看到的，此程序的输出是相同的（`caffein`），尽管它需要更少的代码行。需要注意的是的第二个参数`copyOfRange`的方法是该范围的初始索引被复制，包含地，而第三个参数是将要复制的区间的最后的索引，*只*。在此示例中，要复制的范围不包括索引9处的数组元素（包含该字符`a`）。

`java.util.Arrays`该类中的方法提供的一些其他有用的操作是：

- 在数组中搜索特定值以获取放置它的索引（`binarySearch`方法）。
- 比较两个数组以确定它们是否相等（`equals`方法）。
- 填充数组以在每个索引处放置特定值（`fill`方法）。
- 按升序对数组进行排序。这可以使用该`sort`方法顺序完成，也可以使用`parallelSort`Java SE 8中引入的方法同时完成。多处理器系统上的大型数组的并行排序比顺序数组排序更快。

#### 变量摘要

Java编程语言使用“字段”和“变量”作为其术语的一部分。实例变量（非静态字段）对于类的每个实例都是唯一的。类变量（静态字段）是使用`static`修饰符声明的字段; 无论类实例化了多少次，都只有一个类变量的副本。局部变量在方法中存储临时状态。参数是为方法提供额外信息的变量; 局部变量和参数总是被归类为“变量”（而不是“字段”）。在命名字段或变量时，您应该（或必须）遵循规则和约定。

八种原始数据类型是：byte，short，int，long，float，double，boolean和char。本 [`java.lang.String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)类代表字符串。编译器将为上述类型的字段分配合理的默认值; 对于局部变量，永远不会分配默认值。文字是固定值的源代码表示。数组是一个容器对象，它包含固定数量的单个类型的值。创建数组时，将建立数组的长度。创建后，其长度是固定的。

### 运算符

现在，你已经学会了如何声明和初始化变量，你可能想知道如何*做一些*与他们。学习Java编程语言的操作符是一个很好的起点。运算符是对一个，两个或三个*操作数*执行特定操作的特殊符号，然后返回结果。

在我们探索Java编程语言的运算符时，提前知道哪些运算符具有最高优先级可能对您有所帮助。下表中的运算符按优先顺序列出。操作员越接近表格顶部，其优先级越高。优先级较高的运算符在优先级相对较低的运算符之前进行求值。同一行上的运营商具有相同的优先权。当具有相同优先级的运算符出现在同一表达式中时，规则必须控制首先计算的值。除了赋值运算符之外的所有二元运算符都是从左到右计算的; 赋值运算符从右到左进行计算。

| Operators            | Precedence                               |
| -------------------- | ---------------------------------------- |
| postfix              | `*expr*++ *expr*--`                      |
| unary                | `++*expr* --*expr* +*expr* -*expr* ~ !`  |
| multiplicative       | `* / %`                                  |
| additive             | `+ -`                                    |
| shift                | `<< >> >>>`                              |
| relational           | `< > <= >= instanceof`                   |
| equality             | `== !=`                                  |
| bitwise AND          | `&`                                      |
| bitwise exclusive OR | `^`                                      |
| bitwise inclusive OR | `|`                                      |
| logical AND          | `&&`                                     |
| logical OR           | `||`                                     |
| ternary              | `? :`                                    |
| assignment           | `= += -= *= /= %= &= ^= |= <<= >>= >>>=` |

在通用编程中，某些运营商往往比其他运营商更频繁地出现; 例如，赋值运算符“ `=`”比无符号右移运算符“ `>>>`” 更常见。考虑到这一点，以下讨论首先关注您最有可能定期使用的运营商，并最终关注那些不太常见的运营商。每个讨论都附有可以编译和运行的示例代码。研究它的输出将有助于强化你刚刚学到的东西。

#### 赋值，算术和一元运算符

**赋值操作符**

您将遇到的最常见的运算符之一是简单的赋值运算符“ `=`”。你在Bicycle类中看到过这个操作符; 它将右侧的值赋给左侧的操作数：

````java
 int cadence = 0;
 int speed = 0;
 int gear = 1;
````

此运算符也可用于对象以分配*对象引用*，如 [创建对象中所述](https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html)。

**算术运算符**

Java编程语言提供执行加法，减法，乘法和除法的运算符。你很可能会在基础数学方面认识他们。唯一可能对你来说很新的符号是“ `%`”，它将一个操作数除以另一个操作数，并将余数作为结果返回。

| Operator | Description                              |
| -------- | ---------------------------------------- |
| `+`      | Additive operator (also used for String concatenation) |
| `-`      | Subtraction operator                     |
| `*`      | Multiplication operator                  |
| `/`      | Division operator                        |
| `%`      | Remainder operator                       |

以下程序 [`ArithmeticDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ArithmeticDemo.java)测试算术运算符。

````java
class ArithmeticDemo {

    public static void main (String[] args) {

        int result = 1 + 2;
        // result is now 3
        System.out.println("1 + 2 = " + result);
        int original_result = result;

        result = result - 1;
        // result is now 2
        System.out.println(original_result + " - 1 = " + result);
        original_result = result;

        result = result * 2;
        // result is now 4
        System.out.println(original_result + " * 2 = " + result);
        original_result = result;

        result = result / 2;
        // result is now 2
        System.out.println(original_result + " / 2 = " + result);
        original_result = result;

        result = result + 8;
        // result is now 10
        System.out.println(original_result + " + 8 = " + result);
        original_result = result;

        result = result % 7;
        // result is now 3
        System.out.println(original_result + " % 7 = " + result);
    }
}
````

该程序打印以下内容：

````shell
1 + 2 = 3
3 - 1 = 2
2 * 2 = 4
4 / 2 = 2
2 + 8 = 10
10 % 7 = 3
````

您还可以将算术运算符与简单赋值运算符组合以创建*复合赋值*。例如，`x+=1;`与`x=x+1;`两个增量的值`x`由1。

的`+`操作者也可以用于级联（接合）两个字符串在一起，如示于下述 [`ConcatDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConcatDemo.java)方案：

````java
class ConcatDemo {
    public static void main(String[] args){
        String firstString = "This is";
        String secondString = " a concatenated string.";
        String thirdString = firstString+secondString;
        System.out.println(thirdString);
    }
}
````

在该程序结束时，变量`thirdString`包含“This is a concatenated string。”，它将打印到标准输出。

**一元运算符**

一元运算符只需要一个操作数; 它们执行各种操作，例如将值递增/递减1，否定表达式或反转布尔值。

| Operator | Description                              |
| -------- | ---------------------------------------- |
| `+`      | Unary plus operator; indicates positive value (numbers are positive without this, however) |
| `-`      | Unary minus operator; negates an expression |
| `++`     | Increment operator; increments a value by 1 |
| `--`     | Decrement operator; decrements a value by 1 |
| `!`      | Logical complement operator; inverts the value of a boolean |

以下程序 [`UnaryDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/UnaryDemo.java)测试一元运算符：

````java
class UnaryDemo {

    public static void main(String[] args) {

        int result = +1;
        // result is now 1
        System.out.println(result);

        result--;
        // result is now 0
        System.out.println(result);

        result++;
        // result is now 1
        System.out.println(result);

        result = -result;
        // result is now -1
        System.out.println(result);

        boolean success = false;
        // false
        System.out.println(success);
        // true
        System.out.println(!success);
    }
}
````

可以在操作数之前（前缀）或之后（后缀）应用递增/递减运算符。代码`result++;`并将`++result;`以`result`加1 结束。唯一的区别是前缀version（`++result`）计算增量值，而后缀version（`result++`）计算为原始值。如果您只是执行简单的增量/减量，那么选择哪个版本并不重要。但是，如果您在较大的表达式中使用此运算符，则您选择的运算符可能会产生显着差异。

以下程序 [`PrePostDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/PrePostDemo.java)说明了前缀/后缀一元增量运算符：

````java
class PrePostDemo {
    public static void main(String[] args){
        int i = 3;
        i++;
        // prints 4
        System.out.println(i);
        ++i;			   
        // prints 5
        System.out.println(i);
        // prints 6
        System.out.println(++i);
        // prints 6
        System.out.println(i++);
        // prints 7
        System.out.println(i);
    }
}
````

#### 相等，关系和条件运算符

**相等与关系运算符**

等于和关系运算符确定一个操作数是否大于，小于，等于或不等于另一个操作数。这些操作员中的大多数也可能看起来很熟悉。请记住，在测试两个原始值是否相等时`==`，必须使用“ ”而不是“ `=`”。

````
==      equal to
!=      not equal to
>       greater than
>=      greater than or equal to
<       less than
<=      less than or equal to
````

以下程序 [`ComparisonDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ComparisonDemo.java)测试比较运算符：

````java
class ComparisonDemo {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        if(value1 == value2)
            System.out.println("value1 == value2");
        if(value1 != value2)
            System.out.println("value1 != value2");
        if(value1 > value2)
            System.out.println("value1 > value2");
        if(value1 < value2)
            System.out.println("value1 < value2");
        if(value1 <= value2)
            System.out.println("value1 <= value2");
    }
}
````

输出：

````
value1 != value2
value1 <  value2
value1 <= value2
````

**条件操作符**

`&&`与`||` 操作符在两个布尔表达式之间进行 *有条件与*和 *有条件或*运算。这些运算符表现出“短路”行为，这意味着仅在需要时才评估第二个操作数。

````
&& Conditional-AND
|| Conditional-OR
````

以下程序 [`ConditionalDemo1`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConditionalDemo1.java)测试这些运算符：

````java
class ConditionalDemo1 {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        if((value1 == 1) && (value2 == 2))
            System.out.println("value1 is 1 AND value2 is 2");
        if((value1 == 1) || (value2 == 1))
            System.out.println("value1 is 1 OR value2 is 1");
    }
}
````

另一个条件运算符`?:`，可以被认为是`if-then-else`语句的简写（在本课程的[控制流语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)部分中讨论 ）。此运算符也称为*三元运算符，*因为它使用三个操作数。在下面的示例中，此运算符应读作：“如果`someCondition`是`true`，则赋值`value1`to `result`。否则，赋值`value2`to `result`。”

以下程序 [`ConditionalDemo2`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ConditionalDemo2.java)测试`?:`运算符：

````java
class ConditionalDemo2 {

    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        int result;
        boolean someCondition = true;
        result = someCondition ? value1 : value2;

        System.out.println(result);
    }
}
````

因为`someCondition`是，所以该程序在屏幕上打印“1”。如果它使代码更具可读性，则使用`?:`运算符而不是`if-then-else`语句; 例如，当表达式紧凑且没有副作用（例如赋值）时。

**类型比较运算符 instanceof**

`instanceof`操作符将对象与指定类型进行比较。您可以使用它来测试对象是否是类的实例，子类的实例或实现特定接口的类的实例。

以下程序 [`InstanceofDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/InstanceofDemo.java)定义父类（已命名`Parent`），简单接口（已命名`MyInterface`）和`Child`从父进程继承并实现接口的子类（已命名）。

````java
class InstanceofDemo {
    public static void main(String[] args) {

        Parent obj1 = new Parent();
        Parent obj2 = new Child();

        System.out.println("obj1 instanceof Parent: "
            + (obj1 instanceof Parent));
        System.out.println("obj1 instanceof Child: "
            + (obj1 instanceof Child));
        System.out.println("obj1 instanceof MyInterface: "
            + (obj1 instanceof MyInterface));
        System.out.println("obj2 instanceof Parent: "
            + (obj2 instanceof Parent));
        System.out.println("obj2 instanceof Child: "
            + (obj2 instanceof Child));
        System.out.println("obj2 instanceof MyInterface: "
            + (obj2 instanceof MyInterface));
    }
}

class Parent {}
class Child extends Parent implements MyInterface {}
interface MyInterface {}
````

输出：

````
obj1 instanceof Parent: true
obj1 instanceof Child: false
obj1 instanceof MyInterface: false
obj2 instanceof Parent: true
obj2 instanceof Child: true
obj2 instanceof MyInterface: true
````

使用`instanceof`运算符时，请记住，`null`不是任何类型的实例。

#### 位运算和移位操作符

Java编程语言还提供对整数类型执行按位和位移操作的运算符。本节中讨论的运算符不太常用。因此，他们的报道很简短; 目的是让您意识到这些运算符的存在。

一元按位补码运算符“ `~`”反转位模式; 它可以应用于任何整数类型，使每个“0”为“1”，每个“1”为“0”。例如，a `byte`包含8位; 将此运算符应用于位模式为“00000000”的值会将其模式更改为“11111111”。

带符号的左移位运算符“ `<<`”将位模式向左移位，带符号的右移位运算符“ `>>`”将位模式向右移位。位模式由左侧操作数给出，位置数由右侧操作数移位。无符号右移运算符“ `>>>`”将零移动到最左边的位置，而后面的最左边位置`">>"`取决于符号扩展。

按位运算`&`符执行按位AND运算。

按位运算`^`符执行按位异或运算。

按位运算`|`符执行按位包含OR运算。

以下程序 [`BitDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BitDemo.java)使用按位AND运算符将数字“2”打印到标准输出。

````java
class BitDemo {
    public static void main(String[] args) {
        int bitmask = 0x000F;
        int val = 0x2222;
        // prints "2"
        System.out.println(val & bitmask);
    }
}
````

#### 运算符总结

以下快速参考总结了Java编程语言支持的运算符。

**简单赋值操作符**

```
=       Simple assignment operator
```

**算术运算符**

```
+       Additive operator (also used
        for String concatenation)
-       Subtraction operator
*       Multiplication operator
/       Division operator
%       Remainder operator
```

**一元操作符**

```
+       Unary plus operator; indicates
        positive value (numbers are 
        positive without this, however)
-       Unary minus operator; negates
        an expression
++      Increment operator; increments
        a value by 1
--      Decrement operator; decrements
        a value by 1
!       Logical complement operator;
        inverts the value of a boolean
```

**相等和关系运算符**

```
==      Equal to
!=      Not equal to
>       Greater than
>=      Greater than or equal to
<       Less than
<=      Less than or equal to
```

**条件操作符**

```
&&      Conditional-AND
||      Conditional-OR
?:      Ternary (shorthand for 
        if-then-else statement)
```

**类型比较操作符**

```
instanceof      Compares an object to 
                a specified type 
```

**位运算和位移操作符**

```
~       Unary bitwise complement
<<      Signed left shift
>>      Signed right shift
>>>     Unsigned right shift
&       Bitwise AND
^       Bitwise exclusive OR
|       Bitwise inclusive OR
```

### 表达式，语句和块

现在您已了解变量和运算符，现在是时候了解*表达式*，*语句*和*块*。运算符可用于构建计算值的表达式; 表达式是陈述的核心组成部分; 语句可以分组为块。

**表达式**

一个*表达式*是变量，运算符和方法调用，它们根据语言的语法，计算结果为单个值构成由一个构建体。您已经看过表达式的示例，如下面的粗体所示：

````java
int cadence = 0;
anArray[0] = 100;
System.out.println("Element 1 at index 0: " + anArray[0]);

int result = 1 + 2; // result is now 3
if (value1 == value2) 
    System.out.println("value1 == value2");
````

表达式返回的值的数据类型取决于表达式中使用的元素。表达式`cadence = 0`返回一个，`int`因为赋值运算符返回与其左侧操作数相同的数据类型的值; 在这种情况下，`cadence`是一个`int`。从其他表达式中可以看出，表达式也可以返回其他类型的值，例如`boolean`或`String`。

只要表达式的一部分所需的数据类型与另一部分的数据类型匹配，Java编程语言就允许您从各种较小的表达式构造复合表达式。以下是复合表达式的示例：

````
1 * 2 * 3
````

在这个特定的例子中，表达式的计算顺序并不重要，因为乘法的结果与顺序无关; 结果总是相同的，无论您采用乘法的顺序。但是，并非所有表达式都是如此。例如，以下表达式给出不同的结果，具体取决于您是先执行加法还是除法运算：

```
x + y / 100 // 含糊不清
```

您可以使用平衡括号精确指定表达式的计算方式:(和）。例如，要使前一个表达式明确，您可以编写以下内容：

```
（x + y）/ 100 // 明确无误，推荐
```

如果未明确指示要执行的操作的顺序，则顺序由分配给表达式中使用的运算符的优先级确定。首先评估具有更高优先级的运算符。例如，除法运算符的优先级高于加法运算符。因此，以下两个陈述是等效的：

```
x + y / 100 
x +（y / 100）//明确，推荐
```

在编写复合表达式时，请明确并用括号表示应首先评估哪些运算符。这种做法使代码更易于阅读和维护。

**语句**

语句大致相当于自然语言中的句子。一个*语句*形成一个完整的执行单元。下列类型的表达式可以通过使用终结表达式，一个分号````;````，来变成一个语句。


- 赋值表达式
- 任何使用 `++` or `--` 的表达式
- 方法调用
- 对象创建表达式

这种语句被称为*表达式语句*。下面是介个表达式语句的例子：

```
// assignment statement
aValue = 8933.234;
// increment statement
aValue++;
// method invocation statement
System.out.println("Hello World!");
// object creation statement
Bicycle myBike = new Bicycle();
```
除了表达式语句，还存在其他两种语句：*声明语句* 和 *控制流语句*。一个*声明语句*声明一个变量。你应该已经看到过很多声明语句：

```
// declaration statement
double aValue = 8933.234;
```

最后，*控制流语句*调节语句执行的顺序。您将在下一节“控制流语句”中了解 [控制流语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)。

**块**

*块*是一组成对的括号之间的零条或多个语句，并且可以在任何地方使用单个语句是允许的。以下示例 [`BlockDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BlockDemo.java)说明了块的使用：

````java
class BlockDemo {
     public static void main(String[] args) {
          boolean condition = true;
          if (condition) { // begin block 1
               System.out.println("Condition is true.");
          } // end block one
          else { // begin block 2
               System.out.println("Condition is false.");
          } // end block 2
     }
}
````

### 控制流程语句

源文件中的语句通常按照它们出现的顺序从上到下执行。但是，*控制流语句*通过使用决策，循环和分支来打破执行流程，使您的程序能够*有条件地*执行特定的代码块。本节介绍了决策声明（`if-then`，`if-then-else`，`switch`），该循环语句（`for`，`while`，`do-while`）和分支语句（`break`，`continue`，`return`）的Java编程语言的支持。

#### ````if-then````和 ````if-then-else```` 语句

**````if-then```` 语句**

````if-then```` 语句是所有控制流语句中最基本的语句。它告诉程序只有在特定测试评估为 ````true```` 时才执行某段代码。例如，只有在自行车已经运动时，自行车等级才允许制动器降低自行车的速度。 ````applyBrakes```` 方法的一种可能实现如下：

````java
void applyBrakes() {
    // the "if" clause: bicycle must be moving
    if (isMoving){ 
        // the "then" clause: decrease current speed
        currentSpeed--;
    }
}
````

如果此测试评估为 ````false````（意味着自行车未运动），则控制跳转到 ````if-then```` 语句的末尾。

此外，只要 “then” 子句只包含一个语句，开括号和结束括号是可选的：

````java
void applyBrakes() {
    // same as above, but without braces 
    if (isMoving)
        currentSpeed--;
}
````

决定何时省略大括号是个人品味的问题。省略它们会使代码变得更脆弱。如果稍后将第二个语句添加到 “then” 子句中，则常见的错误是忘记添加新所需的大括号。编译器无法捕获这种错误，你会得到错误的结果。

**````if-then-else```` 语句**

````if-then-else```` 语句在 “if” 子句求值为 ````false```` 时提供辅助执行路径。如果在自行车不运动时应用制动器，则可以在 ````applyBrakes```` 方法中使用 ````if-then-else```` 语句来执行某些操作。在这种情况下，操作是简单地打印一条错误消息，指出自行车已经停止。

````java
void applyBrakes() {
    if (isMoving) {
        currentSpeed--;
    } else {
        System.err.println("The bicycle has already stopped!");
    } 
}
````

以下程序 [`IfElseDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/IfElseDemo.java) 根据测试分数的值分配等级：分数为90％或以上的是A，分数为80％或以上的是B，依此类推。

````java
class IfElseDemo {
    public static void main(String[] args) {

        int testscore = 76;
        char grade;

        if (testscore >= 90) {
            grade = 'A';
        } else if (testscore >= 80) {
            grade = 'B';
        } else if (testscore >= 70) {
            grade = 'C';
        } else if (testscore >= 60) {
            grade = 'D';
        } else {
            grade = 'F';
        }
        System.out.println("Grade = " + grade);
    }
}
````

输出是：

````
Grade = C
````

您可能已经注意到 ````testscore```` 的值可以满足复合语句中的多个表达式：76> = 70 和 76> = 60。但是，一旦满足条件，就会执行相应的语句（````grade ='C';```` ）并且不评估剩余的条件。

#### ````swith```` 语句

与 ````if-then```` 和 ````if-then-else```` 语句不同，````switch```` 语句可以有许多可能的执行路径。````switch```` 语句使用 ````byte````，````short````，````char```` 和 ````int```` 原始数据类型。它也适用于枚举类型（在[Enum Types](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)中讨论），[`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) 类，以及一些包含某些基本类型的特殊类： [`Character`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html), [`Byte`](https://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html), [`Short`](https://docs.oracle.com/javase/8/docs/api/java/lang/Short.html), and[`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html) （在[Numbers and Strings](https://docs.oracle.com/javase/tutorial/java/data/index.html)中讨论）。

以下代码示例 [`SwitchDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemo.java) 声明了一个名为 ````month```` 的 ````int````，其值表示月份。 代码使用 ````switch```` 语句根据 ````month```` 的值显示月份的名称。

````java
public class SwitchDemo {
    public static void main(String[] args) {

        int month = 8;
        String monthString;
        switch (month) {
            case 1:  monthString = "January";
                     break;
            case 2:  monthString = "February";
                     break;
            case 3:  monthString = "March";
                     break;
            case 4:  monthString = "April";
                     break;
            case 5:  monthString = "May";
                     break;
            case 6:  monthString = "June";
                     break;
            case 7:  monthString = "July";
                     break;
            case 8:  monthString = "August";
                     break;
            case 9:  monthString = "September";
                     break;
            case 10: monthString = "October";
                     break;
            case 11: monthString = "November";
                     break;
            case 12: monthString = "December";
                     break;
            default: monthString = "Invalid month";
                     break;
        }
        System.out.println(monthString);
    }
}
````

这种情况下，标准输出中打印 ````August```` 。

````switch```` 语句的主体称为 *switch块*。 可以使用一个或多个 ````case```` 或 ````default```` 标签来标记 ````switch```` 块中的语句。````switch```` 语句计算其表达式，然后执行匹配的 ````case```` 标签后面的所有语句。

您还可以使用 ````if-then-else```` 语句显示月份的名称：

````java
int month = 8;
if (month == 1) {
    System.out.println("January");
} else if (month == 2) {
    System.out.println("February");
}
...  // and so on
````

决定使用 ````if-then-else```` 语句还是 ````switch```` 语句是基于程序可读性和语句测试的表达式两方面考虑。````if-then-else```` 语句可以基于值或条件的范围来测试表达式，而 ````switch```` 语句仅基于单个整数，枚举值或 ````String```` 对象来测试表达式。

另一个关键点是 ````break```` 语句。每个 ````break```` 语句都会终止包含它的 ````switch```` 语句。控制流程继续执行 ````switch```` 块后面的第一个语句。````break```` 语句是必需的，因为没有它们，````switch```` 块中的语句都会被穿透：匹配的 ````case```` 标签之后的所有语句都按顺序执行，而不管后续 ````case```` 标签的表达式，直到遇到 ````break```` 语句。程序 [`SwitchDemoFallThrough`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemoFallThrough.java) 显示 ````switch```` 块中的语句穿透。该程序显示对应于整数 ````month```` 的月份和该年份中的后续月份：

````java
public class SwitchDemoFallThrough {

    public static void main(String[] args) {
        java.util.ArrayList<String> futureMonths =
            new java.util.ArrayList<String>();

        int month = 8;

        switch (month) {
            case 1:  futureMonths.add("January");
            case 2:  futureMonths.add("February");
            case 3:  futureMonths.add("March");
            case 4:  futureMonths.add("April");
            case 5:  futureMonths.add("May");
            case 6:  futureMonths.add("June");
            case 7:  futureMonths.add("July");
            case 8:  futureMonths.add("August");
            case 9:  futureMonths.add("September");
            case 10: futureMonths.add("October");
            case 11: futureMonths.add("November");
            case 12: futureMonths.add("December");
                     break;
            default: break;
        }

        if (futureMonths.isEmpty()) {
            System.out.println("Invalid month number");
        } else {
            for (String monthName : futureMonths) {
               System.out.println(monthName);
            }
        }
    }
}
````

程序输出：

````
August
September
October
November
December
````

从技术上讲，不需要最后的 ````break````，因为后续流程不属于 ````switch```` 语句。 建议在最后使用 ````break````，以便更容易修改代码并减少错误。````default```` 部分处理 ````case```` 部分未明确处理的所有值。

以下代码示例 [`SwitchDemo2`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/SwitchDemo2.java) 显示了语句如何具有多个 ````case```` 标签。代码示例计算特定月份的天数：

````java
class SwitchDemo2 {
    public static void main(String[] args) {

        int month = 2;
        int year = 2000;
        int numDays = 0;

        switch (month) {
            case 1: case 3: case 5:
            case 7: case 8: case 10:
            case 12:
                numDays = 31;
                break;
            case 4: case 6:
            case 9: case 11:
                numDays = 30;
                break;
            case 2:
                if (((year % 4 == 0) && 
                     !(year % 100 == 0))
                     || (year % 400 == 0))
                    numDays = 29;
                else
                    numDays = 28;
                break;
            default:
                System.out.println("Invalid month.");
                break;
        }
        System.out.println("Number of Days = "
                           + numDays);
    }
}
````

程序输出：

````
Number of Days = 29
````

**在 ````switch```` 语句中使用 ````String````**

在 Java 7 及后续版本中，````switch```` 语句中的表达式中可以使用 ````String ```` 对象。下面的例子 [`StringSwitchDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/StringSwitchDemo.java) 展示了根据 ````String```` 类型的月份名称计算当月天数：

````java
public class StringSwitchDemo {

    public static int getMonthNumber(String month) {

        int monthNumber = 0;

        if (month == null) {
            return monthNumber;
        }

        switch (month.toLowerCase()) {
            case "january":
                monthNumber = 1;
                break;
            case "february":
                monthNumber = 2;
                break;
            case "march":
                monthNumber = 3;
                break;
            case "april":
                monthNumber = 4;
                break;
            case "may":
                monthNumber = 5;
                break;
            case "june":
                monthNumber = 6;
                break;
            case "july":
                monthNumber = 7;
                break;
            case "august":
                monthNumber = 8;
                break;
            case "september":
                monthNumber = 9;
                break;
            case "october":
                monthNumber = 10;
                break;
            case "november":
                monthNumber = 11;
                break;
            case "december":
                monthNumber = 12;
                break;
            default: 
                monthNumber = 0;
                break;
        }

        return monthNumber;
    }

    public static void main(String[] args) {

        String month = "August";

        int returnedMonthNumber =
            StringSwitchDemo.getMonthNumber(month);

        if (returnedMonthNumber == 0) {
            System.out.println("Invalid month");
        } else {
            System.out.println(returnedMonthNumber);
        }
    }
}
````

程序的输出是 8 。

将 ````switch```` 表达式中的 ````String```` 与每个 ````case```` 标签关联的表达式进行比较，就好像正在使用 [`String.equals`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-) 方法一样。为了使 ````StringSwitchDemo```` 示例无论何种情况都接受任何月份，月份将转换为小写（使用 [`toLowerCase`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toLowerCase--) 方法），并且与 ````case```` 标签关联的所有字符串均为小写。

注意：此示例检查 ````switch```` 语句中的表达式是否为 ````null````。确保任何 ````switch```` 语句中的表达式不为 ````null````，以防止抛出 ````NullPointerException````。

#### ````while```` 和 ````do-while```` 语句

````while```` 语句在特定条件为真时继续执行语句块。 其语法可表示为：

````java
while (expression) {
     statement(s)
}
````

````while```` 语句计算表达式，该表达式必须返回一个布尔值。如果表达式的计算结果为 ````true````，则 ````while```` 语句将执行 ````while```` 块中的语句。````while```` 语句持续测试表达式并执行其中的语句块，直到表达式求值为 ````false````。使用 ````while```` 语句打印1到10之间的值可以在以下 [`WhileDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/WhileDemo.java) 程序中完成：

````java
class WhileDemo {
    public static void main(String[] args){
        int count = 1;
        while (count < 11) {
            System.out.println("Count is: " + count);
            count++;
        }
    }
}
````

你可以像下面这样使用 ````while```` 语句实现死循环：

````java
while (true){
    // your code goes here
}
````

Java 语言还提供了 ````do-while```` 语句，可以表示如下：

````java
do {
     statement(s)
} while (expression);
````

````do-while```` 和 ````while```` 之间的区别在于 ````do-while```` 在循环的底部而不是顶部计算它的表达式。因此，````do```` 块中的语句总是至少执行一次，如下面的 [`DoWhileDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/DoWhileDemo.java) 程序所示：

````java
class DoWhileDemo {
    public static void main(String[] args){
        int count = 1;
        do {
            System.out.println("Count is: " + count);
            count++;
        } while (count < 11);
    }
}
````

#### ````for```` 语句

````for```` 语句提供了一种迭代一系列值的简洁方法。程序员经常将其称为 “for循环”，因为它反复循环直到满足特定条件。````for```` 语句的一般形式可表示如下：

````java
for (initialization; termination;
     increment) {
    statement(s)
}
````

使用此版本的 ````for```` 语句时，请记住：

* 初始化表达式初始化循环， 循环开始时，它执行一次。
* 当终止表达式求值为 ````false```` 时，循环终止。
* 每次迭代循环后调用 ````increment```` 表达式， 这个表达式增加或减少一个值是完全可以接受的。

下面的例子 [`ForDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ForDemo.java) 使用普通形式的 ````for```` 语句将 1 到 10 打印到标准输出中：

````java
class ForDemo {
    public static void main(String[] args){
         for(int i=1; i<11; i++){
              System.out.println("Count is: " + i);
         }
    }
}
````

输出：

````
Count is: 1
Count is: 2
Count is: 3
Count is: 4
Count is: 5
Count is: 6
Count is: 7
Count is: 8
Count is: 9
Count is: 10
````

注意代码如何在初始化表达式中声明变量。 此变量的作用域从其声明扩展到由 ````for```` 语句控制的块的末尾，因此它也可以用在终止和增量表达式中。如果在循环外部不需要控制 ````for```` 语句的变量，则最好在初始化表达式中声明该变量。名称 i，j 和 k 通常用于控制循环。在初始化表达式中声明它们会限制它们的生命周期并减少错误。

````for```` 循环中的 3 个表达式都是可选的，可以如下创建一个无限循环：

````java
// infinite loop
for ( ; ; ) {
    
    // your code goes here
}
````

````for```` 语句还有另一种用于迭代 [Collections](https://docs.oracle.com/javase/tutorial/collections/index.html) 和 [arrays](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html) 的形式。这种形式有时被称为增强````for````语句，可用于使循环更紧凑和易于阅读。要演示，请考虑以下数组，其中包含数字1到10：

````java
int[] numbers = {1,2,3,4,5,6,7,8,9,10};
````

下面的例子，[`EnhancedForDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/EnhancedForDemo.java) 使用增强型 ````for```` 循环遍历上面的数组：

````java
class EnhancedForDemo {
    public static void main(String[] args){
         int[] numbers = 
             {1,2,3,4,5,6,7,8,9,10};
         for (int item : numbers) {
             System.out.println("Count is: " + item);
         }
    }
}
````

程序输出：

````
Count is: 1
Count is: 2
Count is: 3
Count is: 4
Count is: 5
Count is: 6
Count is: 7
Count is: 8
Count is: 9
Count is: 10
````

我们推荐你尽可能使用增强型 ````for```` 循环。

#### 分支语句

**````break```` 语句**

````break```` 语句有两种形式：有标签的和无标签的。你在先前的 ````switch```` 语句的例子中已经看到过无标签的形式。你也可以使用无标签的 ````break```` 语句来终止 ````for```` 、````while```` 或者 ````do-while```` 循环，如下面例子所示：

````java
class BreakDemo {
    public static void main(String[] args) {

        int[] arrayOfInts = 
            { 32, 87, 3, 589,
              12, 1076, 2000,
              8, 622, 127 };
        int searchfor = 12;

        int i;
        boolean foundIt = false;

        for (i = 0; i < arrayOfInts.length; i++) {
            if (arrayOfInts[i] == searchfor) {
                foundIt = true;
                break;
            }
        }

        if (foundIt) {
            System.out.println("Found " + searchfor + " at index " + i);
        } else {
            System.out.println(searchfor + " not in the array");
        }
    }
}
````

上面的程序在数组中搜索数字 12 。````break```` 语句在改值被找到时立即终止 ````for```` 循环。控制流程就转移到 ````for```` 循环之后的语句。程序输出：

````
Found 12 at index 4
````

无标签的 ````break```` 语句终止内层  ````for```` 、````while```` 或者 ````do-while```` 循环，而有标签的 ````break```` 语句终止外层  ````for```` 、````while```` 或者 ````do-while```` 循环。下面的程序 [`BreakWithLabelDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BreakWithLabelDemo.java) ，类似于上面的程序，不过使用了内层的 ````for```` 循环在二维数组中搜索目标值。当目标值被找到，有标签的 ````break```` 语句（标签为 “search”）将终止外部的 ````for```` 循环:

````java
class BreakWithLabelDemo {
    public static void main(String[] args) {

        int[][] arrayOfInts = { 
            { 32, 87, 3, 589 },
            { 12, 1076, 2000, 8 },
            { 622, 127, 77, 955 }
        };
        int searchfor = 12;

        int i;
        int j = 0;
        boolean foundIt = false;

    search:
        for (i = 0; i < arrayOfInts.length; i++) {
            for (j = 0; j < arrayOfInts[i].length;
                 j++) {
                if (arrayOfInts[i][j] == searchfor) {
                    foundIt = true;
                    break search;
                }
            }
        }

        if (foundIt) {
            System.out.println("Found " + searchfor + " at " + i + ", " + j);
        } else {
            System.out.println(searchfor + " not in the array");
        }
    }
}
````

程序的输出：

````
Found 12 at 1, 0
````

````break```` 语句终止有标签的语句，它并不是将流程控制转移到标签处的语句，而是转移到标签语句的下一条语句。

**````continue```` 语句**

````continue```` 语句跳过  ````for```` 、````while```` 或者 ````do-while```` 循环的当前迭代器。无标签的形式跳到内层循环体的末尾然后计算循环控制表达式的 ````boolean```` 值。下面的程序 [`ContinueDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ContinueDemo.java) ，遍历一个 ````String```` ，统计其中的字符 "p" 出现的次数。如果当前字符不是 “p”，则 ````continue```` 语句跳过循环的剩余部分并继续处理下一个字符。如果当前字符是“p”，则程序为字符计数加一。

````java
class ContinueDemo {
    public static void main(String[] args) {

        String searchMe = "peter piper picked a " + "peck of pickled peppers";
        int max = searchMe.length();
        int numPs = 0;

        for (int i = 0; i < max; i++) {
            // interested only in p's
            if (searchMe.charAt(i) != 'p')
                continue;

            // process p's
            numPs++;
        }
        System.out.println("Found " + numPs + " p's in the string.");
    }
}
````

程序输出：

````
Found 9 p's in the string.
````

为了更清楚地看出语句的效果，你可以删除其中的 ````continue```` 语句然后重新编译。再次运行程序，将输出错误的结果 35。

有标签的 ````continue```` 语句跳过标签表示的外层循环的当前迭代器。下面的例子 ContinueWithLabelDemo 使用内层循环来搜索包含某个特定字符串的子字符串。需要两个内层循环，一个迭代子字符串，另一个迭代需要搜索的目标字符串。下面的程序，[`ContinueWithLabelDemo`](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/ContinueWithLabelDemo.java) ，使用有标签的 ````continue```` 形式来跳过外层循环迭代器。

````java
class ContinueWithLabelDemo {
    public static void main(String[] args) {

        String searchMe = "Look for a substring in me";
        String substring = "sub";
        boolean foundIt = false;

        int max = searchMe.length() - 
                  substring.length();

    test:
        for (int i = 0; i <= max; i++) {
            int n = substring.length();
            int j = i;
            int k = 0;
            while (n-- != 0) {
                if (searchMe.charAt(j++) != substring.charAt(k++)) {
                    continue test;
                }
            }
            foundIt = true;
                break test;
        }
        System.out.println(foundIt ? "Found it" : "Didn't find it");
    }
}
````

程序输出：

````
Found it
````

**````return```` 语句**

最后一个分支语句是 ````return```` 语句。该语句退出当前方法，程序控制流返回该方法被调用的位置。该语句有两种形式：有返回值的和无返回值的。为了返回一个值，简单地在 ````return```` 关键字之后放置一个值或者计算该值的表达式即可。

````
return ++count;
````

返回值的类型必须符合该方法声明的返回值类型。当方法声明为 ````void```` ，使用无返回值的 ````return```` 形式。

接下来的 [Classes and Objects](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html) 将覆盖你写方法需要了解的所有知识。

#### 控制流语句总结

````if-then```` 语句是所有控制流语句中最基本的语句。它告诉程序只有在特定测试评估为 ````true```` 时才执行某段代码。 ````if-then-else```` 语句在 “if” 子句求值为 ````false```` 时提供辅助执行路径。与 ````if-then```` 和 ````if-then-else```` 不同，````switch```` 语句允许任意数量的可能执行路径。````while```` 和 ````do-while```` 语句在特定条件为真时不断执行语句块。````do-while```` 和 ````while```` 之间的区别在于 ````do-while```` 在循环的底部而不是顶部计算它的表达式。因此，````do```` 块中的语句总是至少执行一次。````for```` 语句提供了一种迭代一系列值的简洁方法。它有两种形式，其中一种用于循环集合和数组。

## 类和对象

你现在具有了 Java 编程语言的基础知识，可以开始写你自己的类。被章节中，你将学到有关定义你自己的类的信息，包括声明成员变量、方法以及构造器。

你将学到使用你类创建对象，然后使用你创建的对象。

本章节还包括位于其它类内部的内部类，以及枚举类型。

* [类型](https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html)

本章节剖析类型，同时讲述如何声明字段、方法以及构造器。

* [对象](https://docs.oracle.com/javase/tutorial/java/javaOO/objects.html)

本章节覆盖创建和使用对象。你将学到如何实例化一个对象，然后，一旦实例化，如何使用 ````dot```` 操作符访问该对象实例的变量和方法。

* [有关类型的更多话题](https://docs.oracle.com/javase/tutorial/java/javaOO/more.html)

本章节介绍依赖于使用对象引用的类的更多方面以及您在上一节中学习的 ````dot```` 运算符：从方法返回的值，````this```` 关键字，类成员变量与实例变量以及访问控制。

* [内部类](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)

静态内部类，内部类，匿名内部类，局部类，lambda 表达式。同时讨论何时使用何种方式。

* [枚举类型](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)

本章节覆盖枚举类型，这是一种特殊类型，允许你定义并使用一系列的常量。

### 类

[面向对象编程概念](https://docs.oracle.com/javase/tutorial/java/concepts/index.html) 章节中使用了自行车类型作为例子，具有赛车、山地车以及串联自行车等子类型。下面是一个可能的 ````Bicycle```` 类型的实现，向你展示一个完整的类型声明。本章节后续内容将逐步介绍其中的所有内容，现在不需要纠结细节。

````java
public class Bicycle {
        
    // the Bicycle class has
    // three fields
    public int cadence;
    public int gear;
    public int speed;
        
    // the Bicycle class has
    // one constructor
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    // the Bicycle class has
    // four methods
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}
````

其子类 ````MountainBike```` 类型可能如下：

````java
public class MountainBike extends Bicycle {
        
    // the MountainBike subclass has
    // one field
    public int seatHeight;

    // the MountainBike subclass has
    // one constructor
    public MountainBike(int startHeight, int startCadence,
                        int startSpeed, int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // the MountainBike subclass has
    // one method
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   

}
````

````MountainBike```` 继承了 ````Bicycle```` 的所有字段和方法，同时添加了 ````seatHeight```` 字段和该字段的 ````set```` 方法。

#### 类声明

你已经看到可以如下形式声明类型：

````java
class MyClass {
    // field, constructor, and 
    // method declarations
}
````

这是一个*类声明*。 类主体（大括号之间的区域）包含为从该类创建的对象的生命周期提供的所有代码：用于初始化新对象的构造函数，用于提供类及其对象的状态的字段的声明，以及 实现类及其对象行为的方法。

前面的类声明是最小的。 它仅包含所需的类声明的那些必需组件。您可以在类声明的开头提供有关该类的更多信息，例如其超类的名称，是否实现任何接口等。例如：

````java
class MyClass extends MySuperClass implements YourInterface {
    // field, constructor, and
    // method declarations
}
````

意味着 ````MyClass```` 是 ````MySuperClass```` 类的子类，同时它实现了 ````YourInterface```` 接口。

您也可以在一开始就添加 ````public```` 或 ````private```` 等修饰符 - 这样您就可以看到类声明的开头行可能变得非常复杂。````public```` 和 ````private```` 修饰符决定了哪些类可以访问 ````MyClass```` 的内容，本课程稍后将对此进行讨论。关于接口和继承的课程将解释如何以及为什么在类声明中使用 ````extends```` 和 `````implements````` 关键字。目前你不需要担心这些额外的并发症。

通常，类声明可以按顺序包含这些组件：

1. 修改器，例如 ````public````，````private```` 以及稍后您将遇到的许多其他修饰符。
2. 类名，首字母大写。
3. 类的父级（超类）的名称（如果有）以关键字 ````extends```` 开头。一个类只能扩展（子类）一个父类。
4. 由类实现的以逗号分隔的接口列表（如果有），前面是关键字 ````implements````。一个类可以实现多个接口。
5. 类主体，被大括号 ````{}```` 围绕。

#### 声明成员变量

有几种变量：

* 类的成员变量—它们被称为*字段*。
* 方法或者代码块中的变量—它们被称为*局部变量*。
* 方法声明中的变量—它们被称为*参数*。

````Bicycle```` 类使用下面的代码来定义它的字段：

````java
public int cadence;
public int gear;
public int speed;
````

字段声明由三部分组成，依次是：

1. 0 个或者更多访问修饰符，比如 ````public```` 或者 ````private````。
2. 字段类型。
3. 字段名称。

````Bicycle```` 类的字段命名为 ````cadence```` 、````gear```` 和 ````speed```` ，都是整型类型 ````int```` 。````public```` 访问修饰符表示这些字段是公开成员，所有可以访问该类型的对象都可以访问这些字段。

**访问修饰符**

变量声明语句开头的访问修饰符使得你可以控制哪些类可以访问该成员字段。目前，只考虑 ````public```` 和 ````private```` 两个，其它的访问修饰符后面会讨论。

* ````public```` — 该字段可以从所有其它类访问。
* ````private```` — 该字段只能被它所在的类内部访问。

本着封装精神，通常会将字段限制为 ````private```` 的。这意味着它们只能直接从 ````Bicycle```` 类访问。不过我们仍然需要访问这些值。那么就可以通过间接的方式来实现，添加 ````public ```` 方法来获取这些字段值：

````java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear() {
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}
````

**数据类型**

所有的变量必需都有数据类型。你可以使用基本数据类型，比如 ````int```` ，````float````，````boolean```` 等等。或者你可以使用引用类型，比如字符串，数组或者对象。

**变量名称**

所有变量，不论是字段，局部变量还是参数，遵守相同的命名规则，命名传统在 [变量命名](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming) 中介绍。

本章节中，注意方法和类命名遵循相同的规则和传统，除了：

* 类名的首字母应该大写，同时
* 方法名的首个词（或唯一词）应该是动词

#### 方法定义

下面是一个典型的方法声明：

```java
public double calculateAnswer(double wingSpan, int numberOfEngines,
                              double length, double grossTons) {
    //do the calculation here
}

```

方法声明只强制需要以下这些内容，方法返回值类型，名称，一对括号 `()`，以及位于大括号 `{}` 内部的方法体。

更一般地，方法声明包含六种元素，依次为：

1. 访问修饰符—比如 `public`， `private`， 其它几种你随后将会学习到。
2. 返回值类型—方法返回的值的数据类型，或者 `void` 如果方法不返回任何值。
3. 方法名—命名规则和传统与变量命名类似，虽然稍微有些不同。
4. 括号中的参数列表—逗号分隔的输入参数列表，由它们的数据类型开头，被括号 `()` 包围。如果方法不需要参数，你仍然必须使用空括号。
5. 异常列表—稍后讨论。
6. 大括号包围的方法体—方法的逻辑代码，包括局部变量声明等。

访问修饰符、返回值类型和参数将在本章节稍后讨论。异常在下一章节讨论。

------

**定义：**方法声明的两个元素构成了*方法签名*—方法的名称和参数类型。

------

上面方法的方法签名是：

```
calculateAnswer(double, int, double, double)
```

**命名一个方法**

虽然方法名称可以是任何合法标识符，但代码约定限制方法名称。按照惯例，方法名称应该是小写的动词或以小写的动词开头的多词名称，后跟形容词，名词等。在多词名称中，每个第二个和后一个词的第一个字母 应该大写。 这里有些例子：

````java
run
runFast
getBackground
getFinalData
compareTo
setX
isEmpty
````

通常，方法在其类中具有唯一名称。但是，由于方法重载，方法可能与其他方法具有相同的名称。

**方法重载**

Java编程语言支持重载方法，Java可以区分具有不同方法签名的方法。这意味着如果类中的方法具有不同的参数列表，则它们可以具有相同的名称（有一些规范，将在标题为“接口和继承”的课程中讨论）。

假设您有一个类可以使用书法来绘制各种类型的数据（字符串，整数等），并且包含绘制每种数据类型的方法。为每个方法使用新名称很麻烦 - 例如，````drawString````，````drawInteger````，````drawFloat```` 等。在 Java 编程语言中，您可以对所有绘图方法使用相同的名称，但将不同的参数列表传递给每个方法。因此，数据绘制类可能会声明四个名为````draw```` 的方法，每个方法都有一个不同的参数列表。

```java
public class DataArtist {
    ...
    public void draw(String s) {
        ...
    }
    public void draw(int i) {
        ...
    }
    public void draw(double f) {
        ...
    }
    public void draw(int i, double f) {
        ...
    }
}

```

重载方法由传递给方法的参数的数量和类型区分。在代码示例中，````draw(String s)```` 和 ````draw(int i)```` 是不同且唯一的方法，因为它们需要不同的参数类型。

您不能声明多个具有相同名称和相同数量和类型的参数的方法，因为编译器无法区分它们。

在区分方法时，编译器不考虑返回类型，因此即使它们具有不同的返回类型，也不能使用相同的签名声明两个方法。

------

**注意：**应谨慎使用重载方法，因为它们会使代码的可读性降低。

------

#### 为你的类提供构造器

一个累包含构造器，该构造器被调用来从该类蓝图创建对象。构造器声明类似于方法声明—除了它们使用类的名称同时没有返回值类型。比如，````Bicycle```` 拥有一个构造器：

```java
public Bicycle(int startCadence, int startSpeed, int startGear) {
    gear = startGear;
    cadence = startCadence;
    speed = startSpeed;
}
```

为了创建一个新的 `Bicycle` 对象，名为 `myBike` ，构造器被 `new` 操作符调用：

```java
Bicycle myBike = new Bicycle(30, 0, 8);
```

`new Bicycle(30, 0, 8)` 为新的对象分配内存空间并初始化它的字段。

尽管 `Bicycle` 只有一个构造器，实际上它还可以拥有其他构造器，包括一个无参数构造器：

```java
public Bicycle() {
    gear = 1;
    cadence = 10;
    speed = 0;
}
```

`Bicycle yourBike = new Bicycle();` 调用该无参数构造器创建一个新的 `Bicycle` 对象名为 `yourBike`。

两个构造函数都可以在`Bicycle`中声明，因为它们具有不同的参数列表。与方法一样，Java 平台根据列表中的参数数量及其类型来区分构造函数。您不能为同一个类编写两个具有相同数量和类型的参数的构造函数，因为平台无法区分它们。这样做会导致编译时错误。

您不必为您的类提供任何构造函数，但在执行此操作时必须小心。编译器自动为没有构造函数的任何类提供无参数的默认构造函数。此默认构造函数将调用超类的无参数构造函数。在这种情况下，如果超类没有无参数构造函数，编译器将会抱怨，因此您必须验证它是否存在。如果你的类没有显式的超类，那么它有一个隐含的超类 ````Object````，*肯定*具有无参数的构造函数。

您可以自己使用超类构造函数。本章节开头的 ````MountainBike```` 类就是这样做的。稍后将在接口和继承章节中对此进行讨论。

您可以在构造函数的声明中使用访问修饰符来控制哪些其他类可以调用构造函数。

------
**注意：**如果别的类不能调用 ````MyClass```` 构造器，它就不能直接创建 ````MyClass```` 对象。

------

#### 向方法或者构造器传递信息

方法或构造函数的声明声明了该方法或构造函数的参数的数量和类型。例如，以下是根据贷款金额，利率，贷款期限（期数）和贷款的未来价值计算住房贷款的每月付款的方法：

```java
public double computePayment(
                  double loanAmt,
                  double rate,
                  double futureValue,
                  int numPeriods) {
    double interest = rate / 100.0;
    double partial1 = Math.pow((1 + interest), 
                    - numPeriods);
    double denominator = (1 - partial1) / interest;
    double answer = (-loanAmt / denominator)
                    - ((futureValue * partial1) / denominator);
    return answer;
}
```

该方法有四个参数：贷款金额，利率，未来价值和期数。前三个是双精度浮点数，第四个是整数。参数在方法体中使用，并且在运行时将采用传入的参数的值。

------

**注意：**参数是指方法声明中的变量列表。 参数是调用方法时传递的实际值。 调用方法时，使用的参数必须与类型和顺序中的声明参数匹配。

------

**参数类型**

您可以将任何数据类型用于方法或构造函数的参数。这包括原始数据类型，如双精度，浮点数和整数，如在`computePayment`方法中看到的，以及引用数据类型，如对象和数组。

这是一个接受数组作为参数的方法示例。在这个例子中，该方法创建一个新的 `Polygon` 对象并从`Point`对象数组初始化它（假设`Point`是一个表示x，y坐标的类）：

```java
public Polygon polygonFrom(Point[] corners) {
    // method body goes here
}
```

------

**注意:** 如果你希望将一个方法传递给另一个方法，使用 [lambda expression](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 或者 [method reference](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html) 。

------

**任意数量的参数**

您可以使用名为 *varargs* 的构造将任意数量的值传递给方法。当您不知道将多少特定类型的参数传递给该方法时，您可以使用 *varargs*。这是手动创建数组的快捷方式（前一种方法可能使用了 *varargs* 而不是数组）。

要使用 varargs，请使用省略号（三个点，...），一个空格和参数名称，放在最后一个参数的类型之后。然后可以使用任何数量的参数调用该方法，包括none。

```java
public Polygon polygonFrom(Point... corners) {
    int numberOfSides = corners.length;
    double squareOfSide1, lengthOfSide1;
    squareOfSide1 = (corners[1].x - corners[0].x)
                     * (corners[1].x - corners[0].x) 
                     + (corners[1].y - corners[0].y)
                     * (corners[1].y - corners[0].y);
    lengthOfSide1 = Math.sqrt(squareOfSide1);

    // more method body code follows that creates and returns a 
    // polygon connecting the Points
}
```

你可以看到，在方法中，`corner`被视为一个数组。可以使用数组或参数序列调用该方法。在任何一种情况下，方法体中的代码都会将参数视为数组。

您最常见的是打印方法使用的 varargs 。例如，这个`printf`方法：

```java
public PrintStream printf(String format, Object... args)
```

允许你将任意数量的对象打印出来。它可以被如下调用：

```java
System.out.printf("%s: %d, %s%n", name, idnum, address);
```

或者：

```java
System.out.printf("%s: %d, %s, %s, %s%n", name, idnum, address, phone, email);
```

或者使用不同数量的参数。

**参数名称**

向方法或构造函数声明参数时，可以为该参数提供名称。此名称在方法体内用于引用传入的参数。

参数名称在它的作用域中必须是唯一的。它不能与同一方法或构造函数的另一个参数的名称相同，也不能是方法或构造函数中的局部变量的名称。

参数可以与类的某个字段具有相同的名称。如果是这种情况，则该参数称为 *shadow* 字段。 阴影字段可能使您的代码难以阅读，并且通常仅在设置特定字段的构造函数和方法中使用。例如，考虑以下`Circle`类及其`setOrigin`方法：

```java
public class Circle {
    private int x, y, radius;
    public void setOrigin(int x, int y) {
        ...
    }
}
```

````Circle```` 类有三个字段：````x````，````y```` 和 ````radius````。 ````setOrigin```` 方法有两个参数，每个参数与其中一个字段具有相同的名称。每个方法参数都会遮蔽共享其名称的字段。因此，在方法体内使用简单名称 ````x```` 或 ````y```` 指的是参数，而不是字段。要访问该字段，您必须使用限定名称。这将在本课程后面的标题为“使用 ````this```` 关键字”一节中讨论。

**传递基本类型参数**

原始参数，例如`int`或`double`，通过*值*传递给方法。 这意味着对参数值的任何更改都仅存在于方法的范围内。方法返回时，参数消失，对它们的任何更改都将丢失。这是一个例子：

```java
public class PassPrimitiveByValue {

    public static void main(String[] args) {
           
        int x = 3;
           
        // invoke passMethod() with 
        // x as argument
        passMethod(x);
           
        // print x to see if its 
        // value has changed
        System.out.println("After invoking passMethod, x = " + x);
           
    }
        
    // change parameter in passMethod()
    public static void passMethod(int p) {
        p = 10;
    }
}
```

程序输出：

```
After invoking passMethod, x = 3
```

**传递引用类型参数**

引用数据类型参数（如对象）也通过*值*传递给方法。这意味着当方法返回时，传入的引用仍然引用与以前相同的对象。*但是*，如果对象的字段的值具有适当的访问级别，则可以在方法中更改它们的值。

例如，考虑一个移动`Circle`对象的任意类中的方法：

```java
public void moveCircle(Circle circle, int deltaX, int deltaY) {
    // code to move origin of circle to x+deltaX, y+deltaY
    circle.setX(circle.getX() + deltaX);
    circle.setY(circle.getY() + deltaY);
        
    // code to assign a new reference to circle
    circle = new Circle(0, 0);
}
```

如下调用该方法：

```
moveCircle(myCircle, 23, 56)
```

在方法内部，````circle````最初是指 ````myCircle````。 该方法将 ````circle````引用的对象的 x 和 y 坐标（即 ````myCircle````）分别改变为23和56。方法返回时，这些更改将保持不变。然后 ````circle```` 被赋予对 ````x = y = 0```` 的新`Circle`对象的引用。但是，这种重新分配没有永久性，因为引用是按值传递的，不能更改。在方法中，````circle```` 指向的对象已经改变，但是，当方法返回时，`myCircle`仍然引用与调用方法之前相同的`Circle`对象。

### 对象

典型的 Java 程序会创建许多对象，如您所知，通过调用方法进行交互。通过这些对象交互，程序可以执行各种任务，例如实现 GUI，运行动画，或通过网络发送和接收信息。一旦对象完成了它的工作，它的资源就会被回收以供其他对象使用。

下面是个示例小程序，名为 [`CreateObjectDemo`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/CreateObjectDemo.java) ，创建三个对象：一个[`Point`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Point.java) 对象和两个 [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java) 对象。你需要这三个类的源文件来编译此程序。

```java
public class CreateObjectDemo {

    public static void main(String[] args) {
		
        // Declare and create a point object and two rectangle objects.
        Point originOne = new Point(23, 94);
        Rectangle rectOne = new Rectangle(originOne, 100, 200);
        Rectangle rectTwo = new Rectangle(50, 100);
		
        // display rectOne's width, height, and area
        System.out.println("Width of rectOne: " + rectOne.width);
        System.out.println("Height of rectOne: " + rectOne.height);
        System.out.println("Area of rectOne: " + rectOne.getArea());
		
        // set rectTwo's position
        rectTwo.origin = originOne;
		
        // display rectTwo's position
        System.out.println("X Position of rectTwo: " + rectTwo.origin.x);
        System.out.println("Y Position of rectTwo: " + rectTwo.origin.y);
		
        // move rectTwo and display its new position
        rectTwo.move(40, 72);
        System.out.println("X Position of rectTwo: " + rectTwo.origin.x);
        System.out.println("Y Position of rectTwo: " + rectTwo.origin.y);
    }
}

```

程序输出：

```
Width of rectOne: 100
Height of rectOne: 200
Area of rectOne: 20000
X Position of rectTwo: 23
Y Position of rectTwo: 94
X Position of rectTwo: 40
Y Position of rectTwo: 72

```

以下三节使用上面的示例来描述程序中对象的生命周期。通过它们，您将学习如何编写在您自己的程序中创建和使用对象的代码。您还将了解系统在对象生命周期结束后如何清理它们。

#### 创建对象

如你所见，类为对象提供了一张蓝图，你可以从类创建对象，下面的语句来自程序 [`CreateObjectDemo`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/CreateObjectDemo.java) 创建一个对象然后将它分配给一个变量：

```java
Point originOne = new Point(23, 94);
Rectangle rectOne = new Rectangle(originOne, 100, 200);
Rectangle rectTwo = new Rectangle(50, 100);

```

第一行创建一个 [`Point`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Point.java) 类对象，第二句和第三句分别创建一个 [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java) 类对象。

这些语句都包含三个部分（其中细节随后讨论）：

1. **申明**：变量名和对象类型组成变量声明。
2. **实例化**：`new` 关键字是 Java 语言的对象创建操作符。
3. **初始化**：`new` 操作符后面跟随对构造器的调用，用来初始化新创建的对象。

**创建变量来引用对象**

前面你已经学到如何声明变量：

```java
type name;
```

这行代码通知编译器你将要使用 *name* 来引用类型为 *type* 的数据。对基本类型的变量，这个声明语句同时也会为该变量分配合适的内存空间。

你也可以在单独一行代码中声明一个引用变量。比如：

```java
Point originOne;
```

如果你这样声明`originOne` ，在一个对象实际被创建并分配给该变量之前，该变量的值都是未定的。简单地声明一个引用类型变量并不会创建对象。因此，你需要使用 `new` 操作符，如下一节中所述。在使用该变量之前你必须分配一个对象给 `originOne` 。否则，你将得到一个编译错误。

此状态中的变量（当前不引用任何对象）可以如下所示（变量名称，````originOne````，以及未指向任何内容的引用）：

![originOne is null.](https://docs.oracle.com/javase/tutorial/figures/java/objects-null.gif)

**实例化一个类**

`new` 操作符通过为一个新的对象分配内存空间并返回该内存空间的引用的方式来实例化一个类。````new```` 操作符还调用该对象的构造器。

------

**注意：**阶段 “实例化一个类” 的含义与 “创建一个对象” 是相同的。当你创建一个对象，也就是创建该类的一个实例，因而也就是 “实例化” 一个类。

------

`new` 操作符需要一个单独的后缀参数：一个对构造器的调用。该构造器的名称提供了要实例化的类的名称。

`new` 操作符返回新创建的对象的引用。该引用通常被分配给一个相应数据类型的变量。如下所示：

```java
Point originOne = new Point(23, 94);
```

`new` 操作符返回的新对象的引用并不是必须分配给一个变量，也可以直接在表达式中使用。比如：

```java
int height = new Rectangle().height;
```

这个语句将在下一节中讨论。

**初始化一个对象**

`Point` 类代码：

```java
public class Point {
    public int x = 0;
    public int y = 0;
    //constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }
}
```

这个类包含一个构造器，你可以认出这个构造器，因为它的声明使用了类名称并且没有返回值类型。该构造器有两个整型参数，声明为 `(int a, int b)`。接下来的语句为这些参数提供了具体的值：

```java
Point originOne = new Point(23, 94);
```

这条语句的执行结果如下图所示：

![originOne now points to a Point object.](https://docs.oracle.com/javase/tutorial/figures/java/objects-oneRef.gif)

`Rectangle` 类代码，包含四个构造器：

````java
public class Rectangle {
    public int width = 0;
    public int height = 0;
    public Point origin;

    // four constructors
    public Rectangle() {
        origin = new Point(0, 0);
    }
    public Rectangle(Point p) {
        origin = p;
    }
    public Rectangle(int w, int h) {
        origin = new Point(0, 0);
        width = w;
        height = h;
    }
    public Rectangle(Point p, int w, int h) {
        origin = p;
        width = w;
        height = h;
    }

    // a method for moving the rectangle
    public void move(int x, int y) {
        origin.x = x;
        origin.y = y;
    }

    // a method for computing the area of the rectangle
    public int getArea() {
        return width * height;
    }
}
````

每个构造函数都允许您使用基本类型和引用类型为矩形的原点，宽度和高度提供初始值。如果一个类有多个构造函数，则它们必须具有不同的签名。Java 编译器根据参数的数量和类型区分构造函数。当 Java 编译器遇到以下代码时，它知道在 ````Rectangle```` 类中调用构造函数，该类需要一个 ````Point```` 参数，后跟两个整数参数：

```java
Rectangle rectOne = new Rectangle(originOne, 100, 200);
```

这会调用 ````Rectangle```` 的一个构造函数，它将 ````origin```` 初始化为 ````originOne````。此外，构造函数将 ````width```` 设置为100，将 ````height```` 设置为200。现在有两个对同一 ````Point```` 对象的引用 - 一个对象可以有多个引用，如下图所示：

![Now the rectangle's origin variable also points to the Point.](https://docs.oracle.com/javase/tutorial/figures/java/objects-multipleRefs.gif)

以下代码行调用 ````Rectangle```` 构造函数，该构造函数需要两个整数参数，这些参数提供 ````width```` 和 ````height```` 的初始值。如果检查构造函数中的代码，您将看到它创建了一个新的 ````Point```` 对象，其 ````x```` 和 ````y```` 值初始化为0：

```java
Rectangle rectTwo = new Rectangle(50, 100);
```

下面代码中使用的构造器没有使用任何参数，因此它被称为*无参构造器*：

```java
Rectangle rect = new Rectangle();
```

所有类至少有一个构造函数。如果类没有显式声明任何类，那么 Java 编译器会自动提供一个无参构造函数，称为*默认构造函数* 。此默认构造函数调用父类的无参数构造函数，如果类没有其他父级，则调用 ````Object```` 构造函数。如果父级没有构造函数（````Object```` 确实有构造函数），编译器将拒绝该程序。

#### 使用对象

一旦你创建了一个对象，你可能想要用它来做些事情。您可能需要使用其中一个字段的值，更改其中一个字段，或调用其中一个方法来执行操作。

**引用一个对象的字段**

对象字段通过它们的名称访问。你必须使用无歧义的字段名称。

你可以在字段所在的类内部使用简单的字段名称。比如，我们可以在 ````Rectangle```` 类中添加语句来打印 ````width```` 和 ````height```` ：

```java
System.out.println("Width and height are: " + width + ", " + height);
```

这种情况下， `width` 和 `height` 就是简单名称。

对象类之外的代码必须使用一个对象引用或者表达式，后面跟随点操作符 ````.```` ，后跟简单字段名。如下所示：

```java
objectReference.fieldName
```

例如，`CreateObjectDemo` 类中的代码位于 `Rectangle` 类的代码之外。因此，要引用名为 `rectOne` 的 `Rectangle` 对象中的 `origin`，`width` 和 `height` 字段，`CreateObjectDemo` 类必须分别使用名称`rectOne.origin`，`rectOne.width` 和 `rectOne.height`。该程序使用其中两个名称来显示`rectOne` 的 `width` 和 `height`：

```java
System.out.println("Width of rectOne: "  + rectOne.width);
System.out.println("Height of rectOne: " + rectOne.height);
```

尝试在 `CreateObjectDemo` 类中的代码中使用的简单名称 `width`和 `height` 没有意义 - 这些字段仅存在于对象中 - 并导致编译器错误。

稍后，该程序使用类似的代码来显示有关 `rectTwo` 的信息。相同类型的对象具有自己的相同实例字段的副本。因此，每个 `Rectangle` 对象都有名为 `origin`，`width` 和 `height` 的字段。通过对象引用访问实例字段时，将引用该特定对象的字段。`CreateObjectDemo` 程序中的两个对象 `rectOne` 和 `rectTwo` 具有不同的 `origin`，`width` 和 `height` 字段。

要访问字段，可以使用对象的命名引用（如前面的示例所示），也可以使用任何返回对象引用的表达式。回想一下 `newoperator` 返回对象的引用。因此，您可以使用 `new` 返回的值来访问新对象的字段：

```java
int height = new Rectangle().height;
```

该语句创建一个新的 `Rectangle` 对象并立即获得其高度。实质上，该语句计算 `Rectangle` 的默认高度。请注意，在执行此语句之后，程序不再具有对创建的 `Rectangle` 的引用，因为程序从未将引用存储在任何位置。该对象未被引用，其资源可由 Java 虚拟机自由回收。

**调用对象方法**

您还可以使用对象引用来调用对象的方法。将方法的简单名称附加到对象引用，并使用插入点运算符 `.`。此外，您在括号内提供该方法的任何参数。如果方法不需要任何参数，请使用空括号。

```java
objectReference.methodName(argumentList);
```

或者：

```java
objectReference.methodName();
```

`Rectangle` 类包含两个方法： `getArea()` 来计算长方形的面积， `move()` 用来改变长方形的位置。下面的代码展示了如何调用这两个方法：

```java
System.out.println("Area of rectOne: " + rectOne.getArea());
...
rectTwo.move(40, 72);
```

第一个语句调用 `rectOne` 的 `getArea()` 方法并显示结果。第二行移动 `rectTwo`，因为 `move()` 方法为对象的 `origin.x` 和 `origin.y` 分配新值。

与实例字段一样，`objectReference` 必须是对象的引用。您可以使用变量名称，但也可以使用任何返回对象引用的表达式。`new` 运算符返回一个对象引用，因此您可以使用 `new` 返回的值来调用新对象的方法：

```java
new Rectangle(100, 50).getArea()
```

表达式 `new Rectangle(100,50)` 返回引用 `Rectangle` 对象的对象引用。如图所示，您可以使用点表示法来调用新的 `Rectangle` 的 `getArea()` 方法来计算新矩形的面积。

某些方法（如 `getArea()`）返回一个值。对于返回值的方法，可以在表达式中使用方法调用。您可以将返回值分配给变量，使用它来做出决策或控制循环。此代码将 `getArea()` 返回的值赋给变量 `areaOfRectangle`：

```java
int areaOfRectangle = new Rectangle(100, 50).getArea();
```

请记住，在特定对象上调用方法与向该对象发送消息相同。在这种情况下，调用 `getArea()` 的对象就是构造函数返回的矩形。

**垃圾收集器**

某些面向对象的语言要求您跟踪所创建的所有对象，并在不再需要时明确销毁它们。明确地管理内存是单调乏味且容易出错的。Java平台允许您根据需要创建任意数量的对象（当然，受限于系统可以处理的对象），您不必担心会破坏它们。Java运行时环境在确定不再使用对象时删除对象。此过程称为垃圾回收。

当没有对该对象的引用时，对象有资格进行垃圾回收。当变量退出作用域时，通常会删除变量中保存的引用。或者，您可以通过将变量设置为特殊值 `null` 来显式删除对象引用。请记住，程序可以对同一个对象进行多次引用；在对象符合垃圾回收条件之前，必须删除对对象的所有引用。

Java 运行时环境具有垃圾收集器，可以定期释放不再引用的对象使用的内存。垃圾收集器在它认为合适的时机正确时自动完成其工作。

### 关于类的更多话题

本节介绍依赖于使用对象引用的类的更多方面以及您在前面的对象部分中了解到的 `.`运算符：

* 从方法返回值。
* `this`关键字。
* 类与实例成员。
* 访问控制。

#### 从方法返回值

一个方法返回调用它的代码的时机：

- 方法中所有的语句都执行完成，
- 执行到一个 `return` 语句，或者，
- 抛出一个异常 (稍后讨论)。

无论哪个首先发生都无所谓。

你在方法声明中声明方法的返回值类型。在方法体中，你使用 `return` 语句来返回值。

声明 `void` 的方法不返回任何值。它不需要包含 `return` 语句，不过它也可以包含。这种情况下，其中的 `return` 语句的作用是跳出控制流块同时退出该方法。可以简单地写成下面的形式：

```java
return;
```

如果你尝试从声明为 `void` 的方法中返回一个值，你将得到一个编译错误。

任何没有声明为 `void` 的方法都必须包含 `return` 语句并返回相应类型的返回值，如下：

```java
return returnValue;
```

返回的值的数据类型必须符合方法声明的返回值类型，你不能在声明返回布尔值的方法中返回整形数据。

 [`Rectangle`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java) 类中的 `getArea()` 方法返回一个整型数：

```java
// a method for computing the area of the rectangle
public int getArea() {
  return width * height;
}
```

这个方法返回表达式 `width*height` 的计算结果。

`getArea` 方法返回一个基本数据类型。方法也可以返回引用类型。比如，在一个维护 `Bicycle` 对象的程序中，我们可以有下面的方法：

```java
public Bicycle seeWhosFastest(Bicycle myBike, Bicycle yourBike, Environment env) {
    Bicycle fastest;
    // code to calculate which bike is 
    // faster, given each bike's gear 
    // and cadence and given the 
    // environment (terrain and wind)
    return fastest;
}
```

**返回一个类或者接口**

如果此部分让您感到困惑，请跳过它并在完成接口和继承课程后返回该部分。

当方法使用类名作为其返回类型（例如 `whosFastest`）时，返回对象的类型类必须是返回类型的子类或该类本身。假设您有一个类层次结构，其中 `ImaginaryNumber` 是 `java.lang.Number` 的子类，而 `java.lang.Number` 又是 `Object` 的子类，如下图所示。

![The class hierarchy for ImaginaryNumber](https://docs.oracle.com/javase/tutorial/figures/java/classes-hierarchy.gif)

`ImaginaryNumber` 的类继承层级结构。

现在假定你有一个方法声明返回一个 `Number` ：

```java
public Number returnANumber() {
    ...
}
```

`returnANumber` 方法可以返回 `ImaginaryNumber` 但是不能返回 `Object` 。 `ImaginaryNumber` 是一个 `Number` 因为它是 `Number` 的子类。但是，`Object` 不一定是 `Number`   - 它可以是 `String` 或其他类型。

您可以覆盖方法并定义它以返回原始方法的返回类型的子类，如下所示：

```java
public ImaginaryNumber returnANumber() {
    ...
}
```

这种称为*协变返回类型* 的技术意味着允许返回类型在与子类相同的方向上变化。

------

**注意:** 你也可以使用接口名称作为返回类型。这种情况下，返回的对象必须实现该接口。

------

#### 使用 `this` 关键字

在实例方法或者构造器内部，`this` 是*当前对象*的引用—该对象的方法或者构造器正在被调用。你可以使用 `this` 关键字在实例方法或者构造器中引用当前对象的任何成员。

**和字段共同使用 `this`**

最常见的使用 `this` 关键字的原因是字段被方法或者构造器参数遮蔽。

b比如，`Point` 类写成如下形式：

```java
public class Point {
    public int x = 0;
    public int y = 0;
        
    //constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }
}

```

也可能写成这样：

```java
public class Point {
    public int x = 0;
    public int y = 0;
        
    //constructor
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

```

构造函数的每个参数都会遮蔽对象的一个字段 - 构造函数内部的 `x` 是构造函数的第一个参数的本地副本。要引用`Point` 的字段 `x`，构造函数必须使用 `this.x` 。

**和构造器共同使用 `this`**

在构造器内部，你也可以使用 `this` 关键字调用该类的其它构造器。这种调用叫做*显式构造器调用*。下面是另一种形式的 `Rectangle` 类：

```java
public class Rectangle {
    private int x, y;
    private int width, height;
        
    public Rectangle() {
        this(0, 0, 1, 1);
    }
    public Rectangle(int width, int height) {
        this(0, 0, width, height);
    }
    public Rectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    ...
}
```

该类包含一组构造函数。每个构造函数都初始化一些或所有矩形的成员变量。构造函数为任何成员变量提供默认值，其初始值不是由参数提供的。例如，无参数构造函数在坐标 `0,0` 处创建 `1x1` 矩形。双参数构造函数调用四参数构造函数，传递宽度和高度，但始终使用 `0,0` 坐标。和以前一样，编译器根据参数的数量和类型确定要调用的构造函数。

如果存在，则另一个构造函数的调用必须是构造函数中的第一行。

#### 类成员的访问控制

访问级别修饰符决定其它类是否可以使用类的特定字段或者调用类的特定方法。下面是两种访问控制级别：

- 处于顶级水平 — `public` ，或者 *package-private* （隐式访问控制修饰符）。
- 处于成员的水平 — `public` ，`private` ， `protected` ，或者 *package-private* （隐式访问控制修饰符）。

可以使用修饰符 `public` 声明一个类，在这种情况下，该类对于所有类都可见。如果一个类没有修饰符（默认，也称为*包私有*），它只在自己的包中可见（包是相关类的命名组 - 您将在后面的课程中了解它们。）

在成员级别，您也可以使用 `public` 修饰符或隐式修饰符（*package-private*），就像使用顶级类一样，并且具有相同的含义。对于成员，还有两个额外的访问修饰符：`private` 和 `protected`。 `private` 修饰符指定只能在自己的类中访问该成员。`protected` 修饰符指定只能在其自己的包中访问该成员（与 *package-private* 一样），此外，还可以在另一个包中通过其类的子类访问该成员。

下表显示了每个修饰符允许的成员访问权限。

| Modifier    | Class | Package | Subclass | World |
| ----------- | ----- | ------- | -------- | ----- |
| `public`    | Y     | Y       | Y        | Y     |
| `protected` | Y     | Y       | Y        | N     |
| no modifier | Y     | Y       | N        | N     |
| `private`   | Y     | N       | N        | N     |

第一个数据列指示类本身是否可以访问由访问级别定义的成员。如您所见，类始终可以访问自己的成员。第二列指示与该类相同的包中的类（无论其父级是否有）可以访问该成员。第三列指示在此包外声明的类的子类是否可以访问该成员。第四列指示是否所有类都可以访问该成员。

访问级别以两种方式影响您。首先，当您使用来自其他源的类（例如 Java 平台中的类）时，访问级别将确定您自己的类可以使用的这些类的哪些成员。其次，当您编写一个类时，您需要确定每个成员变量和类中的每个方法应具有的访问级别。

让我们看一下类的集合，看看访问级别如何影响可见性。下图显示了此示例中的四个类以及它们之间的关系。

![Classes and Packages of the Example Used to Illustrate Access Levels](https://docs.oracle.com/javase/tutorial/figures/java/classes-access.gif)

用于说明访问级别的示例的类和包。

下表显示了Alpha类的成员对于可应用于它们的每个访问修饰符的可见性。

| Modifier    | Alpha | Beta | Alphasub | Gamma |
| ----------- | ----- | ---- | -------- | ----- |
| `public`    | Y     | Y    | Y        | Y     |
| `protected` | Y     | Y    | Y        | N     |
| no modifier | Y     | Y    | N        | N     |
| `private`   | Y     | N    | N        | N     |

------

选择访问级别的建议：

如果其他程序员使用您的类，您希望确保不会发生滥用错误。访问级别控制可以帮助您实现。

 - 使用对特定成员有意义的最严格的访问级别。使用 `private` ，除非你有充分的理由不使用它。
 - 避免除常量之外的 `public` 字段。（本教程中的许多示例都使用 `public` 字段。这可能有助于简明地说明某些要点，但不建议用于生产代码。）公共字段倾向于将您绑定到特定实现，并限制您更改代码的灵活性。

------

#### 理解类成员

本节中，我们讨论使用 `static` 关键字来创建属于类的字段和方法，而不属于该类的实例。

**类变量**

当从同一个类蓝图创建许多对象时，它们每个都有自己不同的实例变量副本。在`Bicycle`类的情况下，实例变量是 `cadence`，`gear` 和 `speed`。每个 `Bicycle` 对象都有自己的值，这些变量存储在不同的内存位置。

有时，您希望拥有所有对象共有的变量。这是通过 `static` 修饰符完成的。在声明中具有 `static` 修饰符的字段称为静态字段或类变量。它们与类相关联，而不是与任何对象相关联。该类的每个实例共享一个类变量，该变量位于内存中的一个固定位置。任何对象都可以更改类变量的值，但也可以在不创建类实例的情况下操作类变量。

例如，假设您要创建多个 `Bicycle` 对象并为每个对象分配序列号，从第一个对象开始为1。此 ID 号对每个对象都是唯一的，因此是一个实例变量。同时，您需要一个字段来跟踪已创建的 `Bicycle` 对象的数量，以便您知道要分配给下一个对象的 ID。这样的字段与任何单个对象无关，而与整个类相关。为此，您需要一个类变量 `numberOfBicycles`，如下所示：

````java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    // add an instance variable for the object ID
    private int id;
    
    // add a class variable for the
    // number of Bicycle objects instantiated
    private static int numberOfBicycles = 0;
        ...
}
````

类变量通过它所在的类名和它自己的名字引用：

```java
Bicycle.numberOfBicycles
```

这样就将它们是类变量表现的很清楚。

------

**注意：** 你也可以用一个对象引用来引用静态字段，如下：

```java
myBike.numberOfBicycles
```

不过我们不建议这种做法，因为这样不能很清楚地表示它们是类变量。

------

你可以使用 `Bicycle` 构造器来设定 `id` 实例变量并增加 `numberOfBicycles` 类变量：

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
    private int id;
    private static int numberOfBicycles = 0;
        
    public Bicycle(int startCadence, int startSpeed, int startGear){
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        // increment number of Bicycles
        // and assign ID number
        id = ++numberOfBicycles;
    }

    // new method to return the ID instance variable
    public int getID() {
        return id;
    }
        ...
}
```

**类方法**

Java 语言支持 `static` 变量的同时，还支持 `static` 方法。`static` 方法，就是在其声明中包含 `static` 修饰符，应该通过类名调用，而不需要创建类实例。如下：

```java
ClassName.methodName(args)
```

------

**注意：** 你也可以用一个对象引用来引用静态方法，如下：

```java
instanceName.methodName(args)
```

不过我们不建议这种做法，因为这样不能很清楚地表示它们是类方法。

------

`static` 方法的通常用来访问 `static` 字段。比如，我们可以在 `Bicycle` 类中添加一个 `static` 方法来访问 `numberOfBicycles` `static` 变量：

```java
public static int getNumberOfBicycles() {
    return numberOfBicycles;
}
```

并非所有实例和类变量和方法的组合都是允许的：

 - 实例方法可以直接访问实例变量和实例方法。
 - 实例方法可以直接访问类变量和类方法。
 - 类方法可以直接访问类变量和类方法。
 - 类方法**不能**直接访问实例变量或实例方法 - 它们必须使用对象引用。此外，类方法不能使用 `this` 关键字，因为没有 `this` 的实例可以引用。

**常量**

`static` 访问修饰符，与 `final` 访问修饰符结合使用，用来定义常量。`final` 修饰符表示该字段的值不能改变。

比如，下面的变量声明定义了一个名为 `PI` 的常量，其值为圆周率的近似值。

````java
static final double PI = 3.141592653589793
````

这种方式定义的常量不能被赋值，如果你的程序试图这么做就会发生编译错误。传统上，常量值的名称通常都是由大写字母组成。如果该名称由一个以上的词组成，则这些词由下划线 `_` 连接。

------

**注意：** 如果基本数据类型或者字符串被定义为常量，同时其值在编译期确定，编译器就会将代码中所有的该常量的名称替换为它的值。这被称为*编译期*常量。如果外部世界中的常量的值已经改变，则你需要重新编译所有使用该常量的类以获取该常量的当前值。

------

**`Bicycle` 类**

经过这一节的修改，`Bicycle` 类变成了：

````java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    private int id;
    
    private static int numberOfBicycles = 0;

        
    public Bicycle(int startCadence,
                   int startSpeed,
                   int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        id = ++numberOfBicycles;
    }

    public int getID() {
        return id;
    }

    public static int getNumberOfBicycles() {
        return numberOfBicycles;
    }

    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear(){
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}
````

#### 初始化字段

如你所见，你通常可以在声明字段时提供一个初始值：

````java
public class BedAndBreakfast {

    // initialize to 10
    public static int capacity = 10;

    // initialize to false
    private boolean full = false;
}
````

当初始化值可用并且初始化可以放在一行上时，这很有效。然而，这种形式的初始化由于其简单性而具有局限性。如果初始化需要一些逻辑（例如，错误处理或 `for` 循环来填充复杂的数组），则简单的赋值是不合适的。实例变量可以在构造函数中初始化，其中可以使用错误处理或其他逻辑。为了为类变量提供相同的功能，Java 编程语言包括静态初始化块。

------

**注意：** 没有必要在类定义的开头处声明字段，虽然这种做法是最常见的做法。不过在使用它们之前声明和初始化它们是必须的。

------

**静态初始化块**

*静态初始化块* 是由大括号包围起来的普通代码块，以 `static` 关键字引导。下面是个例子：

````java
static {
  // whatevet code is needed for initialization goes here
}
````

一个类可以包含任意数量的静态初始化块，它们可以出现在类主体的任意位置。运行时系统保证静态初始化块会按照它们在源代码中出现的顺序被调用。

另外一种静态代码块，你可以写一个私有静态方法：

````java
class Whatever {
    public static varType myVar = initializeClassVariable();
        
    private static varType initializeClassVariable() {

        // initialization code goes here
    }
}
````

私有静态方法的优点是，它们可以随后被重新使用，如果你需要重新初始化类变量。

**初始化实例成员**

通常，你可以将实例化和初始化变量的代码放入构造器。存在两种不同的方法来使用构造器来实例化变量：初始化块和 `final` 方法。

实例变量的初始化块看起来类似于静态初始化块，只是没有 `static` 关键字：

````java
{
  // whatever code is needed for initialization goes here
}
````

Java 编译器将初始化块复制到每个构造器中。因此，这种方法可以用来在多个构造器之间共享代码块。

`final` 方法不能在子类中被覆盖。这一点将在接口和继承章节中讨论。下面是使用 `final` 方法初始化实例变量的例子：

````java
class Whatever {
    private varType myVar = initializeInstanceVariable();
        
    protected final varType initializeInstanceVariable() {

        // initialization code goes here
    }
}
````

如果子类可能希望重用初始化方法，这尤其有用。该方法是 `final` 的，因为在实例初始化期间调用非 `final` 方法可能会导致问题。

#### 创建和使用类和对象小结

类声明为类命名，并用大括号包含类主体。类名称可以由修饰符引导。类主体包含字段、方法以及类的构造器。类使用字段保持静态信息，使用方法实现行为。构造器初始化类的实例，使用类名作为名称，形如一个没有返回值类型的方法。

控制类和成员的访问的方法相同：在它们的声明中使用访问修饰符，比如 `public` 等。

通过在成员声明中使用 `static` 关键字，你可以指定类变量或者类方法。没有声明为 `static` 的成员就隐式作为实例变量。类变量由所有类实例共享，可以通过类名称或者实例引用访问。类的实例获取每个实例变量的自己的副本，必须通过实例引用访问它们。

你可以使用 `new` 操作符和构造器从类创建对象。`new` 操作符返回新创建的对象的引用。你可以将该引用赋值给一个变量或者直接使用它。

可以通过使用限定名称来引用在声明它们的类之外的代码可访问的实例变量和方法。实例变量的限定名称如下所示：

````
objectReference.variableName
````

方法的全限定名称形如：

````
objectReference.methodName(argumentList)
````

或者：

````
objectReference.methodName()
````

垃圾收集器会自动清理未使用的对象。如果程序不再包含对它的引用，则不使用该对象。您可以通过将包含引用的变量设置为 `null`来显式删除引用。

### 嵌套类

Java 语言允许你在类内部定义另一个类。这种位于其它类内部的类被称为*内部类*，形如：

````java
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}
````

------

**术语：** 内部类分为两种：静态的和非静态的。声明为 `static` 的就是*静态嵌套类*。其它的称为*内部类*。

------

````java
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
````

嵌套类是它所在的类的成员。非静态的嵌套类（内部类）可以访问它所在的类的其它成员，即使它们被声明为 `private` 的。静态嵌套类不能访问它们所在的类的其它成员。作为 `OuterClass` 的成员，嵌套类可以被声明为 `private` ，`public`，`protected` 或者*package private* 。（回想一下，外部类只能声明为 `public` 或 `package private`）

**为什么使用嵌套类？**

使用嵌套类的令人信服的理由包括：

* **它是一种逻辑类分组仅在一个地方使用的方法**：如果一个类只对另一个类有用，那么将它嵌入该类并将两者保持在一起是合乎逻辑的。嵌套这样的“帮助类”使得它们的包更加简化。
* **它增加了封装**：考虑两个顶级类A和B，其中B需要访问A的成员，否则这些成员将被声明为私有。通过将类B隐藏在类A中，可以将A的成员声明为私有，并且B可以访问它们。另外，B本身可以对外部隐藏。
* **它可以带来更易读和可维护的代码**：在顶级类中嵌套小类会使代码更接近于使用它的位置。

**静态嵌套类**

与类方法和变量一样，静态嵌套类与其外部类相关联。和静态类方法一样，静态嵌套类不能直接引用其封闭类中定义的实例变量或方法：它只能通过对象引用来使用它们。

------

**注意：**静态嵌套类与其外部类（和其他类）的实例成员交互，就像任何其他顶级类一样。 实际上，静态嵌套类在行为上是一个顶级类，它已嵌套在另一个顶级类中以方便打包。

------

静态嵌套类通过包含它的类名访问：

```java
OuterClass.StaticNestedClass
```

比如，使用下面的语法来闯进静态嵌套类的对象：

```java
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
```

**内部类**

与实例方法和变量一样，内部类与其所在的类的实例相关联，并且可以直接访问该对象的方法和字段。此外，由于内部类与实例相关联，因此本身无法定义任何静态成员。

作为内部类的实例的对象存在于外部类的实例中。 考虑以下类：

````java
class OuterClass {
    ...
    class InnerClass {
        ...
    }
}
````

`InnerClass` 的实例只能存在于 `OuterClass` 的实例中，并且可以直接访问其所在类实例的方法和字段。

要实例化内部类，必须首先实例化外部类。然后，使用以下语法在外部对象中创建内部对象：

````java
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
````

有两种特殊的内部类： [local classes](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html) 和 [anonymous classes](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)。

**遮蔽**

如果特定作用域（例如内部类或方法定义）中的类型声明（例如成员变量或参数名称）与包含它的外部作用域中的另一个声明具有相同的名称，则内部作用域中的声明将遮蔽外部作用域中的声明。您不能仅通过其名称引用被遮蔽的声明。以下示例 `ShadowTest` 演示了这一点：

````java
public class ShadowTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            System.out.println("x = " + x);
            System.out.println("this.x = " + this.x);
            System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);
        }
    }

    public static void main(String... args) {
        ShadowTest st = new ShadowTest();
        ShadowTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}
````

程序输出：

````java
x = 23
this.x = 1
ShadowTest.this.x = 0
````

上面的例子定义了三个名为 `x` 的变量：类 `ShadowTest` 的成员变量，内部类 `FirstLevel` 的成员变量，以及方法 `methodInFirstLevel` 的参数。作为方法参数的变量 `x` 或遮蔽同名的内部类成员变量，因此，当你在方法中使用该变量时，它指的是方法参数。为了表示内部类的成员变量，可以使用 `this` 关键字表示包含当前作用域的外部作用域：

```java
System.out.println("this.x = " + this.x);
```

通过使用它们所属于的类的名称来引用更外层作用域中的成员变量。比如，下面的语句在方法`methodInFirstLevel` 中访问`ShadowTest`类的成员变量：

```java
System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);
```

**序列化**

强烈建议不要对内部类（包括本地类和匿名类）进行序列化。当Java编译器编译某些构造（如内部类）时，它会创建*合成结构* ；这些是类，方法，字段和其他在源代码中没有相应结构的结构。合成结构使 Java 编译器能够在不更改 JVM 的情况下实现新的 Java 语言功能。但是，合成结构可以在不同的 Java 编译器实现之间变化，这意味着 `.class` 文件也可以在不同的实现之间变化。因此，如果序列化内部类，然后使用不同的 JRE 实现反序列化，则可能存在兼容性问题。有关在编译内部类时生成的合成结构的更多信息，请参阅获  [Obtaining Names of Method Parameters](https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html) 一节中的  [Implicit and Synthetic Parameters](https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html#implcit_and_synthetic) 部分。

#### 内部类示例

为了观察使用中的内部类，首先考虑数组。在下面的例子中，你创建一个数组，用整型数值填满它，然后以升序输出其中偶数下标的数值。

[`DataStructure.java`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java) 例子由以下内容组成：

- `DataStructure` 外部类，包含一个构造器来创建 `DataStructure` 的实例，该实例包含一个填满顺序整型数值的数组，同时还包含一个方法将数组中偶数下标元素值打印出来。
- `EvenIterator` 内部类，实现了 `DataStructureIterator`  接口，继承了 [`Iterator`](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)`<` [`Integer`](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)`>` 接口。迭代器被用来遍历一个数据结构，同时还有相应的方法来检测是否到达最后一个元素、获取当前元素以及删除下一个元素。
- `main` 方法实例化一个 `DataStructure` 对象(`ds`)，然后调用 `printEven` 方法来打印数组 `arrayOfInts` 中偶数下标的元素值。

````java
public class DataStructure {
    
    // Create an array
    private final static int SIZE = 15;
    private int[] arrayOfInts = new int[SIZE];
    
    public DataStructure() {
        // fill the array with ascending integer values
        for (int i = 0; i < SIZE; i++) {
            arrayOfInts[i] = i;
        }
    }
    
    public void printEven() {
        
        // Print out values of even indices of the array
        DataStructureIterator iterator = this.new EvenIterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
    }
    
    interface DataStructureIterator extends java.util.Iterator<Integer> { } 

    // Inner class implements the DataStructureIterator interface,
    // which extends the Iterator<Integer> interface
    
    private class EvenIterator implements DataStructureIterator {
        
        // Start stepping through the array from the beginning
        private int nextIndex = 0;
        
        public boolean hasNext() {
            
            // Check if the current element is the last in the array
            return (nextIndex <= SIZE - 1);
        }        
        
        public Integer next() {
            
            // Record a value of an even index of the array
            Integer retValue = Integer.valueOf(arrayOfInts[nextIndex]);
            
            // Get the next even element
            nextIndex += 2;
            return retValue;
        }
    }
    
    public static void main(String s[]) {
        
        // Fill the array with integer values and print out only
        // values of even indices
        DataStructure ds = new DataStructure();
        ds.printEven();
    }
}
````

程序输出：

````
0 2 4 6 8 10 12 14 
````

请注意，`EvenIterator` 类直接引用 `DataStructure` 对象的 `arrayOfInts` 实例变量。

您可以使用内部类来实现帮助程序类，例如本示例中显示的帮助程序类。要处理用户界面事件，您必须知道如何使用内部类，因为事件处理机制会广泛使用它们。

**局部类和匿名类**

还有两种类型的内部类。您可以在方法体内声明内部类。这些类称为 [local classes](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html)。您还可以在方法体内声明内部类，而无需命名该类。这些类称为 [anonymous classes](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)。

**修饰符**

您可以对内部类使用与外部类的其他成员相同的修饰符。例如，您可以使用访问修饰符 `private`，`public` 和 `protected` 来限制对内部类的访问，就像您使用它们来限制对其他类成员的访问一样。

#### 局部类

局部类是在代码块中声明的类，所谓的代码块就是配对的括号包围的若干条语句。你通常可以发现定义在方法体中的局部类。

本节涵盖了以下主题：

- [声明局部类](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#declaring-local-classes)
- 访问外部类的成员
  - [遮蔽和局部类](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#shadowing-and-local-classes)
- [局部类类似于内部类](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#local-classes-are-similar-to-inner-classes)

**声明局部类**

你可以在任何代码块中定义局部类 (参考 [Expressions, Statements, and Blocks](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html) 获取更多信息)。比如，你可以在方法主体中定义局部类，在 `for` 循环内部，或者在 `if` 语句块内部。

下面的例子，[`LocalClassExample`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LocalClassExample.java)， 校验两个电话号码。它在方法 `validatePhoneNumber` 中定义局部类 `PhoneNumber` ：

```java
public class LocalClassExample {
  
    static String regularExpression = "[^0-9]";
  
    public static void validatePhoneNumber(
        String phoneNumber1, String phoneNumber2) {
      
        final int numberLength = 10;
        
        // Valid in JDK 8 and later:
       
        // int numberLength = 10;
       
        class PhoneNumber {
            
            String formattedPhoneNumber = null;

            PhoneNumber(String phoneNumber){
                // numberLength = 7;
                String currentNumber = phoneNumber.replaceAll(
                  regularExpression, "");
                if (currentNumber.length() == numberLength)
                    formattedPhoneNumber = currentNumber;
                else
                    formattedPhoneNumber = null;
            }

            public String getNumber() {
                return formattedPhoneNumber;
            }
            
            // Valid in JDK 8 and later:

//            public void printOriginalNumbers() {
//                System.out.println("Original numbers are " + phoneNumber1 +
//                    " and " + phoneNumber2);
//            }
        }

        PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);
        PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);
        
        // Valid in JDK 8 and later:

//        myNumber1.printOriginalNumbers();

        if (myNumber1.getNumber() == null) 
            System.out.println("First number is invalid");
        else
            System.out.println("First number is " + myNumber1.getNumber());
        if (myNumber2.getNumber() == null)
            System.out.println("Second number is invalid");
        else
            System.out.println("Second number is " + myNumber2.getNumber());

    }

    public static void main(String... args) {
        validatePhoneNumber("123-456-7890", "456-7890");
    }
}
```

该示例通过首先从电话号码中删除除0到9之外的所有字符来验证电话号码。之后，它检查电话号码是否包含正好十位数（北美电话号码的长度）。此示例打印以下内容：

```java
First number is 1234567890
Second number is invalid
```

**访问外部类成员**

局部类可以访问它的外部类的成员。在上面的例子中，`PhoneNumber` 构造器访问成员 `LocalClassExample.regularExpression`。

另外，局部类可以访问局部变量。不过局部类只能访问声明为 `final` 的局部变量。当局部类访问包围它的代码块中的局部变量或者参数时，它*捕获*那些变量和参数。比如， `PhoneNumber` 构造器可以访问局部变量 `numberLength` 因为它被声明为 `final`；`numberLength` 是*被捕获*的变量。

但是，从Java SE 8开始，本地类可以访问包围它的代码块的 `final` 或者等效 `final` 的局部变量和参数。在初始化之后其值永远不会改变的变量或参数就是等效 `final` 的。例如，假设变量 `numberLength` 未声明为 `final`，并且您在`PhoneNumber` 构造函数中添加下面例子中的赋值语句，以将有效电话号码的长度更改为7位数：

```java
PhoneNumber(String phoneNumber) {
    numberLength = 7;
    String currentNumber = phoneNumber.replaceAll(
        regularExpression, "");
    if (currentNumber.length() == numberLength)
        formattedPhoneNumber = currentNumber;
    else
        formattedPhoneNumber = null;
}
```

由于这个赋值语句，变量 `numberLength` 不再是 `final` 等效的。因此，Java编译器生成类似于 “local variables referenced from an inner class must be final or effectively final" 的错误消息，其中内部类 `PhoneNumber` 尝试访问`numberLength` 变量：

```java
if (currentNumber.length() == numberLength)
```

从Java SE 8开始，如果在方法中声明本地类，它可以访问方法的参数。例如，您可以在 `PhoneNumberlocal` 类中定义以下方法：

```java
public void printOriginalNumbers() {
    System.out.println("Original numbers are " + phoneNumber1 +
        " and " + phoneNumber2);
}
```

`printOriginalNumbers` 方法访问 `validatePhoneNumber` 方法的参数 `phoneNumber1` 和 `phoneNumber2` 。

**遮蔽和局部类**

在一个局部类中的类型声明（比如一个变量）遮蔽外部作用域中的同名声明。参考 [Shadowing](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing) 获取更多信息。

**局部类类似于内部类**

局部类类似于内部类，因为他们不能定义或者声明任何静态成员。静态方法中的局部类，比如上面的 `PhoneNumber` 类，定义在静态方法 `validatePhoneNumber` 内部，只能引用外部类中的静态成员。例如，如果你没有将成员变量 `regularExpression` 定义为静态变量，则 Java 编译器会产生类似于 "no-static variable regularExpression cannot be referenced from a static context" 的错误信息。

局部类是非静态的，因为它们访问外部代码块的实例成员。因此它们不能包含大多数种类的静态声明。

你不能在一个代码块中声明一个接口，接口本质上是静态的。比如，下面的代码块无法通过编译：

````java
public void greetInEnglish() {
    interface HelloThere {
       public void greet();
    }
    class EnglishHelloThere implements HelloThere {
        public void greet() {
           System.out.println("Hello " + name);
        }
    }
    HelloThere myGreeting = new EnglishHelloThere();
    myGreeting.greet();
}
````

你不能在一个局部类中声明静态初始化器或者静态成员接口。下面的代码同样不能通过编译。编译器将会产生类似于 "modifier 'static' is only allowed in constant variable declaration" ，当它遇到该方法定义：

````java
public void sayGoodbyeInEnglish() {
    class EnglishGoodbye {
        public static void sayGoodbye() {
            System.out.println("Bye bye");
        }
    }
    EnglishGoodbye.sayGoodbye();
}
````

局部类可以具有静态成员，前提是它们是常量变量。（常量变量是基本类型或 `String` 类型的变量，声明为 `final` 并使用编译时常量表达式初始化。编译时常量表达式通常是可在编译时计算的字符串或算术表达式。参考  [Understanding Class Members](https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html) 了解更多信息。）以下代码可以通过编译，因为静态成员 `EnglishGoodbye.farewell` 是一个常量变量：

````java
public void sayGoodbyeInEnglish() {
    class EnglishGoodbye {
        public static final String farewell = "Bye bye";
        public void sayGoodbye() {
            System.out.println(farewell);
        }
    }
    EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();
    myEnglishGoodbye.sayGoodbye();
}
````

#### 匿名类

匿名类使您可以使代码更简洁。它们使您能够同时声明和实例化一个类。它们就像局部类，除了它们没有名字。如果您只需要使用局部类一次，请使用它们。

本节包括以下主题

- [声明匿名类](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#declaring-anonymous-classes)
- [匿名类的语法](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#syntax-of-anonymous-classes)
- [访问外部作用域的局部变量，以及声明和访问匿名类的成员](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#accessing)
- [匿名类的示例](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#examples-of-anonymous-classes)

**声明匿名类**

虽然局部类是类声明，但匿名类是表达式，这意味着您在另一个表达式中定义该类。以下示例[`HelloWorldAnonymousClasses`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/HelloWorldAnonymousClasses.java) 在局部变量 `frenchGreeting` 和 `spanishGreeting` 的初始化语句中使用匿名类，但使用本地类来初始化变量 `englishGreeting`：

````java
public class HelloWorldAnonymousClasses {
  
    interface HelloWorld {
        public void greet();
        public void greetSomeone(String someone);
    }
  
    public void sayHello() {
        
        class EnglishGreeting implements HelloWorld {
            String name = "world";
            public void greet() {
                greetSomeone("world");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Hello " + name);
            }
        }
      
        HelloWorld englishGreeting = new EnglishGreeting();
        
        HelloWorld frenchGreeting = new HelloWorld() {
            String name = "tout le monde";
            public void greet() {
                greetSomeone("tout le monde");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Salut " + name);
            }
        };
        
        HelloWorld spanishGreeting = new HelloWorld() {
            String name = "mundo";
            public void greet() {
                greetSomeone("mundo");
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println("Hola, " + name);
            }
        };
        englishGreeting.greet();
        frenchGreeting.greetSomeone("Fred");
        spanishGreeting.greet();
    }

    public static void main(String... args) {
        HelloWorldAnonymousClasses myApp =
            new HelloWorldAnonymousClasses();
        myApp.sayHello();
    }            
}
````

**匿名类语法**

如前所述，一个匿名类是一个表达式。匿名类表达式的语法看起来像是调用构造器，除了该代码块中包含一个类定义。

考虑 `frenchGreeting` 对象的实例化：

````java
HelloWorld frenchGreeting = new HelloWorld() {
    String name = "tout le monde";
    public void greet() {
        greetSomeone("tout le monde");
    }
    public void greetSomeone(String someone) {
        name = someone;
        System.out.println("Salut " + name);
    }
};
````

匿名类表达式由以下部分组成：

* `new` 操作符

* 类实现的接口名称或者类扩展的类名称。在上述例子中，匿名类实现了 `HelloWorld` 接口。
* 包含构造函数的参数的括号，就像普通的类实例创建表达式一样。注意：实现接口时，没有构造函数，因此您使用一对空括号，如本例所示。
* 一个主体，类声明主体。更特殊的，在这个主体中，允许方法声明，而不允许语句。

因为匿名类定义是一个表达式，它必须是一条语句的一部分。在这个例子中，匿名类表达式是 `frenchGreeting` 对象实例化语句的一部分。(这就是为什么在右大括号之后是一个分号)

**访问外部作用域的局部变量，以及声明和访问匿名类的成员**

类似于局部类，匿名类能够 [捕获变量](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#accessing-members-of-an-enclosing-class) ；它们同样可以访问外围作用域中的局部变量：

- 匿名类可以访问包围它的类的成员。
- 匿名类不能访问包围它的外围作用域中的没有声明为 `final` 和等效 `final` 的局部变量。
- 类似于嵌套类，匿名类中的类型声明（比如一个变量）会遮蔽外围作用域中的同名声明。参考 [Shadowing](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing) 获取更多信息。

匿名类作为局部类起成员也有相同的限制：

* 您不能在匿名类中声明静态初始化程序或成员接口。
* 匿名类可以具有静态成员，前提是它们是常量变量。

注意你可以在匿名类中声明下以下内容：

- 字段
- 额外的方法（即使他们没有实现超类型的任何方法）
- 实例初始化器
- 局部类

不过，你不能在匿名类中声明构造器。

**匿名类示例**

匿名类通常用于图形用户界面程序开发。

考虑下面的 JavaFX 例子 [`HelloWorld.java`](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) (来自 [Hello World, JavaFX Style](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) 在 [Getting Started with JavaFX](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/javafx_get_started.htm))。该例子创建了一个框架包含 **Say 'Hello World'** 按钮：

````java

import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
 
public class HelloWorld extends Application {
    public static void main(String[] args) {
        launch(args);
    }
    
    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Hello World!");
        Button btn = new Button();
        btn.setText("Say 'Hello World'");
        btn.setOnAction(new EventHandler<ActionEvent>() {
 
            @Override
            public void handle(ActionEvent event) {
                System.out.println("Hello World!");
            }
        });
        
        StackPane root = new StackPane();
        root.getChildren().add(btn);
        primaryStage.setScene(new Scene(root, 300, 250));
        primaryStage.show();
    }
}
````

在此示例中，方法调用 `btn.setOnAction` 指定在选择 **Say“Hello World”** 按钮时发生的情况。此方法需要 `EventHandler <ActionEvent>` 类型的对象。`EventHandler <ActionEvent>` 接口只包含一个方法 `handle`。该示例使用匿名类表达式，而不是使用新类实现此方法。请注意，此表达式是传递给 `btn.setOnAction` 方法的参数。

因为 `EventHandler <ActionEvent>` 接口只包含一个方法，所以可以使用 lambda 表达式而不是匿名类表达式。有关更多信息，请参阅[Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)表达式一节。

匿名类是实现包含两个或更多方法的接口的理想选择。以下 JavaFX 示例来自 UI 控件的自定义部分。突出显示的代码创建一个仅接受数值的文本字段。它通过重写从 `TextInputControl` 类继承的 `replaceText` 和 `replaceSelection` 方法，使用匿名类重新定义 `TextField` 类的默认实现。

````java
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class CustomTextFieldSample extends Application {
    
    final static Label label = new Label();
 
    @Override
    public void start(Stage stage) {
        Group root = new Group();
        Scene scene = new Scene(root, 300, 150);
        stage.setScene(scene);
        stage.setTitle("Text Field Sample");
 
        GridPane grid = new GridPane();
        grid.setPadding(new Insets(10, 10, 10, 10));
        grid.setVgap(5);
        grid.setHgap(5);
 
        scene.setRoot(grid);
        final Label dollar = new Label("$");
        GridPane.setConstraints(dollar, 0, 0);
        grid.getChildren().add(dollar);
        
        final TextField sum = new TextField() {
            @Override
            public void replaceText(int start, int end, String text) {
                if (!text.matches("[a-z, A-Z]")) {
                    super.replaceText(start, end, text);                     
                }
                label.setText("Enter a numeric value");
            }
 
            @Override
            public void replaceSelection(String text) {
                if (!text.matches("[a-z, A-Z]")) {
                    super.replaceSelection(text);
                }
            }
        };
 
        sum.setPromptText("Enter the total");
        sum.setPrefColumnCount(10);
        GridPane.setConstraints(sum, 1, 0);
        grid.getChildren().add(sum);
        
        Button submit = new Button("Submit");
        GridPane.setConstraints(submit, 2, 0);
        grid.getChildren().add(submit);
        
        submit.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                label.setText(null);
            }
        });
        
        GridPane.setConstraints(label, 0, 1);
        GridPane.setColumnSpan(label, 3);
        grid.getChildren().add(label);
        
        scene.setRoot(grid);
        stage.show();
    }
 
    public static void main(String[] args) {
        launch(args);
    }
}
````

#### Lambda 表达式

匿名类的一个问题是，如果匿名类的实现非常简单，例如只包含一个方法的接口，那么匿名类的语法可能看起来不实用且不清楚。 在这些情况下，您通常会尝试将功能作为参数传递给另一个方法，例如当有人单击按钮时应采取的操作。Lambda表达式使您可以执行此操作，将功能视为方法参数，或将代码视为数据。

前面一个小节，[Anonymous Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)，向你展示了如何实现一个基类而必须要给它一个名称。尽管这通常比命名类要简洁一些，但是即使是对只包含一个方法的类来说，匿名类都似乎仍然有些复杂和繁琐。Lambda 表达式允许你更简洁地表达单方法类的实例。

本小节包含以下主体：

- [Lambda表达式的理想用例](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#use-case)
  - [方法1：创建搜索匹配一个特征的成员的方法](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach1)
  - [方法2：创建更多广义搜索方法](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach2)
  - [方法3：在局部类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3)
  - [方法4：在匿名类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach4)
  - [方法5：使用Lambda表达式指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach5)
  - [方法6：将标准函数式接口与Lambda表达式一起使用](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach6)
  - [方法7：在整个应用程序中使用Lambda表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach7)
  - [方法8：更广泛地使用泛型](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach8)
  - [方法9：使用接受Lambda表达式作为参数的聚合操作](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach9)
- [GUI应用程序中的Lambda表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#lambda-expressions-in-gui-applications)
- [Lambda表达式的语法](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax)
- [访问外围作用域的局部变量](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#accessing-local-variables)
- [目标类型](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing)
  - [目标类型和方法参数](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-types-and-method-arguments)
- [序列化](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#serialization)

**Lambda表达式的理想用例**

假设您正在创建社交网络应用程序。您希望创建一项功能，使管理员能够对满足特定条件的社交网络应用程序成员执行任何类型的操作，例如发送消息。下表详细描述了此用例：

| 字段     | 描述                                       |
| ------ | ---------------------------------------- |
| 名字     | 在选中的成员上执行动作                              |
| 主操作员   | 管理员                                      |
| 前置条件   | 管理员登入系统                                  |
| 后置条件   | 动作只在符合特定条件的成员身上执行                        |
| 主要成功场景 | 管理员指定要对其执行特定操作的成员的条件。管理员指定要对这些选定成员执行的操作。管理员选择**提交**按钮。系统查找符合指定条件的所有成员。系统执行指定的操作。对所有匹配成员采取行动。 |
| 扩展     | 1A。管理员可以选择在指定要执行的操作之前或选择**提交**按钮之前预览符合指定条件的成员。 |
| fa     | mei                                      |

假设此社交网络应用程序的成员由以下 [`Person`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Person.java)类表示：

````java
public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }

    public void printPerson() {
        // ...
    }
}
````

假设您的社交网络应用程序的成员存储在 `List <Person>` 实例中。

本节首先介绍这种用例的简单方法。它使用局部类和匿名类改进了这种方法，然后使用 lambda 表达式以高效和简洁的方法完成。在示例 `RosterTest` 中找到本节中描述的代码。

**方法1：创建搜索匹配一个特征的成员的方法**

一种简单的方法是创建几种方法 ，每种方法都会搜索与一个特征匹配的成员，例如性别或年龄。以下方法打印超过指定年龄的会员：

```java
public static void printPersonsOlderThan(List<Person> roster, int age) {
    for (Person p : roster) {
        if (p.getAge() >= age) {
            p.printPerson();
        }
    }
}
```

**注意**:  [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) 是一个有序 [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)。一个 *集合* 是一个对象，它将多个元素组织称为一个单独的单元。集合用来存储、查询、操作依据传输聚合数据。有关集合的更多信息，参考 [Collections](https://docs.oracle.com/javase/tutorial/collections/index.html) 。

这种方法可能会使您的应用程序变得脆弱，这是由于引入了更新（例如更新的数据类型）导致应用程序无法工作的可能性。假设您升级应用程序并更改 `Person` 类的结构，使其包含不同的成员变量，也许该类记录和测量年龄与不同的数据类型或算法。您必须重写大量 API 以适应此更改。此外，这种方法是不必要的限制。例如，如果您想要打印年龄小于某个年龄的会员，该怎么办？

**方法2：创建更多广义搜索方法**

下面的方法比 `printPersonOlderThan` 更一般，打印特定年龄范围的会员：

```java
public static void printPersonsWithinAgeRange(
    List<Person> roster, int low, int high) {
    for (Person p : roster) {
        if (low <= p.getAge() && p.getAge() < high) {
            p.printPerson();
        }
    }
}
```

如果您想要打印指定性别的成员，或指定性别和年龄范围的组合，该怎么办？如果您决定更改 `Person` 类并添加其他属性（如关系状态或地理位置），该怎么办？虽然这种方法比 `printPersonsOlderThan` 更通用，但是尝试为每个可能的搜索查询创建单独的方法仍然会导致代码脆弱。您可以将在不同类中按照不同条件进行搜索的代码分开。

**方法3：在局部类中指定搜索条件代码**

下面的方法打印匹配到你指定 的搜索条件的会员：

```java
public static void printPersons(
    List<Person> roster, CheckPerson tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}
```

此方法通过调用`tester.test`方法检查`List`参数`roster`中包含的每个`Person`实例是否满足`CheckPerson`参数`tester`中指定的搜索条件。如果方法`tester.test`返回`true`值，则在`Person`实例上调用方法`printPersons`。

要指定搜索条件，请实现`CheckPerson`接口：

```
interface CheckPerson {
    boolean test(Person p);
}
```

下面的类通过指定方法`test`的实现来实现`CheckPerson`接口。此方法筛选符合美国选择性服务条件的会员：如果其`Person`参数为男性且年龄介于18和25之间，则返回`true`值：

```java
class CheckPersonEligibleForSelectiveService implements CheckPerson {
    public boolean test(Person p) {
        return p.gender == Person.Sex.MALE &&
            p.getAge() >= 18 &&
            p.getAge() <= 25;
    }
}
```

为了使用这个类，你创建一个它的新的实例病调用 `printPersons` 方法：

```java
printPersons(
    roster, new CheckPersonEligibleForSelectiveService());
```

虽然这种方法不那么脆弱 - 如果你改变`Person`的结构，你不必重写方法 - 你还有其他代码：你计划在你的应用程序中执行的每个搜索的新接口和局部类。因为`CheckPersonEligibleForSelectiveService`实现了一个接口，所以您可以使用匿名类而不是局部类，并且无需为每次搜索声明一个新类。

**方法4：在匿名类中指定搜索条件代码**

以下调用方法`printPersons`的一个参数是一个匿名类，它过滤了符合美国选择性服务条件的成员：男性和年龄在18到25岁之间：

```java
printPersons(
    roster,
    new CheckPerson() {
        public boolean test(Person p) {
            return p.getGender() == Person.Sex.MALE
                && p.getAge() >= 18
                && p.getAge() <= 25;
        }
    }
);
```

此方法减少了所需的代码量，因为您不必为要执行的每个搜索创建新类。但是，考虑到`CheckPerson`接口只包含一个方法，匿名类的语法很笨重。在这种情况下，您可以使用lambda表达式而不是匿名类，如下一节中所述。

**方法5：使用Lambda表达式指定搜索条件代码**

`CheckPerson` 接口是一个*函数式接口*。函数式接口指的是仅仅包含一个[abstract method](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html) （函数式接口可以包含一个或者多个 [default methods](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html) 或者 [static methods](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static) 。）的任何接口。因为函数式接口只包含一个抽象方法，当你实现该接口时就可以忽略该方法名称。为了这样做，不再使用匿名类表达式，而是使用*lambda 表达式*，如下面例子所示：

```java
printPersons(
    roster,
    (Person p) -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);
```

参考 [Syntax of Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax) 获取更多有关如何定义 lambda 表达式的信息。

您可以使用标准函数式接口代替`CheckPerson`接口，这可以进一步减少所需的代码量。

**方法6：将标准函数式接口与Lambda表达式一起使用**

重新考虑 `CheckPerson` 接口：

```java
interface CheckPerson {
    boolean test(Person p);
}
```

这是一个非常简单的接口。它是一个函数式接口，因为只包含一个抽象方法。该方法携带一个参数并返回一个 `boolean` 值。该方法太简单而不值得在你的应用中定义一个。因此，JDK 定义了若干标准函数式接口，放在包 `java.util.function` 中。

比如，你可以使用 `Predicate<T>` 接口来替换 `CheckPerson` 。该接口包含方法 `boolean test(T t)`：

```java
interface Predicate<T> {
    boolean test(T t);
}
```

接口 `Predicate<T>` 是一个泛型接口的例子。(有关泛型的更多信息，参考 [Generics (Updated)](https://docs.oracle.com/javase/tutorial/java/generics/index.html) 章节。) 泛型类型 (比如泛型接口) 在尖括号 (`<>`)中指定一个或者多个类型参数。该接口值包含一个类型参数， `T` 。当你使用实际类型参数声明或者实例化一个泛型类型时，你将拥有一个参数化类型。比如，下面的例子是参数化类型 `Predicate<Person>` ：

```java
interface Predicate<Person> {
    boolean test(Person t);
}
```

参数化类型包含一个方法，该方法的返回类型和参数与 `CheckPerson.boolean test(Person p)` 相同。接下来，你可以使用 `Predicate<T>` 替代 `CheckPerson` 如下面例子所示：

```java
public static void printPersonsWithPredicate(
    List<Person> roster, Predicate<Person> tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}
```

由此，下面的方法调用与你在 [方法3：在局部类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3) 中调用 `printPersons` 一样可以获取符合选择性服务条件的会员：

```java
printPersonsWithPredicate(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25
);
```

这并不是在方法中使用 lambda 表达式的唯一方式。下面的内容将介绍使用 lambda 表达式的其它方式。

**方法7：在整个应用程序中使用Lambda表达式**

重新考虑方法 `printPersonsWithPredicate` 以查看可以使用 lambda 表达式的其他位置：

```java
public static void printPersonsWithPredicate(
    List<Person> roster, Predicate<Person> tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}
```

此方法检查 `List` 参数名单中包含的每个 `Person` 实例是否满足 `Predicate` 参数测试器中指定的条件。如果 `Personinstance` 确实满足 `tester` 所指定的条件，则在 `Person` 实例上调用 `printPersron` 方法。

您可以指定在满足测试人员指定条件的 `Person` 实例上执行的不同操作，而不是调用方法 `printPerson` 。您可以使用 lambda 表达式指定此操作。假设你想要一个类似于 `printPerson` 的 lambda 表达式，它接受一个参数（`Person` 类型的对象）并返回 `void` 。请记住，要使用 lambda 表达式，您需要实现一个函数式接口。在这种情况下，您需要一个包含抽象方法的函数式接口，该方法可以接受一个 `Person` 类型的参数并返回 `void` 。 `Consumer <T>` 接口包含具有这些特征的 `void accept(T t)`方法。以下方法将调用 `p.printPerson()` 替换为调用方法 `accept` 的 `Consumer <Person>` 实例：

```java
public static void processPersons(
    List<Person> roster,
    Predicate<Person> tester,
    Consumer<Person> block) {
        for (Person p : roster) {
            if (tester.test(p)) {
                block.accept(p);
            }
        }
}
```

由此，下面的方法调用与你在 [方法3：在局部类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3) 中调用 `printPersons` 一样可以获取符合选择性服务条件的会员。用于打印会员的 lambda 表达式如下：

```java
processPersons(
     roster,
     p -> p.getGender() == Person.Sex.MALE
         && p.getAge() >= 18
         && p.getAge() <= 25,
     p -> p.printPerson()
);
```

如果您想要对会员的个人资料进行更多操作而不是打印出来，该怎么办？ 假设您要验证成员的个人资料或检索他们的联系信息？ 在这种情况下，您需要一个包含返回值的抽象方法的函数式接口。 `Function <T，R>` 接口包含方法 `R apply(T t)` 。 以下方法检索参数 `mapper` 指定的数据，然后在其上执行参数 `block` 指定的操作：

```java
public static void processPersonsWithFunction(
    List<Person> roster,
    Predicate<Person> tester,
    Function<Person, String> mapper,
    Consumer<String> block) {
    for (Person p : roster) {
        if (tester.test(p)) {
            String data = mapper.apply(p);
            block.accept(data);
        }
    }
}
```

以下方法从有资格获得选择性服务的名册中包含的每个成员检索电子邮件地址，然后将其打印出来：

```java
processPersonsWithFunction(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);
```

**方法8：更广泛地使用泛型**

重新考虑方法 `processPersonsWithFunction` 。以下是它的通用版本，它接受包含任何数据类型元素的集合作为参数：

```java
public static <X, Y> void processElements(
    Iterable<X> source,
    Predicate<X> tester,
    Function <X, Y> mapper,
    Consumer<Y> block) {
    for (X p : source) {
        if (tester.test(p)) {
            Y data = mapper.apply(p);
            block.accept(data);
        }
    }
}
```

要打印有资格获得选择性服务的成员的电子邮件地址，请按如下方式调用 `processElements` 方法：

```java
processElements(
    roster,
    p -> p.getGender() == Person.Sex.MALE
        && p.getAge() >= 18
        && p.getAge() <= 25,
    p -> p.getEmailAddress(),
    email -> System.out.println(email)
);
```

此方法调用执行以下操作：

1. 从集合 `source` 中获取对象源。在此示例中，它从集合 `roster` 中获取 `Person` 对象的源。请注意，集合 `roster` 是 `List` 类型的集合，也是 `Iterable` 类型的对象。
2. 过滤与 `Predicate` 类型 `tester` 匹配的对象。在此示例中，`Predicate` 对象是一个 lambda 表达式，指定哪些成员有资格获得选择性服务。
3. 将每个筛选对象映射到 `Function` 类型对象 `mapper` 指定的值。在此示例中，`Function` 对象是一个 lambda 表达式，它返回成员的电子邮件地址。
4. 对 `Consumer` 对象 `block` 指定的每个映射对象执行操作。在此示例中，`Consumer` 对象是一个 lambda 表达式，用于输出字符串，该字符串是 `Function` 对象返回的电子邮件地址。

您可以使用聚合操作替换每个操作。

**方法9：使用接受Lambda表达式作为参数的聚合操作**

以下示例使用聚合操作来打印有资格获得选择性服务的集合 `roster` 中包含的成员的电子邮件地址：

```java
roster
    .stream()
    .filter(
        p -> p.getGender() == Person.Sex.MALE
            && p.getAge() >= 18
            && p.getAge() <= 25)
    .map(p -> p.getEmailAddress())
    .forEach(email -> System.out.println(email));
```

下表将方法 `processElements` 执行的每个操作映射到相应的聚合操作：

| `processElements` Action    | Aggregate Operation                      |
| --------------------------- | ---------------------------------------- |
| 获取对象的源                      | `Stream<E> stream ()`                    |
| 过滤匹配到 `Predicate` 的对象       | `Stream<T> filter(Predicate<? super T> predicate)` |
| 将对象映射到 `Function` 对象指定的另一个值 | `<R> Stream<R> map(Function<? super T,? extends R> mapper)` |
| 执行一个由 `Consumer` 指定的操作      | `void forEach(Consumer<? super T> action)` |

操作 `filter`，`map` 和 `forEach` 是*聚合操作*。聚合操作处理流中的元素，而不是直接来自集合（这是在此示例中调用的第一个方法是 `stream` 的原因）。流是一系列元素。与集合不同，它不是存储元素的数据结构。相反，流通过管道携带来自源（例如集合）的值。*管道*是一系列流操作，在此示例中为 `filter-map-forEach` 。此外，聚合操作通常接受 lambda 表达式作为参数，使您可以自定义它们的行为方式。

关于聚合操作的完整讨论，参考 [Aggregate Operations](https://docs.oracle.com/javase/tutorial/collections/streams/index.html) 章节。

**GUI应用程序中的Lambda表达式**

要处理图形用户界面（GUI）应用程序中的事件（例如键盘操作，鼠标操作和滚动操作），通常会创建事件处理程序，这通常涉及实现特定接口。通常，事件处理程序接口是功能接口，他们往往只有一种方法。

在 JavaFX 示例 [`HelloWorld.java`](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm) (在前面章节 [Anonymous Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html) 中讨论过)，你可以将匿名内部类替换为 lambda 表达式语句：

```java
        btn.setOnAction(new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                System.out.println("Hello World!");
            }
        });
```

方法调用 `btn.setOnAction` 指定当您选择 `btn` 对象表示的按钮时会发生什么。此方法需要 `EventHandler <ActionEvent>` 类型的对象。`EventHandler <ActionEvent>` 接口只包含一个方法，`void handle(T event)`。此接口是一个函数式接口，因此您可以使用以下突出显示的 lambda 表达式来替换它：

```java
        btn.setOnAction(
          event -> System.out.println("Hello World!")
        );
```

**Lambda表达式的语法**

一个 lambda 表达式由以下部分组成：

- 括号中用逗号分隔的形式参数列表。 `CheckPerson.test` 方法包含一个参数 `p` ，它表示 `thePerson` 类的一个实例。

  **注意**: 您可以省略 lambda 表达式中参数的数据类型。此外，如果只有一个参数，则可以省略括号。例如，以下 lambda 表达式也是有效的：

  ```java
  p -> p.getGender() == Person.Sex.MALE 
      && p.getAge() >= 18
      && p.getAge() <= 25
  ```

- 箭头符号 `->`

- 一个主体，由单个表达式或语句块组成。此示例使用以下表达式：

  ```java
  p.getGender() == Person.Sex.MALE 
      && p.getAge() >= 18
      && p.getAge() <= 25
  ```

  如果指定单个表达式，则Java运行时将计算表达式，然后返回其值。或者，您可以使用 `return` 语句：

  ```java
  p -> {
      return p.getGender() == Person.Sex.MALE
          && p.getAge() >= 18
          && p.getAge() <= 25;
  }
  ```

  `return` 语句不是表达式；在 lambda 表达式中，必须将语句括在大括号（{}）中。但是，您不必在大括号中包含 `void` 方法调用。例如，以下是有效的 lambda 表达式：

  ```java
  email -> System.out.println(email)
  ```

请注意，lambda 表达式看起来很像方法声明；您可以将 lambda 表达式视为匿名方法 - 没有名称的方法。

下面的例子 [`Calculator`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Calculator.java) ，是一个 lambda 表达式的示例，它采用多个形式参数：

```java
public class Calculator {
  
    interface IntegerMath {
        int operation(int a, int b);   
    }
  
    public int operateBinary(int a, int b, IntegerMath op) {
        return op.operation(a, b);
    }
 
    public static void main(String... args) {
    
        Calculator myApp = new Calculator();
        IntegerMath addition = (a, b) -> a + b;
        IntegerMath subtraction = (a, b) -> a - b;
        System.out.println("40 + 2 = " +
            myApp.operateBinary(40, 2, addition));
        System.out.println("20 - 10 = " +
            myApp.operateBinary(20, 10, subtraction));    
    }
}
```

方法 `operateBinary` 对两个整数操作数执行数学运算。操作本身由 `IntegerMath` 实例指定。该示例使用 lambda 表达式，加法和减法定义了两个操作。该示例打印以下内容：

```java
40 + 2 = 42
20 - 10 = 10
```

**访问外围作用域的局部变量**

像局部类和匿名类一样，lambda 表达式可以捕获变量；它们对封闭范围的局部变量具有相同的访问权限。但是，与局部类和匿名类不同，lambda 表达式没有任何遮蔽问题（有关更多信息，请参阅 [Shadowing](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing)  ）。Lambda 表达式是词法范围的。这意味着它们不会从超类继承任何名称或引入新级别的作用域。lambda 表达式中的声明与封闭环境中的声明一样被解释。以下示例 [`LambdaScopeTest`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LambdaScopeTest.java) 演示了这一点：

```java
import java.util.function.Consumer;

public class LambdaScopeTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            
            // The following statement causes the compiler to generate
            // the error "local variables referenced from a lambda expression
            // must be final or effectively final" in statement A:
            //
            // x = 99;
            
            Consumer<Integer> myConsumer = (y) -> 
            {
                System.out.println("x = " + x); // Statement A
                System.out.println("y = " + y);
                System.out.println("this.x = " + this.x);
                System.out.println("LambdaScopeTest.this.x = " +
                    LambdaScopeTest.this.x);
            };

            myConsumer.accept(x);

        }
    }

    public static void main(String... args) {
        LambdaScopeTest st = new LambdaScopeTest();
        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}
```

程序输出：

```shell
x = 23
y = 23
this.x = 1
LambdaScopeTest.this.x = 0
```

如果在 lambda 表达式 `myConsumer` 的声明中用参数 `x` 代替 `y`，则编译器会生成错误：

```java
Consumer<Integer> myConsumer = (x) -> {
    // ...
}
```

编译器生成错误 “variable x is already defined in method methodInFirstLevel(int)” ，因为 lambda 表达式不会引入新的作用域级别。因此，您可以直接访问封闭范围的字段，方法和局部变量。例如，lambda 表达式直接访问 `methodInFirstLevel` 方法的参数 `x` 。要访问封闭类中的变量，请使用关键字 `this` 。在此示例中，`this.x` 引用成员变量 `FirstLevel.x` 。

但是，与局部类和匿名类一样，lambda 表达式只能访问最终或最终等效的封闭块的局部变量和参数。例如，假设您在`methodInFirstLevel` 定义语句之后立即添加以下赋值语句：

```java
void methodInFirstLevel(int x) {
    x = 99;
    // ...
}
```

由于这个赋值语句，变量 `FirstLevel.x` 不再是等效 `final` 的。因此，Java编译器生成类似于 “local variables referenced from a lambda expression must be final or effectively final” 的错误消息，其中 lambda 表达式 `myConsumer` 尝试访问 `FirstLevel.x` 变量：

```java
System.out.println("x = " + x);
```

**目标类型**

你如何确定一个 lambda 表达式的类型？回想选择年龄在 18 到 25 岁之间的男性会员的 lambda 表达式：

```java
p -> p.getGender() == Person.Sex.MALE
    && p.getAge() >= 18
    && p.getAge() <= 25
```

该 lambda 表达式使用在下面两个方法中：

- `public static void printPersons(List<Person> roster, CheckPerson tester)` in [方法3：在局部类中指定搜索条件代码](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3)
- `public void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester)` in [方法6：将标准函数式接口与Lambda表达式一起使用](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach6)

当Java运行时调用方法`printPersons`时，它期望数据类型为`CheckPerson`，因此lambda表达式属于这种类型。但是，当Java运行时调用方法`printPersonsWithPredicate`时，它期望数据类型为`Predicate <Person>`，因此lambda表达式属于这种类型。这些方法所期望的数据类型称为*目标类型*。要确定lambda表达式的类型，Java编译器将使用发现lambda表达式的上下文或情境的目标类型。因此，您只能在Java编译器可以确定目标类型的情况下使用lambda表达式：

- 变量声明
- 赋值
- 返回语句
- 数组初始化器
- 方法或者构造器函数
- Lambda 表达式主体
- 条件表达式， `?:`
- 转换表达式

**目标类型和方法参数**

对于方法参数，Java编译器使用另外两种语言特性确定目标类型：重载解析和类型参数推断。

考虑下面的两个函数式接口 ( [`java.lang.Runnable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html) 和 [`java.util.concurrent.Callable`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html))：

```java
public interface Runnable {
    void run();
}

public interface Callable<V> {
    V call();
}
```

方法 `Runnable.run` 不返回值，但是 `Callable<V>.call` 返回值。

假定你已经重载了方法 `invoke` 如下 (参考 [Defining Methods](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html) 获取更多方法重载的信息)：

```java
void invoke(Runnable r) {
    r.run();
}

<T> T invoke(Callable<T> c) {
    return c.call();
}
```

下面的语句调用的是哪个方法？

```java
String s = invoke(() -> "done");
```

将调用方法`invoke(Callable <T>)`，因为该方法返回一个值；方法`invoke(Runnable)`没有。在这种情况下，lambda表达式`() - >“done”`的类型是`Callable <T>`。

**序列化**

You can [serialize](https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html) a lambda expression if its target type and its captured arguments are serializable. However, like [inner classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#serialization), the serialization of lambda expressions is strongly discouraged.

你可以 [序列化](https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html) 一个 lambda 表达式，如果它的目标类型和它捕获的参数是可以序列化的。不过，类似于 [inner classes](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#serialization) ，我们并不推荐对 lambda 表达式进行序列化。

##### 方法引用

你使用 [lambda expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 来创建匿名方法。不过，有时候 lambda 表达式仅仅只是调用一个现成的方法。这些场景下，通常可以很清楚地用方法名称表示现有的方法。方法引用使得你可以这么做。它们是紧凑的、容易阅读的关于拥有名称的方法的 lambda 表达式。

再次考虑在 [Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 章节中讨论过的 [`Person`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Person.java) 类：

```java
public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }
    
    public Calendar getBirthday() {
        return birthday;
    }    

    public static int compareByAge(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }}
```

Suppose that the members of your social networking application are contained in an array, and you want to sort the array by age. You could use the following code (find the code excerpts described in this section in the example [`MethodReferencesTest`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/MethodReferencesTest.java)):

假设您的社交网络应用程序的成员包含在一个数组中，并且您希望按年龄对数组进行排序。您可以使用以下代码（查找示例 [`MethodReferencesTest`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/MethodReferencesTest.java) 中本节中描述的代码摘录）：

```java
Person[] rosterAsArray = roster.toArray(new Person[roster.size()]);

class PersonAgeComparator implements Comparator<Person> {
    public int compare(Person a, Person b) {
        return a.getBirthday().compareTo(b.getBirthday());
    }
}
        
Arrays.sort(rosterAsArray, new PersonAgeComparator());
```

这个 `sort` 调用的方法签名如下：

```java
static <T> void sort(T[] a, Comparator<? super T> c)
```

Notice that the interface `Comparator` is a functional interface. Therefore, you could use a lambda expression instead of defining and then creating a new instance of a class that implements `Comparator`:

请注意，接口`Comparator`是一个函数式接口。因此，您可以使用 lambda 表达式而不是定义然后创建实现`Comparator`的类的新实例：

```java
Arrays.sort(rosterAsArray,
    (Person a, Person b) -> {
        return a.getBirthday().compareTo(b.getBirthday());
    }
);
```

但是，这种比较两个`Person`实例的出生日期的方法已经存在为`Person.compareByAge`。您可以在lambda表达式的主体中调用此方法：

```java
Arrays.sort(rosterAsArray,
    (a, b) -> Person.compareByAge(a, b)
);
```

因为此lambda表达式调用现有方法，所以可以使用方法引用而不是lambda表达式：

```java
Arrays.sort(rosterAsArray, Person::compareByAge);
```

方法引用`Person :: compareByAge`在语义上与lambda表达式`（a，b） - > Person.compareByAge（a，b）`相同。每个都有以下特点：

 - 它的形式参数列表是从`Comparator <Person> .compare`复制的，它是`（Person，Person）`。
 - 它的主体调用方法`Person.compareByAge`。

**方法引用种类**

方法引用有四种：

| Kind                                     | Example                                |
| ---------------------------------------- | -------------------------------------- |
| Reference to a static method             | `ContainingClass::staticMethodName`    |
| Reference to an instance method of a particular object | `containingObject::instanceMethodName` |
| Reference to an instance method of an arbitrary object of a particular type | `ContainingType::methodName`           |
| Reference to a constructor               | `ClassName::new`                       |

**静态方法引用**

 `Person::compareByAge` 就是一个静态方法引用。

**特定对象实例方法的引用**

例子：

```java
class ComparisonProvider {
    public int compareByName(Person a, Person b) {
        return a.getName().compareTo(b.getName());
    }
        
    public int compareByAge(Person a, Person b) {
        return a.getBirthday().compareTo(b.getBirthday());
    }
}
ComparisonProvider myComparisonProvider = new ComparisonProvider();
Arrays.sort(rosterAsArray, myComparisonProvider::compareByName);
```

方法引用`myComparisonProvider :: compareByName`调用方法`compareByName`，它是对象`myComparisonProvider`的一部分。JRE推断出方法类型参数，在本例中是`（Person，Person）`。

**特定类型任意对象的实例方法引用**

例子：

```java
String[] stringArray = { "Barbara", "James", "Mary", "John",
    "Patricia", "Robert", "Michael", "Linda" };
Arrays.sort(stringArray, String::compareToIgnoreCase);
```

方法引用`String :: compareToIgnoreCase`的等效lambda表达式将具有形式参数列表`（String a，String b）`，其中`a`和`b`是用于更好地描述此示例的任意名称。方法引用将调用方法`a.compareToIgnoreCase（b）`。

**构造器引用**

您可以使用名称`new`以与静态方法相同的方式引用构造函数。 以下方法将元素从一个集合复制到另一个集合：

```java
public static <T, SOURCE extends Collection<T>, DEST extends Collection<T>>
    DEST transferElements(
        SOURCE sourceCollection,
        Supplier<DEST> collectionFactory) {
        
        DEST result = collectionFactory.get();
        for (T t : sourceCollection) {
            result.add(t);
        }
        return result;
}
```

函数式接口`Supplier`包含一个不带参数的`get`方法并返回一个对象。因此，您可以使用lambda表达式调用方法`transferElements`，如下所示：

```java
Set<Person> rosterSetLambda =
    transferElements(roster, () -> { return ；new HashSet<>(); });
```

你可以如下使用构造器引用替换其中的 lambda 表达式：

```java
Set<Person> rosterSet = transferElements(roster, HashSet::new);
```

Java编译器推断您要创建一个包含`Person`类型元素的`HashSet`集合。或者，您可以按如下方式指定：

```java
Set<Person> rosterSet = transferElements(roster, HashSet<Person>::new);
```

##### 何时使用嵌套类、局部类、匿名类或者 lambda 表达式

如 [嵌套类](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html) 一节所述，嵌套类使您能够对仅在一个地方使用的类进行逻辑分组，增加封装的使用，并创建更易读和可维护的代码。局部类，匿名类和 lambda 表达式也具有这些优点;但是，它们旨在用于更具体的情况：

*  [局部类](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html) ：如果您需要创建多个类的实例，访问其构造函数或引入新的命名类型（例如，您需要稍后调用其他方法），请使用它。
*  [匿名类](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)：如果需要声明字段或其他方法，请使用它。
*  [Lambda 表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) ：
  *  如果要封装要传递给其他代码的单个行为单元，请使用它。例如，如果希望对集合的每个元素执行某个操作，完成进程或进程遇到错误，则可以使用lambda表达式。
  *  如果您需要一个简单的功能接口实例并且不应用任何前述条件（例如，您不需要构造函数，命名类型，字段或其他方法），请使用它。
*  [嵌套类](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)：如果您的要求与本地类的要求类似，则使用它，您希望使类型更广泛可用，并且您不需要访问局部变量或方法参数。
  * 如果需要访问封闭实例的非公共字段和方法，请使用非静态嵌套类（或内部类）。如果不需要此访问权限，请使用静态嵌套类。

#### 枚举类型

*枚举类型*是一种特殊的数据类型，它使变量成为一组预定义的常量。变量必须等于为其预定义的值之一。常见示例包括罗盘方向（NORTH，SOUTH，EAST和WEST的值）和星期几。

因为它们都是常量，因此枚举类型字段名都是大写字母组成。

在 Java 语言中，你可以使用 `enum` 关键字来定义枚举类型。比如，你可以指定一个星期几枚举类型如下：

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY 
}
```

您需要在需要表示一组固定常量时使用枚举类型。这包括自然枚举类型，例如太阳系中的行星和数据集，您可以在编译时知道所有可能的值 - 例如，菜单上的选项，命令行标志等。

下面的代码向你展示如何使用上面定义的 `Day` 枚举类型：

```java
public class EnumTest {
    Day day;
    
    public EnumTest(Day day) {
        this.day = day;
    }
    
    public void tellItLikeItIs() {
        switch (day) {
            case MONDAY:
                System.out.println("Mondays are bad.");
                break;
                    
            case FRIDAY:
                System.out.println("Fridays are better.");
                break;
                         
            case SATURDAY: case SUNDAY:
                System.out.println("Weekends are best.");
                break;
                        
            default:
                System.out.println("Midweek days are so-so.");
                break;
        }
    }
    
    public static void main(String[] args) {
        EnumTest firstDay = new EnumTest(Day.MONDAY);
        firstDay.tellItLikeItIs();
        EnumTest thirdDay = new EnumTest(Day.WEDNESDAY);
        thirdDay.tellItLikeItIs();
        EnumTest fifthDay = new EnumTest(Day.FRIDAY);
        fifthDay.tellItLikeItIs();
        EnumTest sixthDay = new EnumTest(Day.SATURDAY);
        sixthDay.tellItLikeItIs();
        EnumTest seventhDay = new EnumTest(Day.SUNDAY);
        seventhDay.tellItLikeItIs();
    }
}
```

输出：

```shell
Mondays are bad.
Midweek days are so-so.
Fridays are better.
Weekends are best.
Weekends are best.
```

Java编程语言枚举类型比其他语言中的对应类型更强大。枚举声明定义了一个类（称为枚举类型）。枚举类主体可以包括方法和其他字段。编译器在创建枚举时会自动添加一些特殊方法。例如，它们具有静态 `values` 方法，该方法返回一个数组，该数组按照声明的顺序包含枚举的所有值。此方法通常与 for-each 构造结合使用，以迭代枚举类型的值。例如，下面 `Planet` 类示例中的代码迭代太阳系中的所有行星。

```java
for (Planet p : Planet.values()) {
    System.out.printf("Your weight on %s is %f%n",
                      p, p.surfaceWeight(mass));
}
```

------

**注意:** *所有*枚举类型隐含继承 `java.lang.Enum`。由于一个类只能有一个父类（参考 [Declaring Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html)），Java 语言不支持多继承状态 (参考 [多继承状态，实现以及类型](https://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.html))，因此枚举类不能扩展任何其它内容。

------

在以下示例中，`Planet` 是一种枚举类型，表示太阳系中的行星。它们具有恒定的质量和半径属性。

每个枚举常量都声明为质量和半径参数的值。创建常量时，这些值将传递给构造函数。 Java要求在任何字段或方法之前首先定义常量。此外，当存在字段和方法时，枚举常量列表必须以分号结尾。

------

**注意：**枚举类型的构造函数必须是包私有或私有访问。 它会自动创建在枚举主体开头定义的常量。 您不能自己调用枚举构造函数。

------

除了它的属性和构造函数之外，`Planet` 还有一些方法可以让您检索每个行星上物体的表面重力和重量。这是一个示例程序，它可以减轻地球上的重量（以任何单位）并计算并打印所有行星上的重量（以同一单位）：

```java
public enum Planet {
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }

    // universal gravitational constant  (m3 kg-1 s-2)
    public static final double G = 6.67300E-11;

    double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    double surfaceWeight(double otherMass) {
        return otherMass * surfaceGravity();
    }
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java Planet <earth_weight>");
            System.exit(-1);
        }
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight/EARTH.surfaceGravity();
        for (Planet p : Planet.values())
           System.out.printf("Your weight on %s is %f%n",
                             p, p.surfaceWeight(mass));
    }
}
```

如果从命令行运行 `Planet.class`，参数为175，则会得到以下输出：

```shell
$ java Planet 175
Your weight on MERCURY is 66.107583
Your weight on VENUS is 158.374842
Your weight on EARTH is 175.000000
Your weight on MARS is 66.279007
Your weight on JUPITER is 442.847567
Your weight on SATURN is 186.552719
Your weight on URANUS is 158.397260
Your weight on NEPTUNE is 199.207413
```

## 注解

*注解* ，一种元数据形式，提供有关不属于程序本身的程序的数据。注解对它们修饰的代码的操作没有直接影响。

注解有许多用途，其中包括：

* **给编译器的信息**- 编译器可以使用注解来检测错误或抑制警告。
* **编译期和部署时处理** - 软件工具可以处理注解信息以生成代码，XML文件等。
* **运行时处理** - 可以在运行时检查某些注解。

本课程介绍了可以使用注解的位置，如何应用注解，Java平台，标准版（Java SE API）中可用的预定义注解类型，类型注解如何与可插拔类型系统结合使用以编写更强大的代码类型检查，以及如何实现可重复注解。

### 注解基础

**注解的格式**

注解的最简单形式如下：

```java
@Entity
```

符号 (`@`) 告诉编译器它后面跟随的是一个注解。在下面的例子中，注解的名称是 `Override` ：

```java
@Override
void mySuperMethod() { ... }
```

注解可以包含*元素*，元素可以有名称或者没有名称，同时给定这些元素的值：

```java
@Author(
   name = "Benjamin Franklin",
   date = "3/27/2003"
)
class MyClass() { ... }
```

或者：

```java
@SuppressWarnings(value = "unchecked")
void myMethod() { ... }
```

如果注解中只包含一个名为 `value` 的元素，则该名称可以忽略：

```java
@SuppressWarnings("unchecked")
void myMethod() { ... }
```

如果注解不包含元素，则括号也可以忽略，如上面例子中的 `@Override` 注解。

在同一个声明中使用多个注解也是可以的：

```java
@Author(name = "Jane Doe")
@EBook
class MyClass { ... }
```

如果多个注解是相同的类型，则这就被称为可重复注解：

```java
@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }
```

可重复注解由 Java SE 8 版本支持。更多信息参考 [Repeating Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html) 。

注解类型可以是 Java SE API 的 `java.lang` 或 `java.lang.annotation` 包中定义的类型之一。在前面的示例中， `Override` 和 `SuppressWarnings` 是预定义的 Java 注解。也可以定义自己的注解类型。上一个示例中的 `Author` 和 `Ebook` 注解是自定义注解类型。

**哪里可以使用注解**

注解可以应用于声明：类、字段、方法以及其它程序元素的声明。当用于声明上时，方便起见，每个注解都各自一行。

在 Java SE 8 中，注解也可以被用于类型的使用。下面是几个例子：

- 类实例创建表达式：

  ```java
  new @Interned MyObject();
  ```

- 类型转换：

  ```java
  myString = (@NonNull String) str;
  ```

- `implements` 代码块：

  ```java
  class UnmodifiableList<T> implements
          @Readonly List<@Readonly T> { ... }
  ```

- 异常抛出声明：

  ```java
  void monitorTemperature() throws
          @Critical TemperatureException { ... }
  ```

上面这种形式的注解被称为*类型注解*。更多信息参考 [类型注解和可插拔类型系统](https://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html) 。

### 声明一个注解类型

许多注解可以替代代码中的注释。

假设一个软件组传统上启动每个类的主体，其中包含提供重要信息的注释：

```java
public class Generation3List extends Generation2List {

   // Author: John Doe
   // Date: 3/17/2002
   // Current revision: 6
   // Last modified: 4/12/2004
   // By: Jane Doe
   // Reviewers: Alice, Bill, Cindy

   // class code goes here

}
```

要使用注释添加此相同元数据，必须先定义注释类型。这样做的语法是：

```java
@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default "N/A";
   String lastModifiedBy() default "N/A";
   // Note use of array
   String[] reviewers();
}
```

注解类型定义类似于接口定义，其中 `interface` 关键字前面带有at符号（@）（@ = AT，在注解类型中）。注解类型是一种*接口*形式，将在后面的课程中介绍。目前，您不需要了解接口。



前一个注解定义的主体包含注解类型元素声明，它看起来很像方法。请注意，它们可以定义可选的默认值。

定义注解类型后，您可以使用该类型的注解，并填入值，如下所示：

```java
@ClassPreamble (
   author = "John Doe",
   date = "3/17/2002",
   currentRevision = 6,
   lastModified = "4/12/2004",
   lastModifiedBy = "Jane Doe",
   // Note array notation
   reviewers = {"Alice", "Bob", "Cindy"}
)
public class Generation3List extends Generation2List {

// class code goes here

}
```

------

**注意：**要使 `@ClassPreamble` 中的信息出现在 Javadoc 生成的文档中，必须使用 `@Documented` 注解修饰 `@ClassPreamble` 定义：

```java
// import this to use @Documented
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {

   // Annotation element definitions
   
}
```

------

### 预定义注解类型

Java SE API 中已经定义了一系列注解类型。某些注解供 Java 编译器使用，一些用于其他注解。

**Java 语言使用的注解类型**

定义在 `java.lang` 中的预定义注解类型有 `@Deprecated`，`@Override` 和 `@SuppressWarnings` 。

**@Deprecated** [`@Deprecated`](https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html) 注解表示它修饰的元素是*过时的*因而不能再继续使用。当程序无论何时使用一个此注解修饰的方法、类或者字段时编译器都会产生一个警告。当元素是过时的，它应该同时被 Javadoc 标签 `@deprecated` 修饰，如下面例子中所示。在Javadoc注释和注释中使用at符号（@）并非巧合：它们在概念上是相关的。另请注意，Javadoc标记以小写d开头，注释以大写D开头。

```java
   // Javadoc comment follows
    /**
     * @deprecated
     * explanation of why it was deprecated
     */
    @Deprecated
    static void deprecatedMethod() { }
}
```

**@Override** [`@Override`](https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html) 注解提示编译器该元素意图覆盖超类中声明过的元素。方法覆盖将在  [Interfaces and Inheritance](https://docs.oracle.com/javase/tutorial/java/IandI/index.html) 中讨论。

```java
   // mark method as a superclass method
   // that has been overridden
   @Override 
   int overriddenMethod() { }
```

虽然在重写方法时不需要使用此注解，但它有助于防止出错。如果使用 `@Override` 标记的方法无法正确覆盖其某个超类中的方法，则编译器会生成错误。

**@SuppressWarnings** [`@SuppressWarnings`](https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html) 注解告诉编译器抑制它本来会生成的特定警告。在以下示例中，使用了过时的方法，编译器通常会生成警告。但是，在这种情况下，注解会导致警告被抑制。

```java
   // use a deprecated method and tell 
   // compiler not to generate a warning
   @SuppressWarnings("deprecation")
    void useDeprecatedMethod() {
        // deprecation warning
        // - suppressed
        objectOne.deprecatedMethod();
    }
```

每个编译器警告都属于一个类别。 Java语言规范列出了两个类别：`deprecation` 和 `unchecked`。当与 [泛型](https://docs.oracle.com/javase/tutorial/java/generics/index.html) 出现之前编写的遗留代码交互时，可能会发生 `unchecked` 警告。要禁止多种类别的警告，请使用以下语法：

```java
@SuppressWarnings({"unchecked", "deprecation"})
```

**@SafeVarargs** [`@SafeVarargs`](https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html) 在应用于方法或构造函数时，断言代码不对其 `varargs` 参数执行可能不安全的操作。使用此注释类型时，将禁止与 `varargs` 使用相关的未经检查的警告。

**@FunctionalInterface** [`@FunctionalInterface`](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html) 在 Java SE 8 中引入，表示声明的类型是一个函数式接口，函数式接口在 Java 语言规范中定义。

**应用于其他注解的注解**

应用于其他注解的注解被称为 *元注解*。`java.lang.annotation` 中定义了几种元注解。

**@Retention** [`@Retention`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html) 指定它修饰的注解的存储方式：

- `RetentionPolicy.SOURCE` – 被修饰的注解只存在于源代码层面而会被编译器忽略。
- `RetentionPolicy.CLASS` – 被修饰的注解存活到编译期，而会被虚拟机忽略。
- `RetentionPolicy.RUNTIME` – 被修饰的注解会被虚拟机保留，因而可以用在运行时环境中。

**@Documented** [`@Documented`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html) 注解表明，无论何时使用指定的注解，都应使用 Javadoc 工具记录这些元素。（默认情况下，注解不包含在 Javadoc 中。）有关更多信息，请参阅 [Javadoc tools page](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html) 。

**@Target** [`@Target`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html) 修饰另一个注解，限制该注解可以应用到哪些 Java 元素上。该注解指定以下元素类型之一作为它的值：

- `ElementType.ANNOTATION_TYPE` 可被用于注解类型
- `ElementType.CONSTRUCTOR` 可被用于构造器
- `ElementType.FIELD` 可被用于字段或属性
- `ElementType.LOCAL_VARIABLE` 可被用于局部变量
- `ElementType.METHOD` 可被用于方法级注解
- `ElementType.PACKAGE` 可被用于包声明
- `ElementType.PARAMETER` 可被用于方法参数
- `ElementType.TYPE` 可被用于类的任意元素

**@Inherited** [`@Inherited`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html) 表明注解类型可以从超类继承。（默认情况下不是这样。）当用户查询注解类型并且该类没有此类型的注解时，将查询类的超类以获取注解类型。此注解仅适用于类声明。

**@Repeatable** [`@Repeatable`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html) Java SE 8中引入的注解，表明其标记的注解可以多次应用于相同的声明或类型。有关更多信息，请参阅 [Repeating Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html) 。

### 类型注解和可插拔类型系统


在 Java SE 8 发布之前，注解只能被应用到声明上。在 Java SE 8 版本中，注解已经可以被用于任何*类型使用*。这就意味着注解可以用在任何你使用类型的地方。一些展示类型使用位置的例子是类实例创建表达式（`new`）、转型、`implements` 语句、以及 `throws` 语句。这种形式的注解被称为*类型注解*。在 [Annotations Basics](https://docs.oracle.com/javase/tutorial/java/annotations/basics.html) 中给出了几个例子。

类型注解的目的是支持改进的 Java 程序分析，通过保证更强的类型检查。Java SE 8 没有提供类型检查框架，但是允许你自己实现或者下载一个类型检查框架，该框架实现一个或者多个与 Java 编译器结合使用的插件模块。
比如，你想要保证你的程序中的某个特定变量绝对不会被赋值 `null` ，你希望避免触发 `NullPointerException` 。你可以实现一个自定义插件来执行该检查。接下来你可以修改代码，在该特定变量上添加注解，表明它绝对不能被赋值 `null` 。变量声明如下：

```java
@NonNull String str;
```
当你编译该代码时，在命令行中包含该 `NonNull` 模块，编译器打印一个警告，如果它检测到潜在的问题，允许你修改代码来避免错误。在你修改代码消除所有警告之后，该特定错误在程序运行时将不可能发生。
你可以使用多个类型检查模块，每个模块负责检查一种错误。通过这种方式，你可以在 Java 类型系统之上，构建特定的类型检查层，在任何时候用在任何需要的地方。
结合使用类型注解和可插拔的类型检查器，你可以编写更健壮和包含更少潜在问题的代码。
很多情况下，你不需要编写自己的类型检查模块。已经有人为你做好了三部分工作。比如，你可能希望利用华盛顿大学提供的类型检查器框架的优点。该框架包含一个 `NonNull` 模块，以及正则表达式模块、一个互斥锁模块。更多信息，参考 [Checker Framework](http://types.cs.washington.edu/checker-framework/) 。

### 可重复注解
存在几种情况你可能会希望将同样类型的注解应用于一个声明或者类型使用。在 Java SE 8 中，可重复注解允许你这么做。
比如，你正在写的代码使用一个计时器服务允许你在给定时间或者按照某种调度策略执行一个方法，类似于 UNIX 的 `cron` 服务。现在你希望设定一个计时器来运行一个方法，
 `doPeriodicCleanup`,  在每个月的最后一天和每个周五的下午 11：00 。为了设定该定时器运行，创建一个 `@Schedule` 注解并将它两次应用到方法 `doPeriodicCleanup` 上。第一次使用指定每个月的最后一天，第二次使用指定每个周五的下午 11：00 。如下面例子所示：
````java
@Schedule(dayOfMonth="last")
@Schedule(dayOfWeek="Fri", hour="23")
public void doPeriodicCleanup() { ... }
````
上面的例子应用注解到方法上。你可以在任何使用标准注解的地方任意次数地重复使用一个注解。比如，你的一个类用来粗粒未授权访问异常。你可以在该类上使用两次 `@Alert` 注解来支持业务管理员角色和系统管理员角色：
````java
@Alert(role="Manager")
@Alert(role="Administrator")
public class UnauthorizedAccessException extends SecurityException { ... }
````
考虑到兼容性，可重复注解存储在 Java 编译器自动生成的容器注解中。为了保证编译器这么做，你必须在代码中使用两种声明：

**第一步：声明一个可重复注解类型**

该注解类型必须使用 `@Repeatable` 元注解。下面的例子定义了一个 `@Schedule` 可重复注解类型：

````java
import java.lang.annotation.Repeatable;

@Repeatable(Schedules.class)
public @interface Schedule {
  String dayOfMonth() default "first";
  String dayOfWeek() default "Mon";
  int hour() default 12;
}
````
`@Repeatable` 元注解的值（在括号中）是Java编译器为存储重复注解而生成的容器注解的类型。在此示例中，包含注解类型是 `Schedules`，因此重复 `@Schedule` 注解存储在`@Schedules` 注解中。

将相同的注解应用于声明而不首先声明它是可重复的，这会导致编译时错误。

**第二步：声明包含注解类型**

包含注解类型必须具有带数组类型的 `value` 元素。数组的元素类型必须是可重复的注解类型。 包含注解类型 `Schedules` 的声明如下：

````java
public @interface Schedules {
    Schedule[] value();
}
````

**检索注解**

Reflection API 中有几种可用于检索注解的方法。返回单个注解的方法（例如 `AnnotatedElement.getAnnotation(Class <T>)`）的行为未更改，因为如果存在所请求类型的一个注解，它们仅返回单个注解。如果存在多个所请求类型的注解，则可以通过首先获取其容器注解来获取它们。通过这种方式，遗留代码继续工作。Java SE 8中引入了其他方法，它们扫描容器注解以一次返回多个注解，例如 `AnnotatedElement.getAnnotationsByType(Class <T>)`。有关所有可用方法的信息，请参阅 [AnnotatedElement](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html)  类规范。

**设计注意事项**

设计注解类型时，必须考虑该类型注解的基数。现在可以使用注解零次，一次，或者，如果注解的类型被标记为    `@Repeatable` ，则不止一次。也可以通过使用 `@Target` 元注解来限制可以使用注解类型的位置。例如，您可以创建只能在方法和字段上使用的可重复注解类型。仔细设计注解类型非常重要，以确保使用注解的程序员发现它尽可能灵活和强大。

## 接口和继承

[接口](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)

前面的章节中你已经看过了实现一个接口的例子。本节中你将看到更多，接口的目的，发明接口的动机，以及接口的写法。

[继承](https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html)

本节描述从另外一个类产生一个类的方法。也就是说，*子类*如何从*超类*继承字段和方法。你将看到所有的类都是从 `Object` 类派生而来，以及如何在子类中修改从超类继承来的方法。本节也包含类似接口的*抽象类*。

### 接口

软件工程中有许多情况，当不同的程序员团队同意一份“契约”来阐明他们的软件如何相互作用时，这是很重要的。每个组都应该能够编写代码，而不必知道如何编写其他组的代码。一般来说，*接口*就是这样的契约。

例如，想象一个未来主义社会，计算机控制的机器人汽车在没有人工操作员的情况下将乘客运送到城市街道。汽车制造商编写操作汽车的软件（当然是Java） - 停止，启动，加速，左转等等。另一个工业集团，电子制导仪器制造商，使计算机系统接收GPS（全球定位系统）位置数据和无线传输交通状况并利用该信息来驾驶汽车。

汽车制造商必须发布一个行业标准的接口协议，详细说明可以调用什么方法来使汽车移动（任何汽车，来自任何制造商）。然后，制导仪器制造商可以编写调用接口协议中描述的方法的软件来命令汽车。工业集团都不需要知道如何实现其他团队的软件。事实上，每个小组都认为其软件具有高度专有性，并保留随时修改它的权利，只要它继续遵守已发布的接口协议即可。

**Java 中的接口**

在 Java 语言中，*接口*是引用类型，类似于类，不过只能包含常量，方法签名，默认方法，静态方法以及嵌套类型。只有默认方法和静态方法才能有方法体。接口不能被实例化—它们只能被其他类实现或者被其他接口扩展。稍后会讨论扩展。

定义一个接口类似于创建一个新类：

```java
public interface OperateCar {

   // constant declarations, if any

   // method signatures
   
   // An enum with values RIGHT, LEFT
   int turn(Direction direction,
            double radius,
            double startSpeed,
            double endSpeed);
   int changeLanes(Direction direction,
                   double startSpeed,
                   double endSpeed);
   int signalTurn(Direction direction,
                  boolean signalOn);
   int getRadarFront(double distanceToCar,
                     double speedOfCar);
   int getRadarRear(double distanceToCar,
                    double speedOfCar);
         ......
   // more method signatures
}
```

注意方法签名没有大括号，而是以分号终结。

为了使用接口，你需要编写一个类来实现该接口。当一个可实例化的类实现一个接口，它就需要为接口中声明的每个方法都提供方法体。比如：

```java
public class OperateBMW760i implements OperateCar {

    // the OperateCar method signatures, with implementation --
    // for example:
    int signalTurn(Direction direction, boolean signalOn) {
       // code to turn BMW's LEFT turn indicator lights on
       // code to turn BMW's LEFT turn indicator lights off
       // code to turn BMW's RIGHT turn indicator lights on
       // code to turn BMW's RIGHT turn indicator lights off
    }

    // other members, as needed -- for example, helper classes not 
    // visible to clients of the interface
}
```

在上面的机器人汽车示例中，汽车制造商将实现接口协议。 当然，雪佛兰的实现将与丰田的实现大不相同，但两家制造商都将遵循相同的接口协议。 作为接口客户的导航仪制造商将构建使用汽车位置上的GPS数据，数字街道地图和交通数据来驱动汽车的系统。 这样，引导系统将调用接口方法：转弯，改变车道，制动，加速等。

**接口作为API**

机器人汽车示例显示了用作行业标准应用程序编程接口（API）的接口。 API在商业软件产品中也很常见。 通常，公司销售的软件包包含另一家公司希望在其自己的软件产品中使用的复杂方法。 一个例子是销售给制作最终用户图形程序的公司的数字图像处理方法包。 图像处理公司编写其类以实现接口，并将其公开给客户。 然后，图形公司使用接口协议中定义的签名和返回类型调用图像处理方法。 虽然图像处理公司的API是公开的（对其客户），但它的API实现仍然是一个严密保密的秘密 - 事实上，只要它继续实现它的客户所依赖的原始接口，它就可以在以后随时修改其实现 。

#### 定义接口

接口声明包含访问修饰符，关键字 `interface`，接口名称，逗号分隔的父接口列表（如果存在），还有接口体。比如：

```java
public interface GroupedInterface extends Interface1, Interface2, Interface3 {

    // constant declarations
    
    // base of natural logarithms
    double E = 2.718282;
 
    // method signatures
    void doSomething (int i, double x);
    int doSomethingElse(String s);
}
```

`public ` 访问限定符表示该接口可以被任何包中的任何类使用。如果你没有指定接口访问限定符，则该接口只能被同一个包中定义的类使用。

接口可以扩展其他接口，就像类子类或扩展另一个类一样。但是，虽然类只能扩展另一个类，但接口可以扩展任意数量的接口。 接口声明包括它扩展的所有接口的逗号分隔列表。

**接口体**

接口体可以包含 [抽象方法](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)，[默认方法](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html)，以及 [静态方法](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static)。接口中的抽象方法后跟分号，但没有大括号（抽象方法不包含实现）。 默认方法使用`default`修饰符定义，静态方法使用`static`关键字定义。 接口中的所有抽象，默认和静态方法都是隐式的 `public`，因此您可以省略`public`修饰符。

此外，接口可以包含常量声明。接口中定义的所有常量值都隐式为 `public`，`static` 和 `final`。 再一次，您可以省略这些修饰符。

#### 实现接口

为了声明一个实现某个接口的类，你需要在类声明中包含 `implement` 语句片段。你的类可以实现超过一个接口，因而 `implements` 关键字后面跟随的是一个逗号分隔的该类实现的接口列表。方便起见，`implements` 语句片段跟在 `extends` 语句片段之后，如果两者同时存在。

**一个接口示例**

考虑一个定义来比较对象大小的接口：

````java
public interface Relatable {
        
    // this (object calling isLargerThan)
    // and other must be instances of 
    // the same class returns 1, 0, -1 
    // if this is greater than, 
    // equal to, or less than other
    public int isLargerThan(Relatable other);
}
````

如果你希望可以比较两个同类对象，无论它们实际上是什么，实例化它们的类应该实现接口 `Relatable`。

任何类都能够实现 `Relatable` 接口，如果存在某种方法可以比较从该类实例化而来的对象的尺寸。多字符串来说，其尺寸可以是其中的字符数目。对书本来说，尺寸可以是页数。对学生来说，尺寸可以是体重。等等。对平面几何图形对象来说，面积是一个好的选。而体积对应于三维几何对象。所有这些类都能实现 `isLargerThan()` 方法。

如果你知道一个类实现了 `Relatable`  接口，则你知道可以比较从该类实例化而来的对象的尺寸。

**实现 `Relatable` 接口**

下面是曾出现在 [Creating Objects](https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html) 章节中的 `Rectangle` 类，重写并实现 `Relatable` 接口：

```java
public class RectanglePlus 
    implements Relatable {
    public int width = 0;
    public int height = 0;
    public Point origin;

    // four constructors
    public RectanglePlus() {
        origin = new Point(0, 0);
    }
    public RectanglePlus(Point p) {
        origin = p;
    }
    public RectanglePlus(int w, int h) {
        origin = new Point(0, 0);
        width = w;
        height = h;
    }
    public RectanglePlus(Point p, int w, int h) {
        origin = p;
        width = w;
        height = h;
    }

    // a method for moving the rectangle
    public void move(int x, int y) {
        origin.x = x;
        origin.y = y;
    }

    // a method for computing
    // the area of the rectangle
    public int getArea() {
        return width * height;
    }
    
    // a method required to implement
    // the Relatable interface
    public int isLargerThan(Relatable other) {
        RectanglePlus otherRect 
            = (RectanglePlus)other;
        if (this.getArea() < otherRect.getArea())
            return -1;
        else if (this.getArea() > otherRect.getArea())
            return 1;
        else
            return 0;               
    }
}
```

因为 `RectanglePlus` 实现了 `Relatable`，任何两个 `RectanglePlus`  对象的尺寸可以被比较。

------

**注意：** `isLargerThan` 方法（在 `Relatable` 接口中定义）采用 `Relatable` 类型的对象。代码行（在前面的示例中以粗体显示）将 `other` 转换为 `RectanglePlus` 实例。类型转换告诉编译器对象到底是什么。直接在 `other` 实例上调用 `getArea` 将无法编译，因为编译器不理解 `other` 实际上是 `RectanglePlus` 的实例。

------

#### 使用接口作为类型

当你定义一个新接口，你实际上是定义了一个新的引用数据类型。你可以在任何能够使用其它数据类型名称的地方使用接口名称。如果你定义了一个引用变量，其类型是一个接口，则任何你赋予它的对象都必须是实现了该接口的类的实例。

作为一个例子，

作为一个例子，这里有一个方法，用于查找一对对象中的最大对象，对于从实现 `Relatable` 接口 的类实例化的任何对象：

```java
public Object findLargest(Object object1, Object object2) {
   Relatable obj1 = (Relatable)object1;
   Relatable obj2 = (Relatable)object2;
   if ((obj1).isLargerThan(obj2) > 0)
      return object1;
   else 
      return object2;
}
```

通过将 `object1` t转型为 `Relatable` 类型，它就可以调用 `isLargerThan` 方法。

如果您在各种类中实现 `Relatable`，则可以将从这些类中实例化的对象通过 `findLargest()` 方法进行比较 - 前提是两个对象属于同一个类。同样，它们都可以通过以下方法进行比较：

```java
public Object findSmallest(Object object1, Object object2) {
   Relatable obj1 = (Relatable)object1;
   Relatable obj2 = (Relatable)object2;
   if ((obj1).isLargerThan(obj2) < 0)
      return object1;
   else 
      return object2;
}

public boolean isEqual(Object object1, Object object2) {
   Relatable obj1 = (Relatable)object1;
   Relatable obj2 = (Relatable)object2;
   if ( (obj1).isLargerThan(obj2) == 0)
      return true;
   else 
      return false;
}
```

这些方法适用于任何 `relatable` 对象，无论它们的类继承是什么。当它们实现 `Relatable` 时，它们可以是它们自己的类（或超类）类型和 `Relatable` 类型。这为他们提供了多重继承的一些优点，他们可以获得来自超类和接口的行为。

#### 进化中的接口

考虑一个你已经开发出来的接口 `DoIt`：

````java
public interface DoIt {
   void doSomething(int i, double x);
   int doSomethingElse(String s);
}
````

假设，稍后，你希望在接口中添加第三个方法，则该接口变为：

````java
public interface DoIt {

   void doSomething(int i, double x);
   int doSomethingElse(String s);
   boolean didItWork(int i, double x, String s);
   
}
````

如果你进行这样的修改，则所有实现了老 `DoIt` 接口的类都将报废，因为接口已经变化了。依赖此接口的所有程序将在喧闹中崩溃。

尝试预测您的接口的所有用途，并从一开始就完全指定它。如果要向接口添加其他方法，可以使用多中方法。你可以创建一个扩展 `DoIt` 的 `DoItPlus` 接口：

````java
public interface DoItPlus extends DoIt {

   boolean didItWork(int i, double x, String s);
   
}
````

现在你的代码的用户可以选择继续使用旧接口还是升级到新接口。

另外，你可以将新方法定义为 [默认方法](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html). 下面定义名为 `didItWork` 的默认方法：

````java
public interface DoIt {

   void doSomething(int i, double x);
   int doSomethingElse(String s);
   default boolean didItWork(int i, double x, String s) {
       // Method body 
   }
   
}
````

注意，你必须为默认方法提供一个实现，你也可以定义新的 [静态方法](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static) 到已经存在的接口中。实现你的接口的类的用户不需要修改或者重新编译那些类就可以直接享受到这些默认方法和静态方法的强化能力。

#### 默认方法和静态方法

章节 [Interfaces](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html) 描述了一个涉及计算机控制汽车制造商的例子，他们发布了行业标准接口，描述了可以调用哪些方法来操作他们的汽车。如果那些计算机控制的汽车制造商为他们的汽车添加新的功能，例如飞行，该怎么办？这些制造商需要指定新方法，以使其他公司（如电子制导仪器制造商）能够使其软件适应飞行汽车。这些汽车制造商将在哪些地方宣布这些与航班相关的新方法？如果他们将它们添加到原始接口，那么实现这些接口的程序员将不得不重写他们的实现。如果他们将它们作为静态方法添加，那么程序员会将它们视为实用方法，而不是必要的核心方法。

默认方法允许你向你的类库中的接口中添加新功能方法的同时保证与实现这些接口的老版本的代码的二进制兼容性。

考虑下面的接口：

````java
import java.time.*; 
 
public interface TimeClient {
    void setTime(int hour, int minute, int second);
    void setDate(int day, int month, int year);
    void setDateAndTime(int day, int month, int year,
                               int hour, int minute, int second);
    LocalDateTime getLocalDateTime();
}
````

下面的类实现了该接口：

````java
package defaultmethods;

import java.time.*;
import java.lang.*;
import java.util.*;

public class SimpleTimeClient implements TimeClient {
    
    private LocalDateTime dateAndTime;
    
    public SimpleTimeClient() {
        dateAndTime = LocalDateTime.now();
    }
    
    public void setTime(int hour, int minute, int second) {
        LocalDate currentDate = LocalDate.from(dateAndTime);
        LocalTime timeToSet = LocalTime.of(hour, minute, second);
        dateAndTime = LocalDateTime.of(currentDate, timeToSet);
    }
    
    public void setDate(int day, int month, int year) {
        LocalDate dateToSet = LocalDate.of(day, month, year);
        LocalTime currentTime = LocalTime.from(dateAndTime);
        dateAndTime = LocalDateTime.of(dateToSet, currentTime);
    }
    
    public void setDateAndTime(int day, int month, int year,
                               int hour, int minute, int second) {
        LocalDate dateToSet = LocalDate.of(day, month, year);
        LocalTime timeToSet = LocalTime.of(hour, minute, second); 
        dateAndTime = LocalDateTime.of(dateToSet, timeToSet);
    }
    
    public LocalDateTime getLocalDateTime() {
        return dateAndTime;
    }
    
    public String toString() {
        return dateAndTime.toString();
    }
    
    public static void main(String... args) {
        TimeClient myTimeClient = new SimpleTimeClient();
        System.out.println(myTimeClient.toString());
    }
}
````

假定你想要向 `TimeClient` 接口添加新功能方法，比如通过一个 [`ZonedDateTime`](https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html) 对象指定时区的能力， (类似于一个[`LocalDateTime`](https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html) 对象，除了它存储时区信息)：

```java
public interface TimeClient {
    void setTime(int hour, int minute, int second);
    void setDate(int day, int month, int year);
    void setDateAndTime(int day, int month, int year,
        int hour, int minute, int second);
    LocalDateTime getLocalDateTime();                           
    ZonedDateTime getZonedDateTime(String zoneString);
}
```

随着 `TimeClient` 接口的修改，你将不得不修改 `SimpleTimeClient` 以及实现方法 `getZonedDateTime` 。不过，相比于让 `getZonedDateTime` 保持 `abstract` (如前面例子所示)，你可以定义一个*默认实现*。 (回想一下， [抽象方法](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html) 是一种没有实现的方法声明。)

````java
package defaultmethods;
 
import java.time.*;

public interface TimeClient {
    void setTime(int hour, int minute, int second);
    void setDate(int day, int month, int year);
    void setDateAndTime(int day, int month, int year,
                               int hour, int minute, int second);
    LocalDateTime getLocalDateTime();
    
    static ZoneId getZoneId (String zoneString) {
        try {
            return ZoneId.of(zoneString);
        } catch (DateTimeException e) {
            System.err.println("Invalid time zone: " + zoneString +
                "; using default time zone instead.");
            return ZoneId.systemDefault();
        }
    }
        
    default ZonedDateTime getZonedDateTime(String zoneString) {
        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));
    }
}
````

在方法签名的开头使用 `default` 关键字来指定接口中的某个方法定义是默认方法。接口中声明的所有方法，包括默认方法，都隐含是 `public` 的，因此你可以忽略 `public` 访问修饰符。

使用此接口，你不需要修改 `SimpleTimeClient` ，但是该类 (以及所有实现了 `TimeClient` 接口的类)，都将拥有已经定义的 `getZonedDateTime` 方法。下面的例子， [`TestSimpleTimeClient`](https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/TestSimpleTimeClient.java) ，调用来自 `SimpleTimeClient` 实例的 `getZonedDateTime` 方法：

````java
package defaultmethods;
 
import java.time.*;
import java.lang.*;
import java.util.*;

public class TestSimpleTimeClient {
    public static void main(String... args) {
        TimeClient myTimeClient = new SimpleTimeClient();
        System.out.println("Current time: " + myTimeClient.toString());
        System.out.println("Time in California: " +
            myTimeClient.getZonedDateTime("Blah blah").toString());
    }
}
````

**扩展包含默认方法的接口**

当你扩展包含默认方法的接口时，你可以这么做：

- 完全不管默认方法，扩展接口将继承其中的默认方法。
- 重新声明默认方法，将它变成 `abstract` 的。
- 重新定义默认方法，也就是重载它。

假设你扩展接口 `TimeClient` 如下：

```java
public interface AnotherTimeClient extends TimeClient { }
```

任何实现了接口 `AnotherTimeClient` 类将拥有由默认方法 `TimeClient.getZonedDateTime` 指定的实现 。

假定你扩展接口 `TimeClient` 如下：

```java
public interface AbstractZoneTimeClient extends TimeClient {
    public ZonedDateTime getZonedDateTime(String zoneString);
}
```

任何实现接口 `AbstractZoneTimeClient` 的类将必须实现方法 `getZonedDateTime` 。该方法是一个 `abstract` 方法，就像接口中所有其他非默认、非静态方法。

假定你扩展接口 `TimeClient` 如下：

```java
public interface HandleInvalidTimeZoneClient extends TimeClient {
    default public ZonedDateTime getZonedDateTime(String zoneString) {
        try {
            return ZonedDateTime.of(getLocalDateTime(),ZoneId.of(zoneString)); 
        } catch (DateTimeException e) {
            System.err.println("Invalid zone ID: " + zoneString +
                "; using the default time zone instead.");
            return ZonedDateTime.of(getLocalDateTime(),ZoneId.systemDefault());
        }
    }
}
```

任何实现接口 `HandleInvalidTimeZoneClient` 的类将使用由此接口指定的 `getZonedDateTime` 方法实现，而不是接口 `TimeClient` 指定的那个。

**静态方法**

除了默认方法，你还可以在接口中定义 [静态方法  。（静态方法是一种与定义它的类相关联的方法，而不是与任何对象相关联。该类的每个实例都共享其静态方法。）这使您可以更轻松地在库中组织辅助方法；您可以在同一个接口中保留特定于接口的静态方法，而不是在单独的类中。以下示例定义一个静态方法，该方法检索与时区标识符对应的 [`ZoneId`](https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html) 对象；如果没有与给定标识符对应的`ZoneId`对象，它使用系统默认时区。（因此，您可以简化方法`getZonedDateTime`）：

```java
public interface TimeClient {
    // ...
    static public ZoneId getZoneId (String zoneString) {
        try {
            return ZoneId.of(zoneString);
        } catch (DateTimeException e) {
            System.err.println("Invalid time zone: " + zoneString +
                "; using default time zone instead.");
            return ZoneId.systemDefault();
        }
    }

    default public ZonedDateTime getZonedDateTime(String zoneString) {
        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));
    }    
}
```

Like static methods in classes, you specify that a method definition in an interface is a static method with the `static` keyword at the beginning of the method signature. All method declarations in an interface, including static methods, are implicitly `public`, so you can omit the `public` modifier.

与类中的静态方法一样，您指定接口中的方法定义是静态方法，在方法签名的开头使用`static`关键字。接口中的所有方法声明（包括静态方法）都隐式为 “public” 的，因此您可以省略`public`修饰符。

**将默认方法集成进入现存的类库**

默认方法允许你添加新的功能到现有的接口中的同时保证基于该接口的老版本编写的代码的二进制兼容性。特别地，默认方法允许你添加接受 lambda 表达式作为参数的方法到现有的接口中。本节介绍如何通过默认方法和静态方法增强 [`Comparator`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html) 接口。

考虑 [Questions and Exercises: Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/creating-questions.html) 中描述的 `Card` 和 `Deck` 类，下面的例子重写了 [`Card`](https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/Card.java) 和 [`Deck`](https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/Deck.java) 类作为接口。其中 `Card` 接口包含两个 `enum` 类型 (`Suit` 和 `Rank`) 以及两个抽象方法 (`getSuit` 和 `getRank`)：

`````java
package defaultmethods;

public interface Card extends Comparable<Card> {
    
    public enum Suit { 
        DIAMONDS (1, "Diamonds"), 
        CLUBS    (2, "Clubs"   ), 
        HEARTS   (3, "Hearts"  ), 
        SPADES   (4, "Spades"  );
        
        private final int value;
        private final String text;
        Suit(int value, String text) {
            this.value = value;
            this.text = text;
        }
        public int value() {return value;}
        public String text() {return text;}
    }
    
    public enum Rank { 
        DEUCE  (2 , "Two"  ),
        THREE  (3 , "Three"), 
        FOUR   (4 , "Four" ), 
        FIVE   (5 , "Five" ), 
        SIX    (6 , "Six"  ), 
        SEVEN  (7 , "Seven"),
        EIGHT  (8 , "Eight"), 
        NINE   (9 , "Nine" ), 
        TEN    (10, "Ten"  ), 
        JACK   (11, "Jack" ),
        QUEEN  (12, "Queen"), 
        KING   (13, "King" ),
        ACE    (14, "Ace"  );
        private final int value;
        private final String text;
        Rank(int value, String text) {
            this.value = value;
            this.text = text;
        }
        public int value() {return value;}
        public String text() {return text;}
    }
    
    public Card.Suit getSuit();
    public Card.Rank getRank();
}
`````

`Deck` 接口包含各种操作方法：

````java
package defaultmethods; 
 
import java.util.*;
import java.util.stream.*;
import java.lang.*;
 
public interface Deck {
    
    List<Card> getCards();
    Deck deckFactory();
    int size();
    void addCard(Card card);
    void addCards(List<Card> cards);
    void addDeck(Deck deck);
    void shuffle();
    void sort();
    void sort(Comparator<Card> c);
    String deckToString();

    Map<Integer, Deck> deal(int players, int numberOfCards)
        throws IllegalArgumentException;

}
````

 [`PlayingCard`](https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/PlayingCard.java) 类实现了接口 `Card`，同时 [`StandardDeck`](https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/StandardDeck.java) 类实现了接口 `Deck` 。

`StandardDeck` 类实现抽象方法 `Deck.sort`如下：

```java
public class StandardDeck implements Deck {
    
    private List<Card> entireDeck;
    
    // ...
    
    public void sort() {
        Collections.sort(entireDeck);
    }
    
    // ...
}
```

 `Collections.sort` 方法对其中元素类型实现了接口 [`Comparable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)  接口的 `List` 实例中的元素进行排。 `entireDeck` 的成员是一个 `List` 实例，其元素类型是 `Card`，该类型扩展了 `Comparable` 接口。 `PlayingCard` 类型实现 [`Comparable.compareTo`](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-) 方法如下：

```java
public int hashCode() {
    return ((suit.value()-1)*13)+rank.value();
}

public int compareTo(Card o) {
    return this.hashCode() - o.hashCode();
}
```

The method `compareTo` causes the method `StandardDeck.sort()` to sort the deck of cards first by suit, and then by rank.

方法 `compareTo` 使方法 `StandardDeck.sort()` 首先按套装对卡片组进行排序，然后按等级排序。

如果你想先按等级排序，然后按套装排序怎么办？您需要实现 [`Comparator`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html) 接口以指定新的排序条件，并使用  [`sort(List list, Comparator c)`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-java.util.Comparator-) （包含 `Comparator` 参数的 `sort` 方法的版本）。您可以在 `StandardDeck` 类中定义以下方法：

```java
public void sort(Comparator<Card> c) {
    Collections.sort(entireDeck, c);
}  
```

使用这个方法，你可以指定方法 `Collections.sort` 使用何种维度对 `Card` 类实例进行排序。实现这一目的的一种方法是实现 `Comparator` 接口来指定排序维度。如下面例子 [`SortByRankThenSuit`](https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/SortByRankThenSuit.java) 所示：

```java
package defaultmethods;

import java.util.*;
import java.util.stream.*;
import java.lang.*;

public class SortByRankThenSuit implements Comparator<Card> {
    public int compare(Card firstCard, Card secondCard) {
        int compVal =
            firstCard.getRank().value() - secondCard.getRank().value();
        if (compVal != 0)
            return compVal;
        else
            return firstCard.getSuit().value() - secondCard.getSuit().value(); 
    }
}
```

下面的例子对牌进行排序，先按照点数，再按花色：

```java
StandardDeck myDeck = new StandardDeck();
myDeck.shuffle();
myDeck.sort(new SortByRankThenSuit());
```

但是，这种方法过于冗长。如果你可以指定你想要排序的东西，而不是你想要排序的方式会更好。假设您是编写 `Comparator` 接口的开发人员。您可以向 `Comparator` 接口添加哪些默认或静态方法，以使其他开发人员能够更轻松地指定排序条件？

首先，假设您想按点数对扑克牌进行排序，而忽略花色，您可以按如下方式调用 `StandardDeck.sort` 方法：

```java
StandardDeck myDeck = new StandardDeck();
myDeck.shuffle();
myDeck.sort(
    (firstCard, secondCard) ->
        firstCard.getRank().value() - secondCard.getRank().value()
); 
```

由于接口 `Comparator` 是一个 [函数式接口](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach6) ，你可以将 lambda 表达式作为 `sort` 方法的一个参数。在这个例子中，lambda 表达式比较两个整数值。

如果他们可以通过仅调用 `Card.getRank` 方法创建 `Comparator` 实例，那么对于您的开发人员来说会更简单。特别是，如果您的开发人员可以创建一个比较任何可以从 `getValue` 或 `hashCode` 等方法返回数值的对象的 `Comparator` 实例，那将会很有帮助。`Comparator` 接口由静态方法  [`comparing`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-java.util.Comparator-) 增强：

```java
myDeck.sort(Comparator.comparing((card) -> card.getRank()));  
```

这个例子中，你可以使用一个 [方法引用](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html) 来替代：

```java
myDeck.sort(Comparator.comparing(Card::getRank));  
```

这个调用更好地展示了*对什么进行排序*而不是*如何排序*。

`Comparator` 接口已经通过其它各种静态方法 `comparing` 的变体增强，比如 [`comparingDouble`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparingDouble-java.util.function.ToDoubleFunction-java.util.Comparator-) 以及 [`comparingLong`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparingLong-java.util.function.ToLongFunction-) ，它们允许你创建 `Comparator` 接口的其它实例来比较其它数据类型。

假设您的开发人员想要创建一个可以比较对象多个维度的 `Comparator` 实例。例如，你如何先按等级点数扑克牌，然后按花色排序？和之前一样，您可以使用 lambda 表达式来指定这些排序条件：


```java
StandardDeck myDeck = new StandardDeck();
myDeck.shuffle();
myDeck.sort(
    (firstCard, secondCard) -> {
        int compare =
            firstCard.getRank().value() - secondCard.getRank().value();
        if (compare != 0)
            return compare;
        else
            return firstCard.getSuit().value() - secondCard.getSuit().value();
    }      
); 
```
如果你的开发人员可以从一系列`Comparator`实例构建一个`Comparator`实例，那对你来说会更简单。使用默认方法 [`thenComparing`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparing-java.util.Comparator-) 增强了 `Comparator` 接口：


```java
myDeck.sort(
    Comparator
        .comparing(Card::getRank)
        .thenComparing(Comparator.comparing(Card::getSuit)));
```

The `Comparator` interface has been enhanced with other versions of the default method `thenComparing` (such as [`thenComparingDouble`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparingDouble-java.util.function.ToDoubleFunction-) and [`thenComparingLong`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparingLong-java.util.function.ToLongFunction-)) that enable you to build `Comparator` instances that compare other data types.

`Comparator` 接口已使用默认方法  `thenComparing`  的其他版本进行了增强（例如 [`thenComparingDouble`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparingDouble-java.util.function.ToDoubleFunction-) 和 [`thenComparingLong`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparingLong-java.util.function.ToLongFunction-) ），使您可以构建比较其他数据类型的 `Comparator` 实例。

假设您的开发人员想要创建一个 `Comparator` 实例，使其能够以相反的顺序对对象集合进行排序。例如，你如何按照点数的降序排序扑克牌组，从Ace到2（而不是从2到Ace）？ 和以前一样，您可以指定另一个 lambda 表达式。但是，如果您的开发人员可以通过调用方法来反转现有的 `Comparator`，则会更简单。`Comparator` 接口已通过此功能得到增强，默认方法 [`reversed`](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#reversed--) ：

```java
myDeck.sort(
    Comparator.comparing(Card::getRank)
        .reversed()
        .thenComparing(Comparator.comparing(Card::getSuit)));
```

此示例演示了如何使用默认方法，静态方法，lambda表达式和方法引用增强 `Comparator` 接口，以创建更具表现力的库方法，业务程序员可以通过查看它们的调用方式快速推断出来。使用这些构造来增强库中的接口。

#### 接口综述

接口声明可以包含方法签名，默认方法，静态方法和常量定义。 具有实现的方法是默认方法和静态方法。

实现接口的类必须实现接口中声明的所有方法。

可以在任何可以使用类型的地方使用接口名称。

### 继承

在前面的章节中，你已经见到了多次*继承*这个术语。在 Java 语言中，类可以从其他类中派生出来，也就是从其他类中*继承*字段和方法。

------

**定义：**从其他类中派生而来的类被称为*子类*，或者*派生类*，*扩展类*等。派生出别的类的类被称为*超类*，或者*基类*，*父类*等。

除了 `Object` 类没有超类，所有的类都有且只有一个直接超类(就是所谓的单继承)。在没有任何其他显式超类的情况下，每个类都隐式地是 `Object` 的子类。

类可以从派生自类的类派生的类派生，依此类推，最终派生自最顶层的类 `Object` 。 这样的类是继承链中延伸回 `Object` 继承路径上的的所有类的后代。

------

继承的想法很简单但很强大：当你想创建一个新类并且已经有一个包含你想要的代码的类时，你可以从现有的类派生你的新类。在这样做时，您可以重用现有类的字段和方法，而无需自己编写（和调试！）它们。

子类从其超类继承所有成员（字段，方法和嵌套类）。构造函数不是成员，因此它们不是由子类继承的，但是可以从子类调用超类的构造函数。

**Java 平台类层级结构**

在 `java.lang` 包中定义的 `Object` 类定义并实现所有类共有的行为 - 包括您编写的类。在Java平台中，许多类直接从 `Object` 派生，其他类派生自其中一些类，依此类推，形成类的层次结构。

![All Classes in the Java Platform are Descendants of Object](https://docs.oracle.com/javase/tutorial/figures/java/classes-object.gif)

Java平台中的所有类都是 `Object` 的后代

在层次结构的顶部，`Object` 是所有类中最通用的。层次结构底部附近的类提供更专业的行为。

**继承的例子**

下面是可能的 `Bicycle` 类的实现：

````java
public class Bicycle {
        
    // the Bicycle class has three fields
    public int cadence;
    public int gear;
    public int speed;
        
    // the Bicycle class has one constructor
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    // the Bicycle class has four methods
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}
````

 `MountainBike` 类作为 `Bicycle` 类的子类如下：

````java
public class MountainBike extends Bicycle {
        
    // the MountainBike subclass adds one field
    public int seatHeight;

    // the MountainBike subclass has one constructor
    public MountainBike(int startHeight,
                        int startCadence,
                        int startSpeed,
                        int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // the MountainBike subclass adds one method
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   
}
````

`MountainBike` 继承 `Bicycle` 的所有字段和方法，并添加了字段 `seatHeight` 以及一个方法来设置它。除了构造器，这类似于你完整编写一个新的 `MountainBike`类，包含四个字段和五个方法。不过，你没必要这样全新编写。当 `Bicycle` 类中的方法非常复杂并需要大量时间调试的情况下继承非常有价值。

**你可以在子类中做什么**

子类继承其父类的所有 *public* 和 *protected* 成员，无论子类在哪个包中。如果子类与其父类在同一个包中，它还继承父类的 *package-private* 成员。您可以按原样使用继承的成员，替换它们，隐藏它们或用新成员补充它们：

 - 可以直接使用继承的字段，就像任何其他字段一样。
 - 您可以在子类中声明一个与超类中的字段相同的字段，因此*隐藏*它（不推荐）。
 - 您可以在子类中声明不在超类中的新字段。
 - 继承的方法可以直接使用。
 - 您可以在子类中编写一个新的 *instance* 方法，该方法与超类中的签名具有相同的签名，因此*覆盖*它。
 - 您可以在子类中编写一个新的 *static* 方法，该方法与超类中的签名具有相同的签名，因此*隐藏*它。
 - 您可以在子类中声明不在超类中的新方法。
 - 你可以编写一个子类构造函数，它可以隐式地或使用关键字`super`来调用超类的构造函数。

本课程的以下部分将扩展这些主题。

**超类中的私有成员**

子类不会继承父类的 `private` 成员。然而，如果超类拥有 `public` 或者 `protected` 成员来访问它的 `private` 字段，这些方法同样可以为子类所用。

嵌套类可以访问其封闭类的所有私有成员 - 包括字段和方法。因此，子类继承的公共或受保护嵌套类可以间接访问超类的所有私有成员。

**对象转型**

我们已经看到一个对象是实例化它出来的类的数据类型。比如，如果我们写：

```java
public MountainBike myBike = new MountainBike();
```

则 `myBike` 就是类型 `MountainBike`。

`MountainBike` 从 `Bicycle` 和 `Object` 派生而来。因此 `MountainBike` 既是 `Bicycle` 又是 `Object`，同时它可以在需要`Bicycle`或`Object`对象的任何地方使用。

反过来就不一定是正确的： `Bicycle` *可以是*  `MountainBike` ，但是并不一定。类似的， `Object` *可以使*  `Bicycle` 或者 `MountainBike`，但是并不一定。

*转型*展示了在继承和实现允许的对象中使用一种类型的对象代替另一种类型。例如，如果我们写：

```java
Object obj = new MountainBike(); 
```

则 `obj` 既是 `Object` 又是 `MountainBike` (直到s `obj` 被赋值为其他不是 `MountainBike` 的对象)。这被称为 *隐式转型*。

另一方面，如果我们写：

```java
MountainBike myBike = obj;
```

我们将得到一个变异错误，因为编译器并不知道 `obj` 是 `MountainBike`。不过，我们可以告诉编译器，会通过*显式转型* 将一个 `MountainBike` 赋值给 `obj` ：

```java
MountainBike myBike = (MountainBike)obj;
```

这个强制转换插入一个运行时检查，为`obj`分配一个`MountainBike`，这样编译器就可以安全地假设`obj`是一个`MountainBike`。如果`obj`在运行时不是`MountainBike`，则会抛出异常。

------

**注意：**您可以使用 `instanceof` 运算符对特定对象的类型进行逻辑测试。这可以避免由不恰当的转型导致的运行时错误。例如：

```java
if (obj instanceof MountainBike) {
    MountainBike myBike = (MountainBike)obj;
}
```

这里`instanceof`运算符验证`obj`是否指向`MountainBike`，以便我们可以在知道不会抛出运行时异常前提下使用转型。

------

#### 状态多继承，实现和类型

类和接口之间的一个显著区别是类可以有字段而接口不能。此外，您可以实例化一个类来创建一个对象，这是您无法使用接口进行的。如“什么是对象？”一节中所述，对象将其状态存储在字段中，这些字段在类中定义。Java编程语言不允许扩展多个类的一个原因是避免了多重继承状态的问题，即从多个类继承字段的能力。例如，假设您能够定义一个扩展多个类的新类。通过实例化该类来创建对象时，该对象将继承所有类的超类中的字段。如果来自不同超类的方法或构造函数实例化相同的字段会怎样？哪个方法或构造函数优先？由于接口不包含字段，因此您不必担心多重继承状态所导致的问题。

实现的多重继承是从多个类继承方法定义的能力。这种类型的多重继承会出现问题，例如名称冲突和歧义。当支持这种类型的多重继承的编程语言的编译器遇到包含具有相同名称的方法的超类时，它们有时无法确定要访问或调用的成员或方法。此外，程序员可能通过向超类添加新方法而无意中引入名称冲突。默认方法引入了一种形式的多重继承实现。一个类可以实现多个接口，该接口可以包含具有相同名称的默认方法。Java编译器提供了一些规则来确定特定类使用哪种默认方法。

Java编程语言支持多种类型的继承，这是类实现多个接口的能力。一个对象可以有多种类型：它自己的类的类型以及该类实现的所有接口的类型。这意味着如果将变量声明为接口的类型，则其值可以引用从实现接口的任何类实例化的任何对象。这在“将接口用作类型”一节中讨论。

与多实现继承一样，类可以继承在其扩展的接口中定义的方法的不同实现（作为默认或静态）。在这种情况下，编译器或用户必须决定使用哪一个。

#### 覆盖和方法隐藏

**实例方法**

子类中的一个实例方法，如果方法签名（方法名称、参数个数和参数类型）与超类中的方法相同，则会覆盖超类中的方法。

子类覆盖方法的能力允许一个类从尽可能接近需求的超类继承并按照具体需求修改行为。覆盖方法与被它覆盖的方法具有相同的名称，相同的参数个数和类型，相同的返回类型。覆盖方法也可以返回被覆盖方法返回类型的子类型。该子类型被称为*协变返回类型*。

当你覆盖一个方法，你可能会希望使用 `@Override` 注解来告诉编译器你试图覆盖超类中的一个方法。如果编译器探测到超类中不存在这样的方法，就会产生一个变异错误。更多信息参考 [`Annotations`](https://docs.oracle.com/javase/tutorial/java/annotations/index.html)。

**静态方法**

如果子类定义了一个静态方法，该方法与超类中的静态方法具有相同的签名，那么子类中的方法将*隐藏*超类中的方法。

隐藏静态方法和覆盖实例方法之间的区别具有重要意义：

 - 被调用的重写实例方法的版本是子类中的版本。
 - 被调用的隐藏静态方法的版本取决于它是从超类还是从子类调用的。

考虑一个包含两个类的示例。 第一个是`Animal`，它包含一个实例方法和一个静态方法：

```java
public class Animal {
    public static void testClassMethod() {
        System.out.println("The static method in Animal");
    }
    public void testInstanceMethod() {
        System.out.println("The instance method in Animal");
    }
}
```

 `Animal` 的子类叫做 `Cat`：

```java
public class Cat extends Animal {
    public static void testClassMethod() {
        System.out.println("The static method in Cat");
    }
    public void testInstanceMethod() {
        System.out.println("The instance method in Cat");
    }

    public static void main(String[] args) {
        Cat myCat = new Cat();
        Animal myAnimal = myCat;
        Animal.testClassMethod();
        myAnimal.testInstanceMethod();
    }
}
```

`Cat` 类重写 `Animal` 中的实例方法，并隐藏 `Animal` 中的静态方法。此类中的 `main` 方法创建 `Cat` 的实例并在类上调用 `testClassMethod()` 并在实例上调用 `testInstanceMethod()` 。

程序输出如下：

```java
The static method in Animal
The instance method in Cat
```

正如所承诺的那样，被调用的隐藏静态方法的版本是超类中的版本，被调用的重写实例方法的版本是子类中的版本。

**接口方法**

接口中的 [默认方法](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html) 和 [抽象方法](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html) 像实例方法一样被继承。不过，当超类或者接口提供了多个相同方法签名的默认方法时，编辑器将遵循继承规则来解决名称冲突。由下面两条原则驱动：

- 实例方法优先于接口默认方法。

  考虑下面的类和接口：

  ```java
  public class Horse {
      public String identifyMyself() {
          return "I am a horse.";
      }
  }
  ```

  ```java
  public interface Flyer {
      default public String identifyMyself() {
          return "I am able to fly.";
      }
  }
  ```

  ```
  public interface Mythical {
      default public String identifyMyself() {
          return "I am a mythical creature.";
      }
  }
  ```

  ```java
  public class Pegasus extends Horse implements Flyer, Mythical {
      public static void main(String... args) {
          Pegasus myApp = new Pegasus();
          System.out.println(myApp.identifyMyself());
      }
  }
  ```

  方法 `Pegasus.identifyMyself` 返回字符串 `I am a horse` 。

- 被其他候选者覆盖的方法会被忽略。当超类共享一个共同的祖先时，就会出现这种情况。

  考虑下面的接口和类：

  ```java
  public interface Animal {
      default public String identifyMyself() {
          return "I am an animal.";
      }
  }
  ```

  ```java
  public interface EggLayer extends Animal {
      default public String identifyMyself() {
          return "I am able to lay eggs.";
      }
  }
  ```

  ```java
  public interface FireBreather extends Animal { }
  ```

  ```java
  public class Dragon implements EggLayer, FireBreather {
      public static void main (String... args) {
          Dragon myApp = new Dragon();
          System.out.println(myApp.identifyMyself());
      }
  }
  ```

  方法 `Dragon.identifyMyself` 返回字符串 `I am able to lay eggs.`

如果两个或多个独立定义的缺省方法冲突，或者缺省方法与抽象方法冲突，则Java编译器会产生编译器错误。您必须显式覆盖超类方法。

考虑一下现在可以飞行的计算机控制汽车的例子。你有两个接口（`OperateCar`和`FlyCar`）为同一个方法（`startEngine`）提供默认实现：

```java
public interface OperateCar {
    // ...
    default public int startEngine(EncryptedKey key) {
        // Implementation
    }
}
public interface FlyCar {
    // ...
    default public int startEngine(EncryptedKey key) {
        // Implementation
    }
}
```

实现`OperateCar`和`FlyCar`的类必须覆盖方法`startEngine`。您可以使用`super`关键字调用任何默认实现。

```java
public class FlyingCar implements OperateCar, FlyCar {
    // ...
    public int startEngine(EncryptedKey key) {
        FlyCar.super.startEngine(key);
        OperateCar.super.startEngine(key);
    }
}
```

在`super`之前的名称（在这个例子中，`FlyCar`或`OperateCar`）必须引用一个直接超级接口，它定义或继承被调用方法的默认值。这种形式的方法调用不限于区分包含具有相同签名的默认方法的多个已实现接口。您可以使用`super`关键字在类和接口中调用默认方法。

类中的继承实例方法可以覆盖抽象接口方法。考虑以下接口和类：

```java
public interface Mammal {
    String identifyMyself();
}
public class Horse {
    public String identifyMyself() {
        return "I am a horse.";
    }
}
public class Mustang extends Horse implements Mammal {
    public static void main(String... args) {
        Mustang myApp = new Mustang();
        System.out.println(myApp.identifyMyself());
    }
}
```

方法`Mustang.identifyMyself`返回字符串 `I am a horse.` 。类 `Mustang`从类`Horse`继承方法`identifyMyself`，它覆盖了接口 `Mammal` 中同名的抽象方法。

**注意**：接口中的静态方法永远不会被继承。

**修改器**

覆盖方法的访问修饰符可以允许比重写方法更多但不是更少的访问。例如，超类中的 `protected` 实例方法可以在子类中 `public` ，但不是 `private` 。

如果尝试将超类中的实例方法更改为子类中的静态方法，则会出现编译时错误，反之亦然。

**总结**

下表总结了在定义具有与超类中的方法相同的签名的方法时发生的情况。

|        | Superclass Instance Method | Superclass Static Method |
| ------ | -------------------------- | ------------------------ |
| 子类实例方法 | 覆盖                         | 产生编译错误                   |
| 子类静态方法 | 产生编译错误                     | 隐藏                       |

------

**注意：**在子类中，您可以重载从超类继承的方法。这种重载方法既不隐藏也不覆盖超类实例方法 - 它们是新方法，对于子类是唯一的。

------

#### 多态

*多态性*的字典定义是指生物学中的原理，其中生物体或物种可以具有许多不同的形态或阶段。这个原则也可以应用于面向对象的编程和Java语言之类的语言。类的子类可以定义它们自己的唯一行为，但仍然共享父类的一些相同功能。

可以通过对 `Bicycle` 类的微小修改来演示多态性。例如，可以将 `printDescription` 方法添加到显示当前存储在实例中的所有数据的类中。

```java
public void printDescription(){
    System.out.println("\nBike is " + "in gear " + this.gear
        + " with a cadence of " + this.cadence +
        " and travelling at a speed of " + this.speed + ". ");
}
```

要演示Java语言中的多态特性，请使用`MountainBike`和`RoadBike`类扩展`Bicycle`类。对于`MountainBike`，为`suspension`添加一个字段，这是一个`String`值，表示自行车是否有前减震器，`Front`。或者，这辆自行车有一个前后减震器，`Dual`。

这是升级后的类：

```java
public class MountainBike extends Bicycle {
    private String suspension;

    public MountainBike(
               int startCadence,
               int startSpeed,
               int startGear,
               String suspensionType){
        super(startCadence,
              startSpeed,
              startGear);
        this.setSuspension(suspensionType);
    }

    public String getSuspension(){
      return this.suspension;
    }

    public void setSuspension(String suspensionType) {
        this.suspension = suspensionType;
    }

    public void printDescription() {
        super.printDescription();
        System.out.println("The " + "MountainBike has a" +
            getSuspension() + " suspension.");
    }
} 
```

请注意重写的`printDescription`方法。除了之前提供的信息之外，还有关于暂停的其他数据包含在输出中。

接下来，创建`RoadBike`类。因为公路或赛车有紧身轮胎，所以添加一个属性来跟踪轮胎宽度。这是`RoadBike`类：

```java
public class RoadBike extends Bicycle{
    // In millimeters (mm)
    private int tireWidth;

    public RoadBike(int startCadence,
                    int startSpeed,
                    int startGear,
                    int newTireWidth){
        super(startCadence,
              startSpeed,
              startGear);
        this.setTireWidth(newTireWidth);
    }

    public int getTireWidth(){
      return this.tireWidth;
    }

    public void setTireWidth(int newTireWidth){
        this.tireWidth = newTireWidth;
    }

    public void printDescription(){
        super.printDescription();
        System.out.println("The RoadBike" + " has " + getTireWidth() +
            " MM tires.");
    }
}
```

请注意，再次，`printDescription`方法已被覆盖。这次，显示有关轮胎宽度的信息。

总而言之，有三个类：`Bicycle`，`MountainBike`和`RoadBike`。这两个子类覆盖`printDescription`方法并打印唯一信息。

这是一个测试程序，它创建了三个`Bicycle`变量。每个变量都分配给三个自行车类别中的一个。然后打印每个变量。

```java
public class TestBikes {
  public static void main(String[] args){
    Bicycle bike01, bike02, bike03;

    bike01 = new Bicycle(20, 10, 1);
    bike02 = new MountainBike(20, 10, 5, "Dual");
    bike03 = new RoadBike(40, 20, 8, 23);

    bike01.printDescription();
    bike02.printDescription();
    bike03.printDescription();
  }
}
```

程序输出：

```shell
Bike is in gear 1 with a cadence of 20 and travelling at a speed of 10. 

Bike is in gear 5 with a cadence of 20 and travelling at a speed of 10. 
The MountainBike has a Dual suspension.

Bike is in gear 8 with a cadence of 40 and travelling at a speed of 20. 
The RoadBike has 23 MM tires.
```

Java虚拟机（JVM）为每个变量中引用的对象调用适当的方法。它不会调用由变量类型定义的方法。此行为称为*虚方法调用*，展示了Java语言中重要多态性功能的一个方面。

#### 隐藏字段

在类中，与超类中的字段具有相同名称的字段会隐藏超类的字段，即使它们的类型不同也是如此。在子类中，超类中的字段不能通过其简单名称引用。相反，必须通过 `super` 访问该字段，这将在下一节中介绍。一般来说，我们不建议隐藏字段，因为它使代码难以阅读。

#### 使用 `super` 关键字

**访问超类成员**

如果你的方法覆盖了一个它的超类的方法，你可以通过使用 `super` 关键字调用被覆盖的方法。你也可以使用 `super` 关键字来表示一个隐藏字段，尽管我们不鼓励这么做。考虑下面的类 `Superclass` ：

```java
public class Superclass {

    public void printMethod() {
        System.out.println("Printed in Superclass.");
    }
}
```

下面是一个子类 `Subclass`，覆盖了 `printMethod()`：

```java
public class Subclass extends Superclass {

    // overrides printMethod in Superclass
    public void printMethod() {
        super.printMethod();
        System.out.println("Printed in Subclass");
    }
    public static void main(String[] args) {
        Subclass s = new Subclass();
        s.printMethod();    
    }
}
```

在 `Subclass` 中，简单方法名 `printMethod()` 表示在 `Subclass` 中声明的那个方法，该方法覆盖了 `Superclass`中的那个同名方法。因此，为了表示继承自 `Superclass` 的  `printMethod()`，`Subclass` 必须使用全限定名，使用 `super` 关键字。编译并执行 `Subclass` 打印如下结果：

```shell
Printed in Superclass.
Printed in Subclass
```

**子类构造器**

以下示例说明如何使用`super`关键字来调用超类的构造函数。 回想一下[`Bicycle`](https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html) 的例子，`MountainBike`是`Bicycle`的子类。这是`MountainBike`（子类）构造函数，它调用超类构造函数，然后添加自己的初始化代码：

```java
public MountainBike(int startHeight, 
                    int startCadence, 
                    int startSpeed,
                    int startGear) {
    super(startCadence, startSpeed, startGear);
    seatHeight = startHeight;
}   
```

调用超类的构造器必须是子类构造器的第一行代码。

调用超类构造器的语法如下：

```java
super();  
```

或者：

```java
super(parameter list);
```

使用 `super()`，超类的无参构造器被调用。使用 `super(parameter list)`，超类具有相应参数列表的构造器被调用。

------

注意：如果构造函数未显式调用超类构造函数，则Java编译器会自动插入对超类的无参数构造函数的调用。如果超类没有无参数构造函数，则会出现编译时错误。`Object` 确实有这样的构造函数，因此如果 `Object` 是唯一的超类，则没有问题。

------

如果子类构造函数显式或隐式地调用其超类的构造函数，您可能会认为将会调用一整个构造函数链，一直回到`Object`的构造函数。事实上，情况就是这样。它被称为*构造函数链*，当需要很长的类后代时你需要注意它。

#### `Object` 作为超类

[`object`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html) 类位于`java.lang`包中，位于类层次结构树的顶端。每个类都是`Object`类的直接或间接的后代。您使用或编写的每个类都继承了`Object`的实例方法。您可能不需要使用任何这些方法，但是，如果您选择这样做，则可能需要使用特定于您的类的代码覆盖它们。本节中讨论的继承自`Object`的方法是：

- `protected Object clone() throws CloneNotSupportedException`
    创建并返回该对象的一个拷贝。
- `public boolean equals(Object obj)`
    表示其他对象是否等于这个对象。
- `protected void finalize() throws Throwable`
    当垃圾收集器确定不存在引用指向此对象时由垃圾收集器在该对象上调用。
- `public final Class getClass()`
    返回一个对象的运行时类型。
- `public int hashCode()`
    返回对象的哈希值。
- `public String toString()`
    返回对象的字符串表示。

`Object`的`notify`，`notifyAll`和`wait`方法都在同步程序中独立运行的线程的活动中起作用，这将在后面的课程中讨论，这里不再介绍。这些方法有五种：

- `public final void notify()`
- `public final void notifyAll()`
- `public final void wait()`
- `public final void wait(long timeout)`
- `public final void wait(long timeout, int nanos)`

------

**注意：**许多方法都有一些微妙的方面，尤其是`clone`方法。

------

**`clone()` 方法**

如果一个类，或者它的超类之一，实现了 `Cloneable` 接口，你就可以使用 `clone()` 方法来创建现存对象的一个拷贝。可以这么写：

```java
aCloneableObject.clone();
```

`Object`'s implementation of this method checks to see whether the object on which `clone()` was invoked implements the `Cloneable` interface. If the object does not, the method throws a `CloneNotSupportedException` exception. Exception handling will be covered in a later lesson. For the moment, you need to know that `clone()` must be declared as

`Object`的这个方法的实现检查 `clone()`被调用的对象是否实现了`Cloneable`接口。如果对象没有，则该方法抛出`CloneNotSupportedException`异常。稍后的课程将介绍异常处理。目前，您需要知道`clone()`必须声明为：

```java
protected Object clone() throws CloneNotSupportedException
```

或者：

```java
public Object clone() throws CloneNotSupportedException
```

如果你正在写的 `clone()` 方法来覆盖 `Object` 中的那个。

如果调用`clone()`的对象实现了`Cloneable`接口，那么`object`的`clone()`方法的实现会创建一个与原始对象相同的类的对象并初始化新对象的成员变量与原始对象的相应成员变量具有相同的值。

使类可复制的最简单方法是将 `implements Cloneable` 添加到类的声明中。然后你的对象可以调用`clone()`方法。

对于某些类，`Object`的`clone()`方法的默认行为可以正常工作。但是，如果一个对象包含对外部对象的引用，比如说 `ObjExternal`，则可能需要覆盖`clone()`以获得正确的行为。否则，一个对象所做的 `ObjExternal` 的更改也会在其克隆中可见。这意味着原始对象及其克隆不是独立的 - 要将它们分离，你必须覆盖`clone()`以便它克隆对象本身*和*`ObjExternal`。然后原始对象引用 `ObjExternal` ，并且克隆引用 `ObjExternal` 的克隆，以便对象及其克隆真正独立。

**`equals()` 方法**

The `equals()` method compares two objects for equality and returns `true` if they are equal. The `equals()` method provided in the `Object` class uses the identity operator (`==`) to determine whether two objects are equal. For primitive data types, this gives the correct result. For objects, however, it does not. The `equals()` method provided by `Object` tests whether the object *references* are equal—that is, if the objects compared are the exact same object.

To test whether two objects are equal in the sense of *equivalency* (containing the same information), you must override the `equals()` method. Here is an example of a `Book` class that overrides `equals()`:

`equals()`方法比较两个对象是否相等，如果它们相等则返回 `true`。`Object`类中提供的`equals()`方法使用相等运算符（`==`）来确定两个对象是否相等。对于基本数据类型，这会给出正确的结果。但是，对于对象，结果就跟我们想象的不太一样。`Object`提供的`equals()`方法测试对象*引用*是否相等 - 即，被比较的对象是否是完全相同的对象。

要测试两个对象在 *equivalency*（包含相同的信息）意义上是否相等，必须覆盖`equals()`方法。这是一个覆盖`equals()`的`Book`类的例子：

```java
public class Book {
    ...
    public boolean equals(Object obj) {
        if (obj instanceof Book)
            return ISBN.equals((Book)obj.getISBN()); 
        else
            return false;
    }
}
```

考虑这个代码来测试`Book`类的两个实例是否相等：

```java
// Swing Tutorial, 2nd edition
Book firstBook  = new Book("0201914670");
Book secondBook = new Book("0201914670");
if (firstBook.equals(secondBook)) {
    System.out.println("objects are equal");
} else {
    System.out.println("objects are not equal");
}
```

This program displays `objects are equal` even though `firstBook` and `secondBook` reference two distinct objects. They are considered equal because the objects compared contain the same ISBN number.

You should always override the `equals()` method if the identity operator is not appropriate for your class.

即使`firstBook`和`secondBook`引用两个不同的对象，该程序也会显示`对象相等`。它们被认为是相同的，因为比较的对象包含相同的 ISBN 号。

如果相等运算符不适合您的类，则应始终覆盖`equals（）`方法。

------

**注意：**如果重写`equals()`，则还必须覆盖 `hashCode()`。

------

**`finalize()` 方法**

The `Object` class provides a callback method, `finalize()`, that *may be* invoked on an object when it becomes garbage. `Object`'s implementation of `finalize()` does nothing—you can override `finalize()` to do cleanup, such as freeing resources.

The `finalize()` method *may be* called automatically by the system, but when it is called, or even if it is called, is uncertain. Therefore, you should not rely on this method to do your cleanup for you. For example, if you don't close file descriptors in your code after performing I/O and you expect `finalize()` to close them for you, you may run out of file descriptors.

`Object`类提供了一个回调方法`finalize()`，当它变成垃圾时，*可以在对象上调用*。 `object`的`finalize()`的实现什么都不做 - 你可以覆盖`finalize()`去做清理，比如释放资源。

系统可以自动调用`finalize()`方法，但是它何时被调用，它是否确实被调用，都是不确定的。因此，您不应该依赖此方法为您进行清理。例如，如果在执行 I/O 后没有在代码中关闭文件描述符，并且您希望`finalize()`为您关闭它们，则可能会用完文件描述符。

**`getClass()` 方法**

You cannot override `getClass`.

The `getClass()` method returns a `Class` object, which has methods you can use to get information about the class, such as its name (`getSimpleName()`), its superclass (`getSuperclass()`), and the interfaces it implements (`getInterfaces()`). For example, the following method gets and displays the class name of an object:

你不能覆盖`getClass`。

`getClass()`方法返回一个`Class`对象，它有一些方法可以用来获取有关该类的信息，例如它的名字（`getSimpleName()`），它的超类（`getSuperclass()`）和 它实现的接口（`getInterfaces()`）。例如，以下方法获取并显示对象的类名称：

```java
void printClassName(Object obj) {
    System.out.println("The object's" + " class is " +
        obj.getClass().getSimpleName());
}
```

`java.lang`包中的 [`Class`](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html)有很多方法 （超过50个）。例如，您可以测试以查看类是不是注解（`isAnnotation()`），接口（`isInterface()`）还是枚举（`isEnum()`）。你可以看到对象的字段是什么（`getFields()`）或它的方法是什么（`getMethods()`），依此类推。

**`hashCode()` 方法**

The value returned by `hashCode()` is the object's hash code, which is the object's memory address in hexadecimal.

By definition, if two objects are equal, their hash code *must also* be equal. If you override the `equals()` method, you change the way two objects are equated and `Object`'s implementation of `hashCode()` is no longer valid. Therefore, if you override the `equals()` method, you must also override the `hashCode()` method as well.

`hashCode()`返回的值是对象的哈希码，它是十六进制的对象的内存地址。

根据定义，如果两个对象相等，则它们的哈希码也必须相等。如果重写`equals()`方法，则改变两个对象的等价方式，`Object`的`hashCode()`的实现不再有效。因此，如果重写`equals()`方法，则还必须覆盖`hashCode()`方法。

**`toString()` 方法**

您应该始终考虑覆盖类中的`toString()`方法。

`Object`的`toString()`方法返回对象的`String`表示，这对调试非常有用。对象的`String`表示完全取决于对象，这就是你需要在类中重写`toString()`的原因。

您可以使用`toString()`和`System.out.println()`来显示对象的文本表示，例如`Book`的实例：

```java
System.out.println(firstBook.toString());
```

对于正确覆盖的`toString()`方法，它会打印一些有用的东西，如下所示：

```shell
ISBN: 0201914670; The Swing Tutorial; A Guide to Constructing GUIs, 2nd Edition
```
#### 编写 `final` 类和方法

你可以将类的全部或者符分方法声明为*final*的。你在方法声明中使用 `fianl` 关键字表示该方法不能被子类覆盖。`Object` 类就是这样做的，其中的很多方法都是 `final` 的。

你可能希望将某个方法声明为 `final` 的，如果该方法实现不能被改变，而且它对保持对象状态的一致性非常关键。比如，你可能希望将 `ChessAlgorithm` 类中的 `getFirstPlayer` 方法声明为 `final` 的：


````java
class ChessAlgorithm {
    enum ChessPlayer { WHITE, BLACK }
    ...
    final ChessPlayer getFirstPlayer() {
        return ChessPlayer.WHITE;
    }
    ...
}
````


从构造器中调用的方法通常应该声明为 `fianl` 的。如果构造器调用的方法不是 `fianl` 的，则子类可能会重新定义该方法，从而导致期望之外的结果。

注意，你也可以声明完整的类为 `final` 的。`final` 类不能有子类。这样做相当有用，比如，当创建一个不可变类，类似与 `String` 类时。

#### 抽象类和抽象方法

抽象类是一个声明为 `abstract` 的类 - 它可能包含也可能不包含抽象方法。抽象类无法实例化，但可以进行子类化。

抽象方法是在没有实现的情况下声明的方法（没有大括号，后跟分号），如下所示：

```java
abstract void moveTo(double deltaX, double deltaY);
```

如果一个类包含 `abstract` 方法，则该类本身也必须声明为 `abstract` 的。如下：

```java
public abstract class GraphicObject {
   // declare fields
   // declare nonabstract methods
   abstract void draw();
}
```

When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared `abstract`.

当抽象类被子类化时，子类通常为其父类中的所有抽象方法提供实现。但是，如果没有，那么子类也必须声明为 `abstract` 。

------

**注意：**未声明为 `default` 或 `static` 的接口（请参阅  [Interfaces](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)  部分）中的方法是隐式抽象的，因此 `abstract` 修饰符不与接口方法一起使用。（可以使用，但不是必要的。）

------

**抽象类和接口对比**

抽象类与接口类似。您无法实例化它们，并且它们可能包含有实现或未实现的方法声明。但是，对于抽象类，您可以声明非 `static` 和非 `final` 的字段，并定义 `public` ，`protected` 和 `private` 具体方法。使用接口，所有字段都自动为 `public` ，`static` 和 `final`，并且您声明或定义的所有方法（作为默认方法）都是 `public` 的。此外，您只能扩展一个类，无论它是否是抽象的，而您可以实现任意数量的接口。

抽象类还是接口，应该使用谁？

 - 如果这些陈述中的任何一个适用于您的情况，请考虑使用抽象类：
       - 您希望在几个密切相关的类之间共享代码。
       - 您希望扩展抽象类的类具有许多常用方法或字段，或者需要除 `public` 之外的访问修饰符（例如 `protected` 和 `private`）。
       - 您想声明非 `static` 或非 `final` 字段。这使您可以定义可以访问和修改它们所属对象的状态的方法。
 - 如果任何这些陈述适用于您的情况，请考虑使用接口：
       - 您希望不相关的类实现您的接口。 例如， [`Comparable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html) 和 [`Cloneable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html) 接口由许多不相关的类实现。
       - 您希望指定特定数据类型的行为，但不关心谁实现其行为。
       - 您希望利用类型的多重继承。

JDK中的抽象类的一个示例是 [`AbstractMap`](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html)，它是集合框架的一部分。它的子类（包括 `HashMap`，`TreeMap` 和  `ConcurrentHashMap`）共享 `AbstractMap` 定义的许多方法（包括 `get`，`put`，`isEmpty`，`containsKey` 和 `containsValue`）。

JDK中实现多个接口的类的示例是 [`HashMap`](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)，它实现 `Serializable`，`Cloneable和Map <K，V>` 接口。通过读取此接口列表，您可以推断出可以克隆 `HashMap` 的实例（无论是谁实现该类），可序列化（这意味着它可以转换为字节流：请参阅 [Serializable Objects](https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html)），并具有 `map` 的功能。此外，`Map <K，V>` 接口已经增强了许多默认方法，例如 `merge` 和 `forEach`，实现此接口的旧类不必自己定义。

请注意，许多软件库都使用抽象类和接口：`HashMap` 类实现了几个接口，并且还扩展了抽象类 `AbstractMap`。

**抽象类的例子**

在面向对象的绘图应用程序中，您可以绘制圆形，矩形，线条，贝塞尔曲线和许多其他图形对象。这些对象都具有某些状态（例如：位置，方向，线条颜色，填充颜色）和行为（例如：`moveTo`，`rotate`，`resize`，`draw`）。对于所有图形对象，这些状态和行为中的一些是相同的（例如：位置，填充颜色和 `moveTo`）。其他需要不同的实现（例如，`resize` 或 `draw`）。所有 `GraphicObjects` 必须能够 `draw` 自己或调整自己的大小；它们在如何做到这一点上有所不同。这是抽象超类的完美情况。您可以利用相似性并声明所有图形对象从同一个抽象父对象（例如，`GraphicObject`）继承，如下图所示：

![Classes Rectangle, Line, Bezier, and Circle Inherit from GraphicObject ](https://docs.oracle.com/javase/tutorial/figures/java/classes-graphicObject.gif)

首先，声明一个抽象类 `GraphicObject`，以提供所有子类完全共享的成员变量和方法，例如当前位置和 `moveTo` 方法。 `GraphicObject` 还声明了抽象方法，例如 `draw` 或 `resize`，它们需要由所有子类实现，但必须以不同的方式实现。`GraphicObject` 类看起来像这样：

````java
abstract class GraphicObject {
    int x, y;
    ...
    void moveTo(int newX, int newY) {
        ...
    }
    abstract void draw();
    abstract void resize();
}
````

每个 `GraphicObject` 的非抽象子类，比如 `Circle` 和 `Rectangle`，必须提供 `draw` 和 `resize` 方法的实现：

```java
class Circle extends GraphicObject {
    void draw() {
        ...
    }
    void resize() {
        ...
    }
}
class Rectangle extends GraphicObject {
    void draw() {
        ...
    }
    void resize() {
        ...
    }
}
```

**当抽象类实现接口**

在 [`Interfaces`](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html) 章节中，注意到实现接口的类必须实现所有接口的方法。但是，如果声明该类是抽象的，则可以定义一个不实现所有接口方法的类。例如：

```java
abstract class X implements Y {
  // implements all but one method of Y
}

class XX extends X {
  // implements the remaining method in Y
}
```

在这种情况下，类`X`必须是`abstract` 的，因为它没有完全实现`Y`，但类`XX`实际上实现了`Y`。

**类成员**

抽象类可以具有 `static` 字段和 `static` 方法。您可以像使用任何其他类一样使用带有类引用的静态成员（例如， `AbstractClass.staticMethod()`）。

#### 继承综述

除了`Object`类，一个类只有一个直接超类。类继承其所有超类中的字段和方法，无论是直接还是间接。子类可以覆盖它继承的方法，也可以隐藏它继承的字段或方法。 （注意，隐藏字段通常是糟糕的编程习惯。）

[覆盖和隐藏方法](https://docs.oracle.com/javase/tutorial/java/IandI/override.html) 章节中的表显示了使用与超类中的方法相同的签名声明方法的效果。

`Object`类是类层次结构的顶层。所有类都是此类的后代，并从中继承方法。从`Object`继承的有用方法包括`toString()`，`equals()`，`clone()`和`getClass()`。

您可以通过在类的声明中使用`final`关键字来阻止类被子类化。同样，您可以通过将方法声明为 `final` 方法来防止子类覆盖该方法。

抽象类只能被子类化，它无法实例化。抽象类可以包含声明但未实现的方法 - 抽象方法。子类然后提供抽象方法的实现。

## 数字和字符串

[Numbers](https://docs.oracle.com/javase/tutorial/java/data/numbers.html)

本节首先讨论 `Number` 类（在 `java.lang` 包中）及其子类。特别是，本节讨论了使用这些类的实例化而不是原始数据类型的情况。此外，本节还讨论了处理数字时可能需要的其他类，例如格式化或使用数学函数来补充语言中内置的运算符。 最后，讨论了自动装箱和拆箱，这是一种简化代码的编译器功能。

[Strings](https://docs.oracle.com/javase/tutorial/java/data/strings.html)

在Java编程中广泛使用的字符串，是一系列字符。在Java编程语言中，字符串是对象。本节介绍如何使用 `String` 类创建和操作字符串。它还比较了 `String` 和 `StringBuilder` 类。

### Numbers

本节首先讨论 `java.lang` 包中的 `Number` 类，它的子类，以及使用这些类的实例化而不是原始数字类型的情况。

本节还介绍了 `PrintStream` 和 `DecimalFormat` 类，它们提供了编写格式化数字输出的方法。

最后，讨论了 `java.lang` 中的 `Math` 类。它包含数学函数，以补充语言中内置的运算符。该类具有三角函数，指数函数等方法。

#### Numbers 类

当我们使用数字时，大多数情况下都会使用基本数据类型。比如：



````java
int i = 500;
float gpa = 3.65f;
byte mask = 0xff;

````

不过，有理由使用对象而不使用基本数据类型，同时 Java 平台提供了 *wrapper* 类来包装所有的基本数据类型。这些类将基本数据类型*包装*进入对象。通常，该包装过程由编译器自动完成，如果你在期望一个对象的地方使用基本数据类型，编译器就会通过该基本数据类型的包装器对它进行*装箱*。类似的，如果你在期望基本数据类型的地方使用数字对象，编译器将会为你自动*拆箱*。更多信息，参考 [自动装箱和拆箱](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html)

所有数值类型的包装器类都是抽象类 `Number` 的子类：

![The class hierarchy of Number.](https://docs.oracle.com/javase/tutorial/figures/java/objects-numberHierarchy.gif)

------

**注意：** 另外还有四种 `Number` 的子类，这里不讨论。 `BigDecimal` 和 `BigInteger` 被用于高精度计算。`AtomicInteger` 和 `AtomicLong` 被用于多线程应用。

------

有三个理由佐证应该优先使用 `Number` 对象而不是基本数据类型：

1. 作为期望对象的方法的参数（通常在操作数字集合时使用）。
2. 使用由类定义的常量（如 `MIN_VALUE` 和 `MAX_VALUE`），它们提供数据类型的上限和下限。
3. 使用类方法将值转换为其它基本数据类型，或者由其它数据类型转换而来，比如将数值转换为字符串或者从字符串转换来数值，以及在计数系统之间进行转换（十进制，八进制，十六进制，二进制）。

下表列出了Number类的所有子类实现的实例方法。

| 方法                                       | 描述                                       |
| :--------------------------------------- | ---------------------------------------- |
| `byte byteValue()`<br />`short shortValue()`<br />`int intValue()`<br />`long longValue()`<br />`float floatValue()`<br />`double doubleValue()` | 将 `Number` 对象转化未返回的基本数据类型。               |
| `int compareTo(Byte anotherByte)`<br />`int compareTo(Double anotherDouble)`<br />`int compareTo(Float anotherFloat)`<br />`int compareTo(Integer anotherInteger)`<br />`int compareTo(Long anotherLong)`<br />`int compareTo(Short anotherShort)` | 将 `Number` 对象与参数比较。                      |
| `boolean equals(Object obj)`             | 确定此数字对象是否等于参数。如果参数不为 `null` 并且是相同类型且具有相同数值的对象，则方法返回 `true`。对于 `Double` 和 `Float` 对象有一些额外要求，在 Java API 文档中描述。 |

每个 `Number` 类都包含其他方法，这些方法可用于将数字转换为字符串以及转换为数字系统之间的数字。下表列出了 `Integer` 类中的这些方法。其他 `Number` 子类的方法类似：

| 方法                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `static Integer decode(String s)`        | 将字符串解码为整数。 可以接受十进制，八进制或十六进制数字的字符串表示作为输入。 |
| `static int parseInt(String s)`          | 返回一个整数（仅十进制）。                            |
| `static int parseInt(String s, int radix)` | 给定十进制，二进制，八进制或十六进制（基数分别等于10、2、8 或 16）数字作为输入的字符串表示形式，返回一个整数。 |
| `String toString()`                      | 返回表示此 `Integer` 值的 `String` 对象。          |
| `static String toString(int i)`          | 返回表示指定整数的 `String` 对象。                   |
| `static Integer valueOf(int i)`          | 返回包含指定基元值的 `Integer` 对象。                 |
| `static Integer valueOf(String s)`       | 返回一个包含指定字符串表示形式值的 `Integer` 对象。          |
| `static Integer valueOf(String s, int radix)` | 返回一个 `Integer` 对象，该对象包含指定字符串表示形式的整数值，并使用 `radix` 值进行解析。例如，如果 `s = "333"` 且 `radix = 8`，则该方法返回等于八进制数 `333` 的十进制整数。 |

#### 格式化数字输出

之前您已经看到使用 `print` 和 `println` 方法将字符串打印到标准输出（ `System.out` ）。由于所有数字都可以转换为字符串（您将在本课后面看到），因此您可以使用这些方法打印出字符串和数字的任意组合。但是，Java编程语言还有其他方法，可以在包含数字时对打印输出进行更多控制。

**`printf` 和 `Print` 方法**

`java.io` 包中包含一个 `PrintStream` 类，它有两种格式化方法可用于替换 `print` 和 `println`。这些方法，`format` 和 `printf`，彼此相同。您一直使用的熟悉的 `System.out` 恰好是 `PrintStream` 对象，因此您可以在 `System.out` 上调用 `PrintStream` 方法。因此，您可以在您之前使用 `print` 或 `println` 的代码中的任何位置使用 `format` 或 `printf`。例如：

```java
System.out.format(.....);
```

两种 [`java.io.PrintStream`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html) 方法的语法是相同的：

```java
public PrintStream format(String format, Object... args)
```

其中 `format` 是一个字符串，用于指定要使用的格式，`args` 是要使用该格式打印的变量列表。一个简单的例子：

```java
System.out.format("The value of " + "the float variable is " +
     "%f, while the value of the " + "integer variable is %d, " +
     "and the string is %s", floatVar, intVar, stringVar); 
```

第一个参数 `format` 是一个格式字符串，指定如何格式化第二个参数 `args` 中的对象。格式字符串包含纯文本和格式说明符，它们是格式化 `Object ... args`参数的特殊字符。（符号 `Object ... args` 称为 `varargs`，这意味着参数的数量可能会有所不同。）

格式说明符以百分号（％）开头，以*转换器*结束。转换器是一个字符，指示要格式化的参数类型。在百分号（％）和转换器之间，您可以使用可选的标志和说明符。[`java.util.Formatter`](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html) 中记录了许多转换器，标志和说明符.

基本的例子：

```java
int i = 461012;
System.out.format("The value of i is: %d%n", i);
```

`％d` 指定单个变量是十进制整数。`％n` 是与平台无关的换行符。输出是：

```java
The value of i is: 461012
```

`printf` 和 `format` 方法被重载。每个版本都有一个具有以下语法的版本：

```java
public PrintStream format(Locale l, String format, Object... args)
```

例如，要在法语系统中打印数字（使用逗号代替浮点数的英文表示中的小数位），您将使用：

```java
System.out.format(Locale.FRANCE,
    "The value of the float " + "variable is %f, while the " +
    "value of the integer variable " + "is %d, and the string is %s%n", 
    floatVar, intVar, stringVar); 
```

**例子**

下表列出了表格后面的示例程序 `TestFormat.java` 中使用的一些转换器和标志。

| 转换器    | 标识   | 解释                                       |
| ------ | ---- | ---------------------------------------- |
| d      |      | 一个十进制整数。                                 |
| f      |      | 一个浮点数。                                   |
| n      |      | 对应于运行应用程序的平台的新行字符。您应该始终使用 `％n`，而不是 `\n`。 |
| tB     |      | 日期和时间转换 - 特定于语言环境的月份全名。                  |
| td, te |      | 日期和时间转换 - 每月2位数的日期。`td` 根据需要有前导零，`te` 没有。 |
| ty, tY |      | 日期和时间转换- `ty = 2` 位数年份，`tY = 4` 位数年份。    |
| tl     |      | 12小时制的日期和时间转换小时。                         |
| tM     |      | 日期和时间转换 - 以2位数分钟，必要时带前导零。                |
| tp     |      | 日期和时间转换 - 特定于语言环境的上午/下午（小写）。             |
| tm     |      | 日期和时间转换 - 以2位数字表示的月份，必要时带有前导零。           |
| tD     |      | 日期和时间转换-日期为 `％tm％td％ty`                  |
|        | 08   | 宽度为八个字符，必要时带前导零。                         |
|        | +    | 包含符号，正或者负号。                              |
|        | ,    | 包括特定于语言环境的分组字符。                          |
|        | -    | 左对齐..                                    |
|        | .3   | 小数点后三位。                                  |
|        | 10.3 | 宽度为十个字符，右对齐，小数点后三位。                      |

以下程序显示了您可以使用格式进行的一些格式化。输出显示在嵌入注释中的双引号内：

```java
import java.util.Calendar;
import java.util.Locale;

public class TestFormat {
    
    public static void main(String[] args) {
      long n = 461012;
      System.out.format("%d%n", n);      //  -->  "461012"
      System.out.format("%08d%n", n);    //  -->  "00461012"
      System.out.format("%+8d%n", n);    //  -->  " +461012"
      System.out.format("%,8d%n", n);    // -->  " 461,012"
      System.out.format("%+,8d%n%n", n); //  -->  "+461,012"
      
      double pi = Math.PI;

      System.out.format("%f%n", pi);       // -->  "3.141593"
      System.out.format("%.3f%n", pi);     // -->  "3.142"
      System.out.format("%10.3f%n", pi);   // -->  "     3.142"
      System.out.format("%-10.3f%n", pi);  // -->  "3.142"
      System.out.format(Locale.FRANCE,
                        "%-10.4f%n%n", pi); // -->  "3,1416"

      Calendar c = Calendar.getInstance();
      System.out.format("%tB %te, %tY%n", c, c, c); // -->  "May 29, 2006"

      System.out.format("%tl:%tM %tp%n", c, c, c);  // -->  "2:34 am"

      System.out.format("%tD%n", c);    // -->  "05/29/06"
    }
}
```

------

**注意：**本节中的讨论仅涵盖 `format` 和 `printf` 方法的基础知识。更多详细信息可以在 Essential trail 的 [`Basic I/O` ](https://docs.oracle.com/javase/tutorial/essential/io/formatting.html) 部分的“Formatting”页面中找到。

使用String.format创建字符串在 [Strings](https://docs.oracle.com/javase/tutorial/java/data/strings.html) 中介绍。

------

**`DecimalFormat` 类**

您可以使用 [`java.text.DecimalFormat`](https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html)来控制前导和尾随零，前缀和后缀，分组（千分位）分隔符和小数分隔符的显示。`DecimalFormat` 在数字格式化方面提供了极大的灵活性，但它可以使您的代码更复杂。

下面的示例通过将模式字符串传递给 `DecimalFormat` 构造函数来创建 `DecimalFormat` 对象 `myFormatter` 。然后，`myFormatter` 调用 `format()` 方法，`DecimalFormat` 继承自 `NumberFormat`，它接受 `double` 值作为参数，并返回字符串中的格式化数字：

这是一个示例程序，演示了 `DecimalFormat` 的用法：

```java
import java.text.*;

public class DecimalFormatDemo {

   static public void customFormat(String pattern, double value ) {
      DecimalFormat myFormatter = new DecimalFormat(pattern);
      String output = myFormatter.format(value);
      System.out.println(value + "  " + pattern + "  " + output);
   }

   static public void main(String[] args) {

      customFormat("###,###.###", 123456.789);
      customFormat("###.##", 123456.789);
      customFormat("000000.000", 123.78);
      customFormat("$###,###.###", 12345.67);  
   }
}
```

输出：

```shell
123456.789  ###,###.###  123,456.789
123456.789  ###.##  123456.79
123.78  000000.000  000123.780
12345.67  $###,###.###  $12,345.67
```

对输出的解释：

| 值          | 模式           | 输出          | 解释                                       |
| ---------- | ------------ | ----------- | ---------------------------------------- |
| 123456.789 | ###,###.###  | 123,456.789 | 井号（＃）表示一个数字，逗号是分组分隔符的占位符，句点是小数分隔符的占位符。   |
| 123456.789 | ###.##       | 123456.79   | `value` 在小数点右侧有三位数，但 `pattern` 只有两位。`format` 方法通过舍入来处理这个问题。 |
| 123.78     | 000000.000   | 000123.780  | `pattern`指定前导零和尾随零，因为使用0字符而不是井号（＃）。      |
| 12345.67   | $###,###.### | $12,345.67  | `pattern`中的第一个字符是美元符号（$）。 请注意，它紧接在格式化 `output` 中最左边的数字之前。 |

#### 超越基本算数

Java编程语言支持基本算术及其算术运算符：+， - ，*，/和％。`java.lang`包中的`Math`类提供了用于执行更高级数学计算的方法和常量。

`Math` 类中的方法都是`static`的，因此你可以直接从类调用它们，例如：

```java
Math.cos(angle);
```

------

**注意：** 使用 `static import` 语言特性，你不必在每个数学方法前面写上`Math`：

```java
import static java.lang.Math.*;
```

这就允许你使用简单方法名称调用 `Math` 类方法，比如：

````java
cos(angle);
````

------

**常量和基础方法**

`Math` 类包含两个常量：

* `Math.E`，自然对数的底数
* `Math.PI`，圆周率

`Math` 类包含超过 40 个`static`方法。下面列出了大量基础方法。

| 方法                                       | 描述                        |
| ---------------------------------------- | ------------------------- |
| `double abs(double d)`<br />`float abs(float f)`<br />`int abs(int i)`<br />`long abs(long lng)` | 返回参数的绝对值。                 |
| `double ceil(double d)`                  | 返回大于等于参数的最小整数，作为双精度浮点数返回。 |
| `double floor(double d)`                 | 返回小于等于参数的最大整数，作为双精度浮点数返回。 |
| `double rint(double d)`                  | 返回最接近参数值的整数，作为双精度浮点数返回。   |
| `long round(double d)`<br />`int round(float f)` | 返回最接近参数值的长整型数或者整数。        |
| `double min(double arg1, double arg2)`<br />`float min(float arg1, float arg2)`<br />`int min(int arg1, int arg2)`<br />`long min(long arg1, long arg2)` | 返回两个参数中较小的哪个。             |
| `double max(double arg1, double arg2)`<br />`float max(float arg1, float arg2)`<br />`int max(int arg1, int arg2)`<br />`long max(long arg1, long arg2)` | 返回两个参数中较大的那个。             |

下面是个示例程序：

````java
public class BasicMathDemo {
    public static void main(String[] args) {
        double a = -191.635;
        double b = 43.74;
        int c = 16, d = 45;

        System.out.printf("The absolute value " + "of %.3f is %.3f%n", 
                          a, Math.abs(a));

        System.out.printf("The ceiling of " + "%.2f is %.0f%n", 
                          b, Math.ceil(b));

        System.out.printf("The floor of " + "%.2f is %.0f%n", 
                          b, Math.floor(b));

        System.out.printf("The rint of %.2f " + "is %.0f%n", 
                          b, Math.rint(b));

        System.out.printf("The max of %d and " + "%d is %d%n",
                          c, d, Math.max(c, d));

        System.out.printf("The min of of %d " + "and %d is %d%n",
                          c, d, Math.min(c, d));
    }
}
````

输出：

````shell
The absolute value of -191.635 is 191.635
The ceiling of 43.74 is 44
The floor of 43.74 is 43
The rint of 43.74 is 44
The max of 16 and 45 is 45
The min of 16 and 45 is 16
````

**指数和对数方法**

下面列出了`Math`类中的指数和对数方法。

| 方法                                       | 描述                 |
| ---------------------------------------- | ------------------ |
| `double exp(double d)`                   | 返回自然对数的底数，e，参数值次幂。 |
| `double log(double d)`                   | 返回参数的自然对数。         |
| `double pow(double base, double exponent)` | 返回第一个参数的第二个参数值次幂。  |
| `double sqrt(double d)`                  | 返回参数的平方根。          |

下面是实例：

````java
public class ExponentialDemo {
    public static void main(String[] args) {
        double x = 11.635;
        double y = 2.76;

        System.out.printf("The value of " + "e is %.4f%n",
                          Math.E);

        System.out.printf("exp(%.3f) " + "is %.3f%n",
                          x, Math.exp(x));

        System.out.printf("log(%.3f) is " + "%.3f%n",
                          x, Math.log(x));

        System.out.printf("pow(%.3f, %.3f) " + "is %.3f%n",
                          x, y, Math.pow(x, y));

        System.out.printf("sqrt(%.3f) is " + "%.3f%n",
                          x, Math.sqrt(x));
    }
}
````

输出：

````shell
The value of e is 2.7183
exp(11.635) is 112983.831
log(11.635) is 2.454
pow(11.635, 2.760) is 874.008
sqrt(11.635) is 3.411
````

**三角函数方法**

`Math`类同时提供了一系列三角函数方法，如下面表中所示。这些方法的参数是弧度表示的角。你可以通过`toRadians`方法将角度转化为弧度。

| 方法                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `double sin(double d)`                   | 返回给定双精度值的正弦值。                            |
| `double cos(double d)`                   | 返回给定双精度值的余弦值。                            |
| `double tan(double d)`                   | 返回给定双精度值的正切值。                            |
| `double asin(double d)`                  | 返回给定双精度值的正割值。                            |
| `double acos(double d)`                  | 返回给定双精度值的余割值。                            |
| `double atan(double d)`                  | 返回给定双精度值的余切值。                            |
| `double atan2(double y, double x)`       | 将直角坐标 `(x, y)` 转换为极坐标 `(r, theta)` 并返回 `theta`。 |
| `double toDegrees(double d)`<br />`double toRadians(double d)` | 将参数转换为角度或者弧度。                            |

下面是一个实例：

````java
public class TrigonometricDemo {
    public static void main(String[] args) {
        double degrees = 45.0;
        double radians = Math.toRadians(degrees);
        
        System.out.format("The value of pi " + "is %.4f%n",
                           Math.PI);

        System.out.format("The sine of %.1f " + "degrees is %.4f%n",
                          degrees, Math.sin(radians));

        System.out.format("The cosine of %.1f " + "degrees is %.4f%n",
                          degrees, Math.cos(radians));

        System.out.format("The tangent of %.1f " + "degrees is %.4f%n",
                          degrees, Math.tan(radians));

        System.out.format("The arcsine of %.4f " + "is %.4f degrees %n", 
                          Math.sin(radians), 
                          Math.toDegrees(Math.asin(Math.sin(radians))));

        System.out.format("The arccosine of %.4f " + "is %.4f degrees %n", 
                          Math.cos(radians),  
                          Math.toDegrees(Math.acos(Math.cos(radians))));

        System.out.format("The arctangent of %.4f " + "is %.4f degrees %n", 
                          Math.tan(radians), 
                          Math.toDegrees(Math.atan(Math.tan(radians))));
    }
}
````

输出：

````shell
The value of pi is 3.1416
The sine of 45.0 degrees is 0.7071
The cosine of 45.0 degrees is 0.7071
The tangent of 45.0 degrees is 1.0000
The arcsine of 0.7071 is 45.0000 degrees
The arccosine of 0.7071 is 45.0000 degrees
The arctangent of 1.0000 is 45.0000 degrees
````

**随机数**

`random()`方法返回一个从 0.0 到 1.0 之间选择的伪随机数。取值范围包含 0.0 但不包含 1.0 。换句话说，`0.0 <= Math.random() < 1.0`。为了获取其它取值范围的随机数，你可以对该方法返回值进行算数运算。比如，获取 0 到 9 之间的随机数：

````java
int number = (int)(Math.random() * 10);
````

通过将返回值乘以 10，可能的取值范围变成`0.0 <= number < 10.0` 。

使用`Math.random()`方法可以方便地产生单个的随机数。如果你需要产生随机数序列，你应该创建`java.util.Random`实例并调用该对象上的方法来产生随机数序列。

#### Numbers 小结

您可以使用其中一个包装类--`Byte`，`Double`，`Float`，`Integer`，`Long`或`Short`  - 来在对象中包装许多基本类型。Java编译器会在必要时自动为您包装（装箱）基本数据类型，并在必要时再将其解包。

`Number`类包括常量和有用的类方法。`MIN_VALUE`和`MAX_VALUE`常量包含该类型对象可以包含的最小值和最大值。`byteValue`，`shortValue`和类似方法将一种数字类型转换为另一种数字类型。`valueOf`方法将字符串转换为数字，`toString`方法将数字转换为字符串。

要格式化包含输出数字的字符串，可以使用`PrintStream`类中的`printf()`或`format()`方法。或者，您可以使用`NumberFormat`类使用模式自定义数字格式。

`Math`类包含用于执行数学函数的各种类方法，包括指数，对数和三角方法。`Math`还包括基本算术函数，例如绝对值和舍入，以及用于生成随机数的方法`random()`。

### 字符

大多数时候，如果你使用一个单独的字符值，你可以使用基本数据类型`char`。比如：
````java
char ch = 'a'; 
// Unicode for uppercase Greek omega character
char uniChar = '\u03A9';
// an array of chars
char[] charArray = { 'a', 'b', 'c', 'd', 'e' };
````
不过，有些时候，你需要将一个字符作为一个对象使用。比如，作为一个期望一个对象参数的方法的参数。Java提供了一个包装类来将`char`包装为`Character`对象。`Character`类对象包含一个单独的字段，该字段类型为`char`。此字符类还提供一系列有用的方法来操作它。
你可以利用`Character`构造器创建`Character`对象：
````java
Character ch = new Character('a');
````
某些环境下，Java编译器会为你创建`Character`对象。比如，如果你向期望对象参数的方法传递一个`char`类型值，编译器会自动将`char`包装为`Character`。这种特性叫做自动装箱/拆箱。更多有关信息，参考  [自动装箱/拆箱](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html) 。

------

**注意：** `Character`类是不可变的，因此，一旦该类对象被创建出来，就不能修改了。

------

下面的表列出了`Character`类中最有用的一些方法，当然不仅仅是这些方法。完整的方法列表参考 [java.lang.Character](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html) API  规范。

| 方法                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `boolean isLetter(char ch)`<br />`boolean isDigit(char ch)` | 确定给定的字符是否是字母还是数字。                        |
| `boolean isWhitespace(char ch)`          | 确定给定字符是否是空白字符。                           |
| `boolean isUpperCase(char ch)boolean`<br /> `isLowerCase(char ch)` | 确定给定的字符值是否是大写或者小写。                       |
| `char toUpperCase(char ch)`<br />`char toLowerCase(char ch)` | 返回给定字符值得大写或者小写形式。                        |
| `toString(char ch)`                      | 返回一个 `String` 对象表示给定的字符值，也就是返回包含单个字符的字符串。 |

**转义序列**

由反斜杠`\`引导的字符是所谓的转义序列，对编译器有特定含义。下面列出了一些Java中的转义序列：

| 转义序列 | 描述              |
| ---- | --------------- |
| `\t` | 在当前位置插入一个`tab`。 |
| `\b` | 在当前位置插入一个回删。    |
| `\n` | 在当前位置插入一个新行。    |
| `\r` | 在当前位置插入一个回车换行。  |
| `\f` | 在当前位置插入换页符。     |
| `\'` | 在当前位置插入单引号。     |
| `\"` | 在当前位置插入双引号。     |
| `\\` | 在当前位置插入反斜杠字符。   |

当转义序列出现在打印语句中时，编译器会相应解读它们。比如，如果你想要输出包含双引号的字符串，你就必须使用转义序列`\"`, 如下所示：

```
She said "Hello!" to me.
```

你需要这样写：

```java
System.out.println("She said \"Hello!\" to me.");
```

### 字符串

字符串在Java语言中广泛应用，是一个字符序列。在 Java 编程语言中，字符串是对象。

Java 平台提供 `String` 类来创建和操作字符串。

**创建字符串**

最直接的创建字符串：

````java
String greeting = "Hello world!";
````

这个例子中，“Hello world!”是一个字符串字面量—代码中由双引号包围起来的字符序列。无论何时，只要一个字符串字面量出现在代码中，编译器就会根据它的值创建 `String` 对象。这个例子中的 `Hello world!`。

像其它对象一样，你也可以使用`new`关键字和构造器来创建字符串。`String`类拥有13个构造器来允许你提供各种形式的初始值来创建字符串，比如字符数组等：

````java
char[] helloArray = { 'h', 'e', 'l', 'l', 'o', '.' };
String helloString = new String(helloArray);
System.out.println(helloString);
````

最后一行代码输出“hello”。

------

**注意：** `String`类是不可变的，因此`String`对象一旦创建就不能改变了。该类包含大量的方法，接下来会讨论其中一些，看起来会修改字符串。由于字符串是不可变的，这些方法实际上是创建并返回一个新的包含操作结果的字符串。

------

**字符串长度**

用来获取对象信息的方法被称为访问器方法。你可以对字符串使用的一个访问器方法是`length()`，返回字符串对象包含的字符数量。下面两行代码执行之后，`len`等于17：

````java
String palindrome = "Dot saw I was Tod";
int len = palindrome.length();
````

回文指的是对称的单词或者语句。下面是一个遍历回文的方法，它调用`String`的`charAt()`方法，该方法返回字符串中的第 i 个字符。

````java
public class StringDemo {
    public static void main(String[] args) {
        String palindrome = "Dot saw I was Tod";
        int len = palindrome.length();
        char[] tempCharArray = new char[len];
        char[] charArray = new char[len];
        
        // put original string in an 
        // array of chars
        for (int i = 0; i < len; i++) {
            tempCharArray[i] = 
                palindrome.charAt(i);
        } 
        
        // reverse array of chars
        for (int j = 0; j < len; j++) {
            charArray[j] =
                tempCharArray[len - 1 - j];
        }
        
        String reversePalindrome =
            new String(charArray);
        System.out.println(reversePalindrome);
    }
}
````

输出：

````
doT saw I was toD
````

为了实现字符串遍历，该程序将字符串转化为一个字符数组，随后又恢复成为字符串。`String`包含一个方法`getChars()`，可以将一个字符串或者一个字符串的一部分转换为字符数组，因此可以将上面例子中第一个循环修改为：

```
palindrome.getChars(0, len, tempCharArray, 0);
```

**串联字符串**

`String`包含连接两个字符串的方法：

````java
string1.concat(string2); 
````

返回一个新字符串，其中字符串2连接在字符串1后面。

你也可以使用`concat()`方法连接字符串字面量：

````java
"My name is ".concat("Rumplestiltskin");
````

更常见的连接是`+`操作符：

````
"Hello," + " world" + "!"
````

结果是：

```
"Hello, world!"
```

 `+` 操作符被普遍用在 `print` 语句中。比如：

```java
String string1 = "saw I was ";
System.out.println("Dot " + string1 + "Tod");
```

打印：

```
Dot saw I was Tod
```

这种连接可以在任何对象之间进行，如果对象不是字符串，则其`toString()`方法会被调用将其转化为`String`。

------

**注意：** Java 语言不允许源文件中的字符串字面量跨越多行，所以你必须在每行的末尾使用`+`来连接：

````java
String quote = 
    "Now is the time for all good " +
    "men to come to the aid of their country.";
````

这种用法在打印语句中也很常见。

------

**创建格式化字符串**

你已经看到过通过 `printf()` 和 `format()` 方法来格式化输出数字。  `String` 类拥有等价的方法`format()`，返回一个 `String` 对象而不是 `PrintStream` 对象。

使用`String`的静态`format()`方法可以创建一个可以重用的格式化字符串，而不是一次性打印语句。例如：

```java
System.out.printf("The value of the float " +
                  "variable is %f, while " +
                  "the value of the " + 
                  "integer variable is %d, " +
                  "and the string is %s", 
                  floatVar, intVar, stringVar); 
```

可替换为：

```java
String fs;
fs = String.format("The value of the float " +
                   "variable is %f, while " +
                   "the value of the " + 
                   "integer variable is %d, " +
                   " and the string is %s",
                   floatVar, intVar, stringVar);
System.out.println(fs);
```

#### 字符串和数字之间转化

**字符串转化为数字**

通常，程序会以包含在一个字符串对象中的数值结束，比如由用户输入的值。
包装原始数字类型（`Byte`，`Integer`，`Double`，`Float`，`Long`和`Short`）的`Number`子类每个都提供一个名为`valueOf`的类方法，该方法将字符串转换为该类型的对象。下面是一个示例 `ValueOfDemo`，它从命令行获取两个字符串，将它们转换为数字，并对值执行算术运算：
````java
public class ValueOfDemo {
    public static void main(String[] args) {

        // this program requires two 
        // arguments on the command line 
        if (args.length == 2) {
            // convert strings to numbers
            float a = (Float.valueOf(args[0])).floatValue(); 
            float b = (Float.valueOf(args[1])).floatValue();

            // do some arithmetic
            System.out.println("a + b = " +
                               (a + b));
            System.out.println("a - b = " +
                               (a - b));
            System.out.println("a * b = " +
                               (a * b));
            System.out.println("a / b = " +
                               (a / b));
            System.out.println("a % b = " +
                               (a % b));
        } else {
            System.out.println("This program " +
                "requires two command-line arguments.");
        }
    }
}
````

当你使用命令行参数 4.5 和 87.2 时，上述程序会输出：
````shell
a + b = 91.7
a - b = -82.7
a * b = 392.4
a / b = 0.0516055
a % b = 4.5
````
------

注意：包装基本数字类型的每个`Number`子类还提供了一个`parseXXXX()`方法（例如，`parseFloat()`，可用于将字符串转化为基本数字。由于返回基本类型而不是对象，因此`parseFloat()`方法比`valueOf()`方法更直接。例如，在`ValueOfDemo`程序中，我们可以使用：

```java
float a = Float.parseFloat(args[0]);
float b = Float.parseFloat(args[1]);
```

------

**数字转换为字符串**

有时候你需要将数字转化为字符串，因为你需要以这些值的字符串形式操作它们。有几种简单的方法将数字转化为字符串：
````java
int i;
// Concatenate "i" with an empty string; conversion is handled for you.
String s1 = "" + i;
````
或者：
````java
// The valueOf class method.
String s2 = String.valueOf(i);
````
每个`Number`子类都包含一个类方法`toString()`，将基本数据类型转化为字符串。比如：
````java
int i;
double d;
String s3 = Integer.toString(i); 
String s4 = Double.toString(d); 
````
下面的例子使用该方法将数字转换为字符串，然后使用字符串方法计算小数点之前和小数点之后的位数：
````java
public class ToStringDemo {
    
    public static void main(String[] args) {
        double d = 858.48;
        String s = Double.toString(d);
        
        int dot = s.indexOf('.');
        
        System.out.println(dot + " digits " +
            "before decimal point.");
        System.out.println( (s.length() - dot - 1) +
            " digits after decimal point.");
    }
}
````
程序输出：
````
3 digits before decimal point.
2 digits after decimal point.
````
#### 操作字符串中的字符
`String`类包含许多方法用来检查字符串的内容，在字符串内部查找字符或者子串，改变大小写，以及其它操作。
**通过下标获取字符和子串**
你可以获取字符串中处于特定下标位置的字符，通过调用`charAt()`访问器方法。字符串中第一个字符的下标是0，最后一个字符的下标是`length()-1`。比如下面的代码获取字符串中第九个字符：
````java
String anotherPalindrome = "Niagara. O roar again!"; 
char aChar = anotherPalindrome.charAt(9);
````
如下图所示，第九个字符是`O`：

![Use the charAt method to get a character at a particular index.](https://docs.oracle.com/javase/tutorial/figures/java/objects-charAt.gif)

如果你希望从字符串中获取连续的多个字符，你可以使用`substring`方法。该方法有两个版本，如下面表中所示：

| 方法                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `String substring(int beginIndex, int endIndex)` | 返回一个新字符串，该字符串是此字符串的子字符串。子字符串从指定的`beginIndex`开始，并扩展到索引`endIndex - 1`处的字符。 |
| `String substring(int beginIndex)`       | 返回一个新字符串，该字符串是此字符串的子字符串。 `beginIndex`参数指定第一个字符的索引。 这里，返回的子字符串延伸到原始字符串的末尾。 |

以下代码从Niagara 回文获取从索引11延伸到索引15的子字符串，但不包括索引15，即“roar”一词：

````java
String anotherPalindrome = "Niagara. O roar again!"; 
String roar = anotherPalindrome.substring(11, 15);
````

![Use the substring method to get part of a string.](https://docs.oracle.com/javase/tutorial/figures/java/objects-substring.gif)

**操作字符串的其它方法**

下面是`String`类中其它操作字符串的一些方法：

| 方法                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `String[] split(String regex)`<br />`String[] split(String regex, int limit)` | 搜索由字符串参数（包含正则表达式）指定的匹配，并相应地将此字符串拆分为字符串数组。 可选的整数参数指定返回数组的最大大小。正则表达式在标题为“正则表达式”的课程中介绍。 |
| `CharSequence subSequence(int beginIndex, int endIndex) | 返回从`beginIndex`索引构造的新字符序列，直到`endIndex - 1`。 |
| `String trim()`                          | 返回此字符串的副本，其中删除了前导和尾随空格。                  |
| `String toLowerCase()`<br />`String toUpperCase()` | 返回转换为小写或大写的此字符串的副本。如果不需要转换，则这些方法返回原始字符串。 |

**字符串中搜索字符和子串**

以下是一些其他`String`方法，用于查找字符串中的字符或子字符串。`String`类提供了访问器方法，这些方法返回特定字符或子字符串的字符串中的位置：`indexOf()`和`lastIndexOf()`。`indexOf()`方法从字符串的开头向前搜索，而`lastIndexOf()`方法从字符串的末尾向后搜索。如果未找到字符或子字符串，`indexOf()`和`lastIndexOf()`将返回 -1。

`String`类还提供了一个搜索方法`contains`，如果字符串包含特定的字符序列，则返回`true`。当您只需要知道字符串包含字符序列时，请使用此方法，但精确位置并不重要。

下表描述了各种字符串搜索方法。

| 方法                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `int indexOf(int ch)`<br />`int lastIndexOf(int ch)` | 返回指定字符的第一个（最后一次）出现的下标位置。                 |
| `int indexOf(int ch, int fromIndex)`<br />`int lastIndexOf(int ch, int fromIndex)` | 返回指定字符的第一个（最后一次）出现的下标位置，从指定的下标位置向前（向后）搜索。 |
| `int indexOf(String str)`<br />`int lastIndexOf(String str)` | 返回指定子字符串的第一个（最后一次）出现的下标位置。               |
| `int indexOf(String str, int fromIndex)`<br />`int lastIndexOf(String str, int fromIndex)` | 返回指定子字符串的第一个（最后一次）出现的下标位置，从指定的下标位置向前（向后）搜索。 |
| `boolean contains(CharSequence s)`       | 如果字符串包含指定的字符序列，则返回`true`。                |

------

**Note:** `CharSequence` 是`String` 类实现的一个接口。因此，你可以将字符串作为 `contains()` 方法的参数。

------

**替换字符串中的字符或者子串**

`String`类只有很少的方法可以将字符或子字符串插入到字符串中。通常，不需要它们：您可以通过连接从字符串中删除特定子字符串之后剩余的子字符串、或者要插入的子字符串来创建新字符串。

但是，`String`类确实有四种方法可以替换找到的字符或子字符串。 它们是：

| Method                                   | Description                              |
| ---------------------------------------- | ---------------------------------------- |
| `String replace(char oldChar, char newChar)` | 返回一个新字符串，该字符串是使用`newChar`替换此字符串中所有出现的`oldChar`。 |
| `String replace(CharSequence target, CharSequence replacement)` | 将与该文字目标序列匹配的此字符串的每个子字符串替换为指定的文字替换序列。     |
| `String replaceAll(String regex, String replacement)` | 将给定替换的给定正则表达式匹配的此字符串的每个子字符串替换。           |
| `String replaceFirst(String regex, String replacement)` | 将给定替换的给定正则表达式匹配的此字符串的第一个子字符串替换。          |

**例子**

```java
public class Filename {
    private String fullPath;
    private char pathSeparator, 
                 extensionSeparator;

    public Filename(String str, char sep, char ext) {
        fullPath = str;
        pathSeparator = sep;
        extensionSeparator = ext;
    }

    public String extension() {
        int dot = fullPath.lastIndexOf(extensionSeparator);
        return fullPath.substring(dot + 1);
    }

    // gets filename without extension
    public String filename() {
        int dot = fullPath.lastIndexOf(extensionSeparator);
        int sep = fullPath.lastIndexOf(pathSeparator);
        return fullPath.substring(sep + 1, dot);
    }

    public String path() {
        int sep = fullPath.lastIndexOf(pathSeparator);
        return fullPath.substring(0, sep);
    }
}
```

下面的程序使用了上面的类：

```java
public class FilenameDemo {
    public static void main(String[] args) {
        final String FPATH = "/home/user/index.html";
        Filename myHomePage = new Filename(FPATH, '/', '.');
        System.out.println("Extension = " + myHomePage.extension());
        System.out.println("Filename = " + myHomePage.filename());
        System.out.println("Path = " + myHomePage.path());
    }
}
```

程序输出：

```shell
Extension = html
Filename = index
Path = /home/user
```

如下图所示，我们的`extension`方法使用`lastIndexOf`来定位文件名中最后一次出现的句点。然后`substring`使用`lastIndexOf`的返回值来提取文件扩展名 - 即从句点到字符串结尾的子字符串。此代码假定文件名中包含句点；如果文件名没有句点，则`lastIndexOf`返回 -1，`substring`方法抛出`StringIndexOutOfBoundsException`。

![The use of lastIndexOf and substring in the extension method in the Filename class.](https://docs.oracle.com/javase/tutorial/figures/java/objects-lastIndexOf.gif)

另请注意，`extension`方法使用`dot + 1`作为`substring`的参数。如果句点字符是字符串的最后一个字符，则`dot + 1`等于字符串的长度，该字符串大于字符串中的最大索引（因为索引从0开始）。这是`substring`的合法参数，因为该方法接受的索引等于但不大于字符串的长度，并将其解释为“字符串的结尾”。

#### 比较字符串和部分字符串

`String` 类包含大量方法用来比较字符串或者部分字符串。下面列出了这些方法：

| Method                                   | Description                              |
| ---------------------------------------- | ---------------------------------------- |
| `boolean endsWith(String suffix)`<br />`boolean startsWith(String prefix)` | 返回 `true` 如果字符串以参数给出的字符串结尾或者开头。          |
| `boolean startsWith(String prefix, int offset)` | 考察从索引偏移量`offset`开始的字符串，如果它以指定为参数的子字符串开头，则返回`true`。 |
| `int compareTo(String anotherString)`    | 按字典顺序比较两个字符串。返回一个整数，指示此字符串是大于（结果是> 0），等于（结果是= 0）还是小于（结果是<0）参数。 |
| `int compareToIgnoreCase(String str)`    | 按字典顺序比较两个字符串，忽略大小写的差异。返回一个整数，指示此字符串是大于（结果是> 0），等于（结果是= 0）还是小于（结果是<0）参数。 |
| `boolean equals(Object anObject)`        | 当且仅当参数是`String`对象时才返回`true`，该`String`对象表示与此对象相同的字符序列。 |
| `boolean equalsIgnoreCase(String anotherString)` | 当且仅当参数是`String`对象时才返回`true`，该对象表示与此对象相同的字符序列，忽略大小写的差异。 |
| `boolean regionMatches(int toffset, String other, int ooffset, int len)` | 测试此字符串的指定区域是否与`String`参数的指定区域匹配。`Region`的长度为`len`，从此字符串的索引`toffset`开始，另一个字符串的`ooffset`开始。 |
| `boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)` | 测试此字符串的指定区域是否与`String`参数的指定区域匹配。`Region`的长度为`len`，从此字符串的索引`toffset`开始，另一个字符串的`ooffset`开始。`boolean`参数指示是否应忽略大小写；如果为`true`，则在比较字符时忽略大小写。 |
| `boolean matches(String regex)`          | 测试此字符串是否与指定的正则表达式匹配。正则表达式在标题为“正则表达式”的课程中讨论。 |

下面的程序，`RegionMatchesDemo`，使用 `regionMatches` 方法在一个字符串中搜索另一个字符串：

```java
public class RegionMatchesDemo {
    public static void main(String[] args) {
        String searchMe = "Green Eggs and Ham";
        String findMe = "Eggs";
        int searchMeLength = searchMe.length();
        int findMeLength = findMe.length();
        boolean foundIt = false;
        for (int i = 0; 
             i <= (searchMeLength - findMeLength);
             i++) {
           if (searchMe.regionMatches(i, findMe, 0, findMeLength)) {
              foundIt = true;
              System.out.println(searchMe.substring(i, i + findMeLength));
              break;
           }
        }
        if (!foundIt)
            System.out.println("No match found.");
    }
}
```

这个程序的输出是`Eggs`。

程序逐步遍历`searchMe`引用的字符串。对于每个字符，程序调用`regionMatches`方法来确定以当前字符开头的子字符串是否与程序正在查找的字符串匹配。

#### `StringBuilder` 类

`StringBuilder`对象与`String`对象类似，只是它们可以被修改。在内部，这些对象被视为包含一系列字符的可变长度数组。在任何时候，可以通过方法调用来改变序列的长度和内容。

除非`StringBuilder`在更简单的代码（参见本节末尾的示例程序）或更好的性能方面具有优势的场景，否则应始终使用字符串。例如，如果需要连接大量字符串，则附加到`StringBuilder`对象会更有效率。

**长度和容量**

与`String`类一样，`StringBuilder`类有一个`length()`方法，该方法返回构建器中字符序列的长度。

与字符串不同，每个字符串构建器也具有容量，即已分配的字符空间数。 `capacity()`方法返回的容量始终大于或等于长度（通常大于），并将根据需要自动扩展以适应字符串构建器的添加。

| 构造器                               | 描述                                       |
| --------------------------------- | ---------------------------------------- |
| `StringBuilder()`                 | 创建容量为16的空字符串构建器。(包含16个空元素)               |
| `StringBuilder(CharSequence cs)`  | 构建一个字符串构建器包含参数 `CharSequence`给出的字符，同时还在后面跟着16个空元素。 |
| `StringBuilder(int initCapacity)` | 创建一个具有特定初始容量的空字符串构建器。                    |
| `StringBuilder(String s)`         | 创建一个字符串构建器，它包含参数给出的特定字符串，同时在后面跟随16个空元素。  |

例如，下面的代码：

```java
// creates empty builder, capacity 16
StringBuilder sb = new StringBuilder();
// adds 9 character string at beginning
sb.append("Greetings");
```

将产生容量 16 长度 9 的字符串构建器：

![A string builder's length is the number of characters it contains; a string builder's capacity is the number of character spaces that have been allocated.](https://docs.oracle.com/javase/tutorial/figures/java/objects-stringBuffer.gif)

`StringBuilder`类拥有若干方法关于长度和容量，`String`类没有这些方法。

| 方法                                     | 描述                                       |
| -------------------------------------- | ---------------------------------------- |
| `void setLength(int newLength)`        | 设置字符序列的长度，如果 `newLength` 小于 `length()`，则字符序列的尾部字符将会被截断。如果 `newLength` 大于 `length()`， `null`字符就会被添加到字符序列之后。 |
| `void ensureCapacity(int minCapacity)` | 确保容量至少等于给定的最小值。                          |

很多操作 (比如 `append()`, `insert()`, 或者 `setLength()`) 能够增加字符串构建器中字符序列的长度，而结果 `length()` 可能会超过目前的 `capacity()`。当这种情况发生时，容量将会自动扩展。

**`StringBuilder` 操作**

`String`中不可用的`StringBuilder`上的主要操作是`append()`和`insert()`方法，它们被重载以接受任何类型的数据。每个都将其参数转换为字符串，然后将该字符串的字符追加或插入字符串生成器中的字符序列。`append`方法总是在现有字符序列的末尾添加这些字符，而`insert`方法在指定位置添加字符。

以下是`StringBuilder`类的一些方法。

| 方法                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `StringBuilder append(boolean b)`<br />`StringBuilder append(char c)`<br />`StringBuilder append(char[] str)`<br />`StringBuilder append(char[] str, int offset, int len)`<br />`StringBuilder append(double d)`<br />`StringBuilder append(float f)`<br />`StringBuilder append(int i)`<br />`StringBuilder append(long lng)`<br />`StringBuilder append(Object obj)`<br />`StringBuilder append(String s)` | 将参数追加到此字符串构建器。在附加操作发生之前，数据将转换为字符串。       |
| `StringBuilder delete(int start, int end)`<br />`StringBuilder deleteCharAt(int index)` | 第一种方法在`StringBuilder`的字符序列中删除从`start`到`end-1`（包括）的子序列。第二种方法删除位于`index`的字符。 |
| `StringBuilder insert(int offset, boolean b)`<br />`StringBuilder insert(int offset, char c)`<br />`StringBuilder insert(int offset, char[] str)`<br />`StringBuilder insert(int index, char[] str, int offset, int len)`<br />`StringBuilder insert(int offset, double d)`<br />`StringBuilder insert(int offset, float f)`<br />`StringBuilder insert(int offset, int i)`<br />`StringBuilder insert(int offset, long lng)`<br />`StringBuilder insert(int offset, Object obj)`<br />`StringBuilder insert(int offset, String s)` | 将第二个参数插入到字符串构建器中。第一个整数参数表示要在其中插入数据的索引。在插入操作发生之前，数据将转换为字符串。 |
| `StringBuilder replace(int start, int end, String s)`<br />`void setCharAt(int index, char c)` | 替换此字符串生成器中的指定字符。                         |
| `StringBuilder reverse()`                | 反转此字符串构建器中的字符序列。                         |
| `String toString()`                      | 返回包含构建器中的字符序列的字符串。                       |

------

**注意：**您可以在`StringBuilder`对象上使用任何`String`方法，方法是首先使用`StringBuilder`类的`toString()`方法将字符串构建器转换为字符串。然后使用`StringBuilder(String str)`构造函数将字符串转换回字符串构建器。

------

**例子**

标题为“字符串”一节中列出的`StringDemo`程序是一个程序的示例，如果使用`StringBuilder`而不是`String`则该程序会更有效率。

`StringDemo`反转了回文。在这里，它再次出现：

```java
public class StringDemo {
    public static void main(String[] args) {
        String palindrome = "Dot saw I was Tod";
        int len = palindrome.length();
        char[] tempCharArray = new char[len];
        char[] charArray = new char[len];
        
        // put original string in an 
        // array of chars
        for (int i = 0; i < len; i++) {
            tempCharArray[i] = 
                palindrome.charAt(i);
        } 
        
        // reverse array of chars
        for (int j = 0; j < len; j++) {
            charArray[j] =
                tempCharArray[len - 1 - j];
        }
        
        String reversePalindrome =
            new String(charArray);
        System.out.println(reversePalindrome);
    }
}
```

程序输出：

```shell
doT saw I was toD
```

为了完成字符串反转，程序将字符串转换为字符数组（第一个`for`循环），将数组反转为第二个数组（第二个`for`循环），然后转换回字符串。

如果将`palindrome`字符串转换为字符串构建器，则可以在`StringBuilder`类中使用`reverse()`方法。它使代码更简单，更易于阅读：

```java
public class StringBuilderDemo {
    public static void main(String[] args) {
        String palindrome = "Dot saw I was Tod";
         
        StringBuilder sb = new StringBuilder(palindrome);
        
        sb.reverse();  // reverse it
        
        System.out.println(sb);
    }
}
```

程序输出：

```shell
doT saw I was toD
```

请注意，`println()`打印字符串构建器，如下所示：

```java
System.out.println(sb);
```

`sb.toString()`是隐式调用的，因为它与`println()`调用中的任何其他对象一样。

------

**注意：**还有一个与`StringBuilder`类完全相同的`StringBuffer`类，除了它的方法是同步的，它是线程安全的。线程将在关于并发的课程中讨论。

------

#### 字符和字符串小结

大多数情况下，如果使用单个字符值，则将使用原始`char`类型。但是，有时候需要使用`char`作为对象 - 例如，作为期望对象的方法参数。Java编程语言提供了一个*wrapper*类，为了这个目的，它将`char`包装在`Character`对象中。 `Character`类型的对象包含一个类型为`char`的字段。 这个[`Character`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html) 类还提供了许多用于操作字符的有用类（即静态）方法。

字符串是一系列字符，广泛用于Java编程。在Java编程语言中，字符串是对象。 [`String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) 类有60多个方法和13个构造函数。

最常见的是，您如下创建一个字符串：

```shell
String s = "Hello world!";
```

而不是使用其中一个`String`构造函数。

`String`类有很多方法可以查找和检索子字符串；然后可以使用`+`连接运算符将它们轻松地重新组合成新的字符串。

`String`类还包括许多实用方法，其中包括`split()`，`toLowerCase()`，`toUpperCase()`和`valueOf()`。后一种方法在将用户输入字符串转换为数字时是必不可少的。`Number`子类还具有将字符串转换为数字的方法，反之亦然。

除了`String`类之外，还有一个[`StringBuilder`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html) 类。使用`StringBuilder`对象有时比使用字符串更有效。`StringBuilder`类提供了一些对字符串有用的方法，其中包括`reverse()`。但是，一般来说，`String`类有更多种方法。

可以使用`StringBuilder`构造函数将字符串转换为字符串构建器。可以使用`toString()`方法将字符串构建器转换为字符串。

### 自动装箱和拆箱

*自动装箱*是一种Java编译器自动执行的在基本数据类型和它们对应的对象包装类之间的转换机制。比如，将`int` 转换为`Integer`，`double`转换为`Double`，等等。如果这种转换反向进行，则被称为*自动拆箱*。

下面是一个自动装箱的最简单的例子：

```java
Character ch = 'a';
```

本章节中其它例子中用到了泛型。如果你对泛型语法还不熟悉，参考 [Generics (Updated)](https://docs.oracle.com/javase/tutorial/java/generics/index.html) 部分。

考虑下面的代码：

```java
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
    li.add(i);
```

虽然您将`int`值作为基本类型而不是`Integer`对象添加到`li`，但代码会通过编译。因为`li`是`Integer`对象的列表，而不是`int`值列表，所以您可能想知道为什么Java编译器不会发出编译时错误。编译器不会生成错误，因为它从`i`创建一个`Integer`对象并将对象添加到`li`。因此，编译器在运行时将以前的代码转换为以下代码：

```java
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
    li.add(Integer.valueOf(i));
```

将原始值（例如`int`）转换为相应包装类（`Integer`）的对象称为`autoboxing`。 当基本数据类型值为如下情况时，Java编译器应用自动装箱：

- 被作为参数传递给期望它对应的包装类型的方法时。
- 被赋值给对应的包装类型的变量时。

考虑下面的方法：

```java
public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i: li)
        if (i % 2 == 0)
            sum += i;
        return sum;
}
```

由于求余数(`%`) 和一元加 (`+=`) 操作符不能应用于 `Integer` 对象，你可能会好奇为啥Java编译器在编译该方法时并没有抛出异常。因为它在运行时调用了 `intValue` 方法将 `Integer` 转换成了 `int` ：

```java
public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i : li)
        if (i.intValue() % 2 == 0)
            sum += i.intValue();
        return sum;
}
```

将包装类型（`Integer`）的对象转换为其对应的原始（`int`）值称为自动拆箱。当包装类的对象是下列情况时，Java编译器应用拆箱：

- 作为参数传递给期望相应基本数据类型值的方法。
- 赋值给相应基本数据类型的变量。

`Unboxing`示例显示了其工作原理：

```java
import java.util.ArrayList;
import java.util.List;

public class Unboxing {

    public static void main(String[] args) {
        Integer i = new Integer(-8);

        // 1. Unboxing through method invocation
        int absVal = absoluteValue(i);
        System.out.println("absolute value of " + i + " = " + absVal);

        List<Double> ld = new ArrayList<>();
        ld.add(3.1416);    // Π is autoboxed through method invocation.

        // 2. Unboxing through assignment
        double pi = ld.get(0);
        System.out.println("pi = " + pi);
    }

    public static int absoluteValue(int i) {
        return (i < 0) ? -i : i;
    }
}
```

程序输出：

```shell
absolute value of -8 = 8
pi = 3.1416
```

自动装箱和拆箱使开发人员可以编写更清晰的代码，使其更易于阅读。下表列出了原始类型及其相应的包装类，Java编译器使用这些类进行自动装箱和拆箱：

| 基本数据类型  | 包装类型      |
| ------- | --------- |
| boolean | Boolean   |
| byte    | Byte      |
| char    | Character |
| float   | Float     |
| int     | Integer   |
| long    | Long      |
| short   | Short     |
| double  | Double    |

## 泛型

在任何重要的软件项目中，错误总是如影随形。仔细的规划，编程和测试可以帮助减少它们的可能性，但不知何故，它们总会找到一种方法来混进你的代码。随着新功能的引入以及您的代码库在规模和复杂性方面的增长，这一点变得尤为明显。

幸运的是，一些错误比其他错误更容易被发现。例如，编译时错误可以在早期检测到；您可以使用编译器的错误消息来确定问题所在并立即修复它。但是，运行时错误可能会更成问题；它们并不总是立即浮出水面，当它们发生时，可能是在程序中远离问题的实际原因的位置。

泛型通过在编译时检测到更多错误来增加代码的稳定性。完成本课程后，您可能需要跟进 Gilad Bracha 的 [Generics](https://docs.oracle.com/javase/tutorial/extra/generics/index.html) 教程。

### 为什么使用泛型

简而言之，泛型使*类型*（类和接口）在定义类，接口和方法时成为参数。与方法声明中使用的更熟悉的*形式参数*非常类似，类型参数提供了一种方法，您可以使用不同的输入重用相同的代码。不同之处在于形式参数的输入是值，而类型参数的输入是类型。

使用泛型的代码比非泛型代码有许多好处：

- 在编译时进行更强大的类型检查。
  Java编译器将强类型检查应用于通用代码，并在代码违反类型安全性时发出错误。修复编译时错误比修复运行时错误更容易，因为运行时错误很难发现。
- 消除转型。

下面的代码片段没有使用泛型，因而需要转型：

```java
List list = new ArrayList();
list.add("hello");
String s = (String) list.get(0);
```

使用泛型重写，不再需要转型：

```java
List<String> list = new ArrayList<String>();
list.add("hello");
String s = list.get(0);   // no cast
```

- 使程序员能够实现通用算法。
  通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。

### 泛型类型

*泛型类型*是一个泛型类或者接口，进行了类型参数化。下面的`Box`类将被改写来说明这个概念。

**简单版本的`Box`类**

检查一个非泛型的`Box`类，操作任意类型的对象。它只需要两个方法：`set`方法来添加对象到盒子里，`get`方法从盒子里拿到对象。

```java
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
```

由于它的方法接受或返回一个`Object`，只要它不是基本数据类型之一，你就可以自由地传入任何你想要传入的东西。在编译时无法验证类的使用方式。代码的一部分可能会在框中放置一个`Integer`，并期望从中获取`Integer`，而代码的另一部分可能会错误地传入`String`，从而导致运行时错误。

**`Box`类的泛型版本**

泛型类以下面的形式定义：

```java
class name<T1, T2, ..., Tn> { /* ... */ }
```

类型餐多户部分，由尖括号 `<>` 分隔，跟随着类名。它给出了*类型参数*，也被称为*类型变量* `T1`, `T2`, ..., 以及 `Tn`。

要更新`Box`类以使用泛型，可以通过将代码“`public class Box`”更改为“`public class Box <T>`”来创建*泛型类型声明*。这引入了类型变量`T`，可以在类中的任何地方使用。

通过此更改，`Box`类变为：

```java
/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

如您所见，所有出现的`Object`都被`T`取代。类型变量可以是您指定的任何**非原始**类型：任何类类型，任何接口类型，任何数组类型，甚至是其他类型变量。

可以应用相同的技术来创建通用接口。

**类型参数命名约定**

按照约定，类型参数名称应该是单个的大写字母。这一点与你所知道的变量的命名完全不同，不过理由很充分：如果不这么约定，就很难区分类型变量和原始的类或者接口名称。

最常用的类型参数名称有：

- E - Element（在 Java 集合框架中广泛应用）
- K - Key
- N - Number
- T - Type
- V - Value
- S, U, V etc - 第二、第三、第四类型

你将看到这些名称贯穿整个 Java SE API 和本文的剩余章节。

**调用及实例化泛型类型**

为了引用你的代码中的泛型`Box`类，你必须执行一个*泛型类型调用*，该调用将使用某种具体类型替换 `T` ，比如 `Integer`：

```java
Box<Integer> integerBox;
```

您可以将泛型类型调用视为与普通方法调用类似，但不是将参数传递给方法，而是将*类型参数*  - `Integer`在这种情况下传递给`Box`类本身。

------

`Type Parameter`和`Type Argument`术语：

  许多开发人员可以互换地使用术语`Type Parameter`和`Type Argument`，但这些术语并不相同。编码时，提供`Type Parameter`以创建参数化类型。 因此，`Foo <T>`中的`T`是一个`Type Parameter`，而`Foo <String> f`中的`String`是一个类`Type Argument`。本课程在使用这些术语时会遵循此定义。

------

与任何其他变量声明一样，此代码实际上并不创建新的`Box`对象。它只是声明`integerBox`将保存对`Integer`的`Box`的引用，这就是`Box <Integer>`的含义。

泛型类型的调用通常称为*参数化类型*。

要实例化这个类，像往常一样使用`new`关键字，但在类名和括号之间放置`<Integer>`：

```java
Box<Integer> integerBox = new Box<Integer>();
```

**菱形表示法**

在Java SE 7及更高版本中，只要编译器可以从上下文中确定或推断类型参数，就可以用一组空的类型参数（<>）替换调用泛型类的构造函数所需的类型参数。这对尖括号`<>`非正式地称为*菱形表示法*。例如，您可以使用以下语句创建`Box <Integer>`的实例：

```java
Box<Integer> integerBox = new Box<>();
```

有关菱形表示法和类型推断的更多信息，请参阅 [Type Inference](https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html) 。

**多个类型参数**

如前所述，一个泛型 类型可以拥有多个类型参数，如下面例子：

```java
public interface Pair<K, V> {
    public K getKey();
    public V getValue();
}

public class OrderedPair<K, V> implements Pair<K, V> {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
	this.key = key;
	this.value = value;
    }

    public K getKey()	{ return key; }
    public V getValue() { return value; }
}
```

下面的两条语句创建两个`OrderedPair`类对象实例：

```java
Pair<String, Integer> p1 = new OrderedPair<String, Integer>("Even", 8);
Pair<String, String>  p2 = new OrderedPair<String, String>("hello", "world");
```

代码 `new OrderedPair<String, Integer>`，实例化 `K` 作为一个 `String` 对象， `V` 作为一个 `Integer`对象。因此， `OrderedPair`的构造器的参数类型就是 `String` 和 `Integer`。由于 [自动装箱](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html) 机制，传递 `String` 和 `int` 给该类也是合法的。

如 [菱形表示法](https://docs.oracle.com/javase/tutorial/java/generics/types.html#diamond) 中所述，由于 Java 编译器能够从 `OrderedPair<String, Integer>` 声明推断出 `K` 和 `V` 的类型，使用菱形表示法将上述语句简化为：

```java
OrderedPair<String, Integer> p1 = new OrderedPair<>("Even", 8);
OrderedPair<String, String>  p2 = new OrderedPair<>("hello", "world");
```

创建泛型接口的约定和创建泛型类的约定一样。

**参数化类型**

您还可以用参数化类型（即`List <String>`）替换类型参数（即`K`或`V`）。例如，使用`OrderedPair <K，V>`示例：

```java
OrderedPair<String, Box<Integer>> p = new OrderedPair<>("primes", new Box<Integer>(...));
```

#### 原始类型

*原始类型*是没有任何类型参数的泛型类或者泛型接口。比如，给定泛型 `Box` 类：

```java
public class Box<T> {
    public void set(T t) { /* ... */ }
    // ...
}
```

为了创建一个参数化类型 `Box<T>`，你给出一个实际的类型参数来取代先前的类型参数 `T`：

```java
Box<Integer> intBox = new Box<>();
```

如果实际类型参数被忽略，你就会创建一个原始类型 `Box<T>`：

```java
Box rawBox = new Box();
```

也就是说， `Box` 是泛型类型 `Box<T>`的原始类型。不过，一个非泛型类或者接口类型不是原始类型。

原始类型出现在遗留代码中，因为大量 API 类，比如`Collections`类，编写的年代还没有引入泛型。当使用原始类型时，你实际上得到的是泛型出现之前的行为 - 一个`Box`会返回给你一个`Object`。为了保持向后兼容性，将一个参数化类型赋值给它的原始类型是允许的：

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;               // OK
```

但是，如果你赋值一个原始类型给一个参数化类型，你将得到一个警告：

```java
Box rawBox = new Box();           // rawBox is a raw type of Box<T>
Box<Integer> intBox = rawBox;     // warning: unchecked conversion
```

当你使用一个原始类型来调用对应的泛型类型定义的泛型方法是，你也会得到一个警告：

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
```

警告表明该原始类型绕过了泛型类型检查，将不安全代码捕获推迟到了运行时。因此，你应该避免使用原始类型。

[类型擦除](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html) 章节包含更多有关 Java 编译器使用原始类型的信息。

**不受检查的错误信息**

如前所述，当混合使用遗留代码和泛型代码时，你可能会遇到类似下面的警告消息：

```shell
Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
```

这些可能发生在使用老的使用原始类型的 API 时，如下面例子所示：

```java
public class WarningDemo {
    public static void main(String[] args){
        Box<Integer> bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
```

术语“unchecked”表示编译器没有足够的类型信息来执行确保类型安全所必需的所有类型检查。默认情下，“unchecked”警告被禁用，尽管编译器提供了提示。要查看所有“unchecked”警告，请使用`-Xlint：unchecked`重新编译。

使用`-Xlint：unchecked`重新编译前一个示例会显示以下附加信息：

```shell
WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box<java.lang.Integer>
        bi = createBox();
                      ^
1 warning
```

要完全禁用未检查的警告，请使用`-Xlint：-unchecked`标志。`@SuppressWarnings`（“unchecked”）注解会抑制未经检查的警告。如果您不熟悉`@SuppressWarnings`语法，请参阅 [注解](https://docs.oracle.com/javase/tutorial/java/annotations/index.html) 。

### 泛型方法

*泛型方法*是引入它们自己的类型参数的方法。这类似于声明泛型类型，但类型参数的范围仅限于声明它的方法。允许使用静态和非静态泛型方法，以及泛型类构造函数。

泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。

`Util`类包含一个泛型方法`compare`，它比较两个`Pair`对象：

```java
public class Util {
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair<K, V> {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
```

调用该方法的完整语法：

```java
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.<Integer, String>compare(p1, p2);
```

代码中已明确提供类型，如粗体所示。通常，这可以省略，编译器将推断所需的类型：

```java
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.compare(p1, p2);
```

此功能称为*类型推断*，允许您将泛型方法作为普通方法调用，而无需在尖括号之间指定类型。本主题将在下一节 [类型推断](https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html) 中进一步讨论。

### 有界的类型参数

有时您可能希望限制可用作参数化类型中的类型参数的类型。例如，对数字进行操作的方法可能只想接受`Number`或其子类的实例。这是*有界类型参数*的用途。

要声明有界类型参数，请列出类型参数的名称，后跟`extends`关键字，后跟*上限*，在此示例中为`Number`。注意，在这种情况下，`extends`在一般意义上用于表示“扩展”（如在类中）或“实现”（如在接口中）。

```java
public class Box<T> {

    private T t;          

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public <U extends Number> void inspect(U u){
        System.out.println("T: " + t.getClass().getName());
        System.out.println("U: " + u.getClass().getName());
    }

    public static void main(String[] args) {
        Box<Integer> integerBox = new Box<Integer>();
        integerBox.set(new Integer(10));
        integerBox.inspect("some text"); // error: this is still String!
    }
}
```

通过修改我们的泛型方法来包含这个有界类型参数，编译现在将失败，因为我们调用`inspect`仍然包含一个`String`：

```shell
Box.java:21: <U>inspect(U) in Box<java.lang.Integer> cannot
  be applied to (java.lang.String)
                        integerBox.inspect("10");
                                  ^
1 error
```

除了限制可用于实例化泛型类型的类型之外，有界类型参数还允许您调用边界中定义的方法：

```java
public class NaturalNumber<T extends Integer> {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return n.intValue() % 2 == 0;
    }

    // ...
}
```

`isEven`方法通过`n`调用`Integer`类中定义的`intValue`方法。

**多个边界**

前面的示例说明了使用带有单个边界的类型参数，但是类型参数可以具有*多个边界*：

```java
<T extends B1 & B2 & B3>
```

具有多个边界的类型变量是边界中列出的所有类型的子类型。如果其中一个边界是类，则必须首先指定它。 例如：

```java
Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D <T extends A & B & C> { /* ... */ }
```

如果未首先指定边界中的`A`，则会出现编译时错误：

```java
class D <T extends B & A & C> { /* ... */ }  // compile-time error
```

#### 泛型方法和有界类型参数

有界类型参数是泛型算法实现的关键。考虑以下方法来计算数组`T[]`中大于指定元素`elem`的元素数。

```java
public static <T> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e > elem)  // compiler error
            ++count;
    return count;
}
```

该方法的实现很简单，但它不能编译，因为大于运算符（`>`）仅适用于基本数据类型，如`short`，`int`，`double`，`long`，`float`， `byte`和`char`。你不能使用`>`运算符来比较对象。要解决此问题，请使用由`Comparable <T>`接口限定的类型参数：

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

代码的结果将是：

```java
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) > 0)
            ++count;
    return count;
}
```

### 泛型，继承和子类型

如您所知，只要类型兼容，就可以将一种类型的对象分配给另一种类型的对象。例如，您可以将`Integer`对象分配给`Object`，因为`Object`是`Integer`的超类型之一：

```java
Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;   // OK
```

在面向对象的术语中，这被称为“is a”关系。由于`Integer` *是*一种`Object`，因此允许赋值。但是`Integer`也是一种`Number`，所以下面的代码也是有效的：

```java
public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // OK
someMethod(new Double(10.1));   // OK
```

泛型也是如此。您可以执行泛型类型调用，将`Number`作为其类型参数传递，如果参数与`Number`兼容，则允许任何后续的`add`调用：

```java
Box<Number> box = new Box<Number>();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
```

现在考虑下面的方法：

```java
public void boxTest(Box<Number> n) { /* ... */ }
```

它接受什么类型的参数？ 通过查看其签名，您可以看到它接受一个类型为`Box <Number>`的参数。但是，这是什么意思？ 您是否允许传递`Box <Integer>`或`Box <Double>`，如您所料？ 答案是“不”，因为`Box <Integer>`和`Box <Double>`不是`Box <Number>`的子类型。

在使用泛型编程时，这是一个常见的误解，但这是一个需要学习的重要概念。

![diagram showing that Box<Integer> is not a subtype of Box<Number>](https://docs.oracle.com/javase/tutorial/figures/java/generics-subtypeRelationship.gif)

`Box<Integer>` 不是 `Box<Number>` 的子类型，尽管 `Integer` 是 `Number`的子类型。

------

**注意：**给定两个具体类型`A`和`B`（例如，`Number`和`Integer`），`MyClass <A>`与`MyClass <B>`无关，无论`A`和`B`是否相关。`MyClass <A>`和`MyClass <B>`的公共父类是`Object`。

有关如何在类型参数相关时在两个泛型类之间创建类似子类型关系的信息，请参阅 [通配符和子类型](https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html) 。

------

**泛型类和子类化**

您可以通过扩展或实现通用类或接口来对其进行子类型化。一个类或接口的类型参数与另一个类的类型参数之间的关系由`extends`和`implements`子句决定。

使用`Collections`类作为例子，`ArrayList <E>`实现`List <E>`，`List <E>扩展Collection <E>`。 所以`ArrayList <String>`是`List <String>`的子类型，它是`Collection <String>`的子类型。只要不改变类型参数，就会在类型之间保留子类型关系。

![diagram showing a sample collections hierarchy: ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>.](https://docs.oracle.com/javase/tutorial/figures/java/generics-sampleHierarchy.gif)

现在假设我们想要定义我们自己的列表接口`PayloadList`，它将泛型类型`P`的可选值与每个元素相关联。它的声明可能如下：

```java
interface PayloadList<E,P> extends List<E> {
  void setPayload(int index, P val);
  ...
}
```

`PayloadList`的以下参数化是`List <String>`的子类型：

- `PayloadList<String,String>`
- `PayloadList<String,Integer>`
- `PayloadList<String,Exception>`

![diagram showing an example PayLoadList hierarchy: PayloadList<String, String> is a subtype of List<String>, which is a subtype of Collection<String>. At the same level of PayloadList<String,String> is PayloadList<String, Integer> and PayloadList<String, Exceptions>.](https://docs.oracle.com/javase/tutorial/figures/java/generics-payloadListHierarchy.gif)

### 类型推断

类型推断是 Java 编译器的一种能力，通过检查每个方法调用以及相应的方法声明来确定可应用于方法调用的类型参数。该推断算法确定参数的类型，如果可能，结果被赋值的类型，或者返回值类型。最后，类型推断算法尝试找出所有参数的最精确的类型。

下面的例子说明了上面这一点，类型推断确定传递给`pick`方法的第二个参数是`Serializable`类型：

```java
static <T> T pick(T a1, T a2) { return a2; }
Serializable s = pick("d", new ArrayList<String>());
```

**类型推断和泛型方法**

[泛型方法](https://docs.oracle.com/javase/tutorial/java/generics/methods.html) 向你介绍了类型推断，它使得你可以像调用普通方法那样调用泛型方法，而不需要使用尖括号说明类型参数。考虑下面的例子[`BoxDemo`](https://docs.oracle.com/javase/tutorial/java/generics/examples/BoxDemo.java)，需要 [`Box`](https://docs.oracle.com/javase/tutorial/java/generics/examples/Box.java) 类：

```java
public class BoxDemo {

  public static <U> void addBox(U u, 
      java.util.List<Box<U>> boxes) {
    Box<U> box = new Box<>();
    box.set(u);
    boxes.add(box);
  }

  public static <U> void outputBoxes(java.util.List<Box<U>> boxes) {
    int counter = 0;
    for (Box<U> box: boxes) {
      U boxContents = box.get();
      System.out.println("Box #" + counter + " contains [" +
             boxContents.toString() + "]");
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList<Box<Integer>> listOfIntegerBoxes =
      new java.util.ArrayList<>();
    BoxDemo.<Integer>addBox(Integer.valueOf(10), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
```

程序输出：

```shell
Box #0 contains [10]
Box #1 contains [20]
Box #2 contains [30]
```

泛型方法`addBox`定义了一个名为`u`的类型参数。一般地，Java 编译器可以推断泛型方法调用的类型参数。因此，大部分情况下，你不需要指定它们。比如，为了调用泛型方法`addBox`，你可以随着一个类型*见证者*指定类型参数，如下所示：

```java
BoxDemo.<Integer>addBox(Integer.valueOf(10), listOfIntegerBoxes);
```

不过，如果你忽略该类型见证者，Java 编译器将会自动推断出类型参数是`Integer`：

```java
BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
```

**类型推断和泛型类实例化**

由于编译器可以从上下文中推断出类型参数，你就可以在调用泛型类的构造方法时使用空的类型参数列表 `<>`。这个空的尖括号被称为 [菱形表示法](https://docs.oracle.com/javase/tutorial/java/generics/types.html#diamond) 。

例如，考虑下面的变量声明：

```java
Map<String, List<String>> myMap = new HashMap<String, List<String>>();
```

您可以使用一组空的类型参数（<>）替换构造函数的参数化类型：

```java
Map<String, List<String>> myMap = new HashMap<>();
```

请注意，要在泛型类实例化期间利用类型推断，必须使用菱形表示法。在以下示例中，编译器生成未经检查的转换警告，因为`HashMap()`构造函数引用`HashMap`原始类型，而不是`Map <String，List <String >>`类型：

```java
Map<String, List<String>> myMap = new HashMap(); // unchecked conversion warning
```

**类型推断与泛型类或者非泛型类的泛型构造方法**

请注意，构造函数在泛型和非泛型类中都可以是通用的（换句话说，声明它们自己的形式类型参数）。请考虑以下示例：

```java
class MyClass<X> {
  <T> MyClass(T t) {
    // ...
  }
}
```

考虑下面的`MyClass`类的实例化：

```java
new MyClass<Integer>("")
```

此语句创建参数化类型`MyClass <Integer>`的实例；该语句显式指定泛型类`MyClass <X>`的形式类型参数`X`的类型`Integer`。请注意，此泛型类的构造函数包含一个正式的类型参数`T` 。编译器推断出此泛型类的构造函数的形式类型参数`T`的类型`String`（因为此构造函数的实际参数是`String`对象）。

Java SE 7之前版本的编译器能够推断泛型构造函数的实际类型参数，类似于泛型方法。但是，如果使用菱形表示法`<>`，Java SE 7及更高版本中的编译器可以推断出要实例化的泛型类的实际类型参数。请考虑以下示例：

```java
MyClass<Integer> myObject = new MyClass<>("");
```

在此示例中，编译器为通用类`MyClass <X>`的形式类型参数`X`推断类型`Integer`。它推断出此泛型类的构造函数的形式类型参数`T`的类型`String`。

------

**注意：** 要注意推理算法仅使用调用参数，目标类型，并且可能使用明显的预期返回类型来推断类型。推理算法不使用程序中稍后的结果。

------

**目标类型**

Java编译器利用目标类型来推断泛型方法调用的类型参数。表达式的目标类型是Java编译器所期望的数据类型，具体取决于表达式的出现位置。考虑方法`Collections.emptyList`，声明如下：

```java
static <T> List<T> emptyList();
```

考虑下面的赋值语句：

```java
List<String> listOne = Collections.emptyList();
```

此语句需要`List <String>`的实例；此数据类型是目标类型。因为方法`emptyList`返回`List <T>`类型的值，所以编译器推断类型参数`T`必须是`String`值。这适用于Java SE 7和8。或者，您可以使用类型见证并指定`T`的值，如下所示：

```java
List<String> listOne = Collections.<String>emptyList();
```

不过，这样做在当前上下文中是不必要的。它在其它上下文中是必要的。考虑如下方法：

```java
void processStringList(List<String> stringList) {
    // process stringList
}
```

假设您要使用空列表调用方法`processStringList`。 在Java SE 7中，以下语句不能通过编译：

```java
processStringList(Collections.emptyList());
```

Java SE 7 编译器产生类似下面的错误信息：

```shell
List<Object> cannot be converted to List<String>
```

编译器需要类型参数`T`的值，因此它以`Object`值开头。因此，`Collections.emptyList`的调用返回`List <Object>`类型的值，该值与方法`processStringList`不兼容。因此，在Java SE 7中，您必须指定类型参数，如下所示：

```java
processStringList(Collections.<String>emptyList());
```

Java SE 8中不再需要这样。目标类型的概念已经扩展为包含方法参数，例如方法`processStringList`的参数。在这种情况下，`processStringList`需要一个`List <String>`类型的参数。方法`Collections.emptyList`返回`List <T>`的值，因此使用`List <String>`的目标类型，编译器推断类型参数`T`的值为`String`。因此，在Java SE 8中，以下语句可以通过编译：

```java
processStringList(Collections.emptyList());
```

参考 [Lambda 表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 中的 [目标类型](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing) 获取更多信息。

### 通配符

在泛型代码中，问号`?`被称为*通配符*，表示一个未知的类型。通配符能够被用在各种情景中：作为参数、字段或者局部变量的类型，有时候也作为一个返回类型。通配符永远不会被用来作为泛型方法声明、泛型类实例创建的类型参数，或者一个超类型。

接下来的章节详细讨论通配符，包括上界通配符、下界通配符，以及通配符捕获。

#### 上界通配符

您可以使用上限通配符来放宽对变量的限制。例如，假设您要编写一个适用于`List <Integer>`，`List <Double>`，*和*`List <Number>`的方法。你可以通过使用上限的通配符来实现这一点。

要声明一个上限通配符，请使用通配符（`?`），后跟`extends`关键字，后跟*上限*。注意，在这种情况下，`extends`在一般意义上用于表示“扩展”（在类中）或“实现”（在接口中）。

要编写适用于`Number`列表和`Number`子类的方法，如`Integer`，`Double`和`Float`，你可以指定`List <？ extends Number>`。术语`List <Number>`比`List <？extends Number>`更具限制性。因为前者只匹配一个类型为`Number`的列表，而后者匹配一个类型为`Number`或其任何子类的列表。

考虑下面的 `process` 方法：

```java
public static void process(List<? extends Foo> list) { /* ... */ }
```

上界通配符 `<? extends Foo>`，其中的 `Foo` 是任何类型，匹配到 `Foo` 以及 `Foo`的任何子类。 `process` 方法能够处理元素类型为 `Foo`的列表：

```java
public static void process(List<? extends Foo> list) {
    for (Foo elem : list) {
        // ...
    }
}
```

在`foreach`子句中，`elem`变量遍历列表中的每个元素。现在可以在`elem`上使用`Foo`类中定义的任何方法。

`sumOfList`方法返回列表中数字的总和：

```java
public static double sumOfList(List<? extends Number> list) {
    double s = 0.0;
    for (Number n : list)
        s += n.doubleValue();
    return s;
}
```

下面的代码，使用 `Integer` 对象列表，打印结果 `sum = 6.0`：

```java
List<Integer> li = Arrays.asList(1, 2, 3);
System.out.println("sum = " + sumOfList(li));
```

`Double`值列表可以使用相同的`sumOfList`方法。以下代码打印`sum = 7.0`：

```java
List<Double> ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println("sum = " + sumOfList(ld));
```

#### 无界通配符

无界通配符类型使用通配符`?`来说明，比如，`List<?>`。这被称为未知类型列表。无界通配符在两种场景下是非常有用的：

- 如果你正在编写一个方法，该方法可以使用`Object`类中提供的功能实现。
- 当代码使用泛型类中不依赖类型参数方法时。比如 `List.size` 或者 `List.clear`。事实上，`Class<?>` 是如此常用，因为`Class<?>`中大部分方法都不依赖 `T`。

考虑下面的方法 `printList`：

```java
public static void printList(List<Object> list) {
    for (Object elem : list)
        System.out.println(elem + " ");
    System.out.println();
}
```

`printList`的目标是打印任何类型的列表，但它无法实现该目标 - 它只打印一个`Object`实例列表；它不能打印`List <Integer>`，`List <String>`，`List <Double>`等等，因为它们不是`List <Object>`的子类型。 要编写通用的`printList`方法，请使用`List <？>`：

```java
public static void printList(List<?> list) {
    for (Object elem: list)
        System.out.print(elem + " ");
    System.out.println();
}
```

因为对任何具体的类型 `A`, `List<A>` 都是 `List<?>`的子类，你可以使用 `printList` 来打印任何类型元素的列表：

```java
List<Integer> li = Arrays.asList(1, 2, 3);
List<String>  ls = Arrays.asList("one", "two", "three");
printList(li);
printList(ls);
```

------

**注意：**  [`Arrays.asList`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-) 方法被用在本手册中的所有例子中。此静态工厂方法转化给定的数据并且返回一个固定长度的列表。

------

注意`List <Object>`和`List <？>`是不一样的。您可以将`Object`或`Object`的任何子类型插入到`List <Object>`中。但是你只能将`null`插入`List <？>`。[通配符使用指南](https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html) 部分提供了有关如何确定特定情况下应使用哪种通配符（如果有）的更多信息。

#### 下界通配符

[上界通配符](https://docs.oracle.com/javase/tutorial/java/generics/upperBounded.html) 章节展示上界通配符约束未知类型是使用`extends`关键字表示的特定类型或者特定类型的子类型。类似的，下界通配符约束未知类型为特定类型或者特定类型的超类。

下界通配符使用通配符'`?`'表示，后面跟随 `super` 关键字，随后是它的下界：`<? super A>` 。

------

**注意：** 你可以为一个通配符指定上界或者下界，但是不能同时指定两者。

------

假设您要编写一个将`Integer`对象放入列表的方法。为了最大限度地提高灵活性，您希望该方法可以处理`List <Integer>`，`List <Number>`和`List <Object> ` - 任何可以保存`Integer`值的方法。

要编写适用于`Integer`列表和`Integer`超类型的方法，例如`Integer`，`Number`和`Object`，您可以指定`List<? super Integer>`。`List <Integer>`一词比`List<? super Integer>`更具限制性。因为前者仅匹配`Integer`类型的列表，而后者匹配任何类型为`Integer`的超类型的列表。

以下代码将数字1到10添加到列表的末尾：

```java
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}
```

[通配符使用向导](https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html) 章节介绍了上界通配符和下界通配符的使用时机。

#### 通配符和子类型化

如 [泛型，继承以及子类型化](https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html) 中所述，泛型类后者泛型接口之间不仅仅通过类型相关联。不过，你可以使用通配符在泛型类或者接口之间建立某种关系。

给定下面两个普通的非泛型类：

```java
class A { /* ... */ }
class B extends A { /* ... */ }
```

编写下面的代码是合理的：

```java
B b = new B();
A a = b;
```

此示例显示常规类的继承遵循此子类型规则：如果B扩展A，则类B是类A的子类型。此规则不适用于泛型类型：

```java
List<B> lb = new ArrayList<>();
List<A> la = lb;   // compile-time error
```

鉴于`Integer`是`Number`的子类型，`List <Integer>`和`List <Number>`之间的关系是什么？

![diagram showing that the common parent of List<Number> and List<Integer> is the list of unknown type](https://docs.oracle.com/javase/tutorial/figures/java/generics-listParent.gif)

公共父类是List <?>。

尽管`Integer`是`Number`的子类型，但`List <Integer>`不是`List <Number>`的子类型，实际上，这两种类型不相关。`List <Number>`和`List <Integer>`的公共父类是List <?>。

为了在这些类之间创建关系以便代码可以通过`List <Integer>`的元素访问`Number`的方法，请使用上限的通配符：

```java
List<? extends Integer> intList = new ArrayList<>();
List<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>
```

因为`Integer`是`Number`的子类型，而`numList`是`Number`对象的列表，所以`intList`（`Integer`对象列表）和`numList`之间现在存在关系。下图显示了使用上限和下限通配符声明的多个`List`类之间的关系。

![diagram showing that List<Integer> is a subtype of both List<? extends Integer> and List<?super Integer>. List<? extends Integer> is a subtype of List<? extends Number> which is a subtype of List<?>. List<Number> is a subtype of List<? super Number> and List>? extends Number>. List<? super Number> is a subtype of List<? super Integer> which is a subtype of List<?>.](https://docs.oracle.com/javase/tutorial/figures/java/generics-wildcardSubtyping.gif)

几个通用`List`类声明的层次结构。

[通配符使用向导](https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html) 章节介绍了上界通配符和下界通配符的使用效果。

#### 通配符捕获和帮助方法

某些情况下，编译器推断通配符的类型。比如，一个列表可以定义为`List<?>`，但是，当计算一个表达式时，编译器从代码推断特定类型。该场景被称为*通配符捕获*。

大部分情况下，你不需要担心通配符捕获，除非你看到包含 "capture of" 的错误消息。

[`WildcardError`](https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardError.java) 例子在编译时产生捕获错误：

```java
import java.util.List;

public class WildcardError {

    void foo(List<?> i) {
        i.set(0, i.get(0));
    }
}
```

在此示例中，编译器将`i`输入参数处理为`Object`类型。当`foo`方法调用 [List.set(int, E)](https://docs.oracle.com/javase/8/docs/api/java/util/List.html#set-int-E-) 时，编译器无法确认插入到列表中的对象的类型，并产生错误。发生此类错误时，通常意味着编译器认为您为变量分配了错误的类型。由于这个原因，泛型被添加到Java语言中 - 在编译时强制类型安全。

由 Oracle 的 JDK 7 `javac`实现编译时，`WildcardError`示例生成以下错误：

```shell
WildcardError.java:6: error: method set in interface List<E> cannot be applied to given types;
    i.set(0, i.get(0));
     ^
  required: int,CAP#1
  found: int,Object
  reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
1 error
```

在此示例中，代码尝试执行安全操作，那么如何解决编译器错误？ 您可以通过编写捕获通配符的私有帮助程序方法来解决它。在这种情况下，您可以通过创建私有帮助器方法`fooHelper`来解决此问题，如`WildcardFixed`中所示：

```java
public class WildcardFixed {

    void foo(List<?> i) {
        fooHelper(i);
    }


    // Helper method created so that the wildcard can be captured
    // through type inference.
    private <T> void fooHelper(List<T> l) {
        l.set(0, l.get(0));
    }

}
```

在辅助方法帮助下，编译器使用推断来确定调用中T是CAP＃1（捕获变量）。该示例现在已成功编译。

按照惯例，辅助方法通常命名为`*originalMethodName*Helper`。

现在考虑一个更复杂的例子， [`WildcardErrorBad`](https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardErrorBad.java)：

```java
import java.util.List;

public class WildcardErrorBad {

    void swapFirst(List<? extends Number> l1, List<? extends Number> l2) {
      Number temp = l1.get(0);
      l1.set(0, l2.get(0)); // expected a CAP#1 extends Number,
                            // got a CAP#2 extends Number;
                            // same bound, but different types
      l2.set(0, temp);	    // expected a CAP#1 extends Number,
                            // got a Number
    }
}
```

在此示例中，代码尝试进行不安全的操作。例如，考虑以下对`swapFirst`方法的调用：

```java
List<Integer> li = Arrays.asList(1, 2, 3);
List<Double>  ld = Arrays.asList(10.10, 20.20, 30.30);
swapFirst(li, ld);
```

`List <Integer>`和`List <Double>`都符合`List <？extends Number>`，从`Integer`值列表中取一个项目并尝试将其放入`Double`值列表中显然是不正确的。

使用Oracle的JDK `javac`编译器编译代码会产生以下错误：

```shell
WildcardErrorBad.java:7: error: method set in interface List<E> cannot be applied to given types;
      l1.set(0, l2.get(0)); // expected a CAP#1 extends Number,
        ^
  required: int,CAP#1
  found: int,Number
  reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Number from capture of ? extends Number
WildcardErrorBad.java:10: error: method set in interface List<E> cannot be applied to given types;
      l2.set(0, temp);      // expected a CAP#1 extends Number,
        ^
  required: int,CAP#1
  found: int,Number
  reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Number from capture of ? extends Number
WildcardErrorBad.java:15: error: method set in interface List<E> cannot be applied to given types;
        i.set(0, i.get(0));
         ^
  required: int,CAP#1
  found: int,Object
  reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
3 errors
```

没有帮助方法来解决这个问题，因为代码根本就是错误的。

#### 通配符使用向导

学习使用泛型编程时，更令人困惑的一个方面是确定何时使用上界通配符以及何时使用下界通配符。此页面提供了设计代码时要遵循的一些准则。

出于本讨论的目的，将变量视为提供两个函数之一是有帮助的：

- **一个“in”变量**

  “in”变量向代码提供数据。想象一下带有两个参数的复制方法：`copy(src, dest)`。`src`参数提供要复制的数据，因此它是“in”参数。

- **一个“out”变量**

  “out”变量保存数据以供其他地方使用。在复制示例中，`copy(src, dest)`，`dest`参数接受数据，因此它是“out”参数。

当然，一些变量既用于“in”又用于“out”目的 - 这种情况也在指南中得到解决。

在决定是否使用通配符以及适合使用哪种类型的通配符时，可以使用“in”和“out”原则。以下列表提供了遵循的准则：

------

通配符指南：

- 使用`extends`关键字定义带有上限通配符的“in”变量。
- 使用`super`关键字定义带有下限通配符的“out”变量。
- 如果可以使用`Object`类中定义的方法访问“in”变量，请使用无界通配符。
- 如果代码需要作为“in”和“out”变量访问变量，请不要使用通配符。

------

这些指南不适用于方法的返回类型。应该避免使用通配符作为返回类型，因为它强制程序员使用代码来处理通配符。

 `List<? extends ...>` 可以被非正式地认为是只读的，但这不是一个严格的保证。假设您有以下两个类：

```java
class NaturalNumber {

    private int i;

    public NaturalNumber(int i) { this.i = i; }
    // ...
}

class EvenNumber extends NaturalNumber {

    public EvenNumber(int i) { super(i); }
    // ...
}
```

考虑如下代码：

```java
List<EvenNumber> le = new ArrayList<>();
List<? extends NaturalNumber> ln = le;
ln.add(new NaturalNumber(35));  // compile-time error
```

因为`List <EvenNumber>`是`List <? extends NaturalNumber>`，你可以将`le`赋给`ln`。但是你不能使用`ln`将自然数添加到偶数列表中。列表中的以下操作是可能的：

- 您可以添加`null`。
- 你可以调用`clear`。
- 您可以获取迭代器并调用`remove`。
- 您可以捕获通配符并写入从列表中读取的元素。

你可以看到 `List<? extends NaturalNumber>` 在严格意义上不是只读的，但您可能会这样想，因为您无法存储新元素或更改列表中的现有元素。

### 类型擦除

泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。为了实现泛型，Java编译器将类型擦除应用于：

- 如果类型参数是无界的，则将泛型类型中的所有类型参数替换为其边界或`Object`。因此，生成的字节码仅包含普通的类，接口和方法。
- 如有必要，插入类型转换以保持类型安全。
- 生成桥接方法以保留扩展泛型类型中的多态性。

类型擦除确保不为参数化类型创建新类：因此，泛型不会产生运行时开销。

#### 泛型类型擦除

在类型擦除过程中，Java编译器将擦除所有类型参数，并在类型参数有界时将其替换为第一个界，如果类型参数为无界，则替换为`Object`。

考虑以下表示单链表中节点的泛型类：

```java
public class Node<T> {

    private T data;
    private Node<T> next;

    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

    public T getData() { return data; }
    // ...
}
```

因为类型参数`T`是无界的，所以Java编译器将其替换为`Object`：

```java
public class Node {

    private Object data;
    private Node next;

    public Node(Object data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Object getData() { return data; }
    // ...
}
```

在以下示例中，泛型`Node`类使用有界类型参数：

```java
public class Node<T extends Comparable<T>> {

    private T data;
    private Node<T> next;

    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

    public T getData() { return data; }
    // ...
}
```

Java编译器将有界类型参数`T`替换为第一个界限类`Comparable`：

```java
public class Node {

    private Comparable data;
    private Node next;

    public Node(Comparable data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Comparable getData() { return data; }
    // ...
}
```

#### 泛型方法擦除

Java 编译器也会擦除泛型方法参数的类型参数。考虑下面的泛型方法：

```java
// Counts the number of occurrences of elem in anArray.
//
public static <T> int count(T[] anArray, T elem) {
    int cnt = 0;
    for (T e : anArray)
        if (e.equals(elem))
            ++cnt;
        return cnt;
}
```

由于`T`是无界的，Java 编译器将它替换为 `Object`：

```java
public static int count(Object[] anArray, Object elem) {
    int cnt = 0;
    for (Object e : anArray)
        if (e.equals(elem))
            ++cnt;
        return cnt;
}
```

假设定义如下的类：

```java
class Shape { /* ... */ }
class Circle extends Shape { /* ... */ }
class Rectangle extends Shape { /* ... */ }
```

你可以编写一个泛型方法来画出不同的形状：

```java
public static <T extends Shape> void draw(T shape) { /* ... */ }
```

Java 编译器将 `T` 替换为 `Shape`：

```java
public static void draw(Shape shape) { /* ... */ }
```

#### 类型擦除和桥接方法的影响

有时候类型擦除导致你可能没有候选者的情况。下面的例子展示了这种情况是如何发生的。该例子（在 [桥接方法](https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html#bridgeMethods) 中描述）展示了有时编译器是如何创建一个合成方法，并调用一个桥接方法，作为类型擦除过程的一部分。

给定下面的两个类：

```java
public class Node<T> {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

考虑下面的代码：

```java
MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
n.setData("Hello");     
Integer x = mn.data;    // Causes a ClassCastException to be thrown.
```

类型擦除之后，代码变成：

```java
MyNode mn = new MyNode(5);
Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
n.setData("Hello");
Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.
```

代码执行时将会发生：

- `n.setData("Hello");` 导致`MyNode`类对象上的方法`setData(Object)` 被执行。(`MyNode` 类从 `Node`类继承`setData(Object)`。)
- 在`setData(Object)`的方法体中，`n`引用的对象的数据字段被分配给`String`。
  undefined可以访问通过`mn`引用的同一对象的数据字段，并且期望它是一个整数（因为`mn`是`MyNode`，它是`Node <Integer>`。
   undefined尝试将`String`分配给`Integer`会导致 Java 编译器在赋值时插入的转换中出现`ClassCastException`。

**桥接方法**

在编译扩展参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，您可能会感到困惑。

在类型擦除之后，`Node`和`MyNode`类变为：

```java
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

在类型擦除之后，方法签名不匹配。`Node`方法变为`setData(Object)`，`MyNode`方法变为`setData(Integer)`。因此，`MyNode.setData`方法不会覆盖`Node.setData`方法。

为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java编译器会生成一个桥接方法，以确保子类型按预期工作。 对于`MyNode`类，编译器为`setData`生成以下桥接方法：

```java
class MyNode extends Node {

    // Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```

如您所见，桥接方法与类型擦除后的`Node`类的`setData`方法具有相同的方法签名，委托给原始的`setData`方法。

#### 不可再生类型

[类型擦除](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html) 部分讨论了编译器删除与类型形式参数和类型实际参数相关的信息的过程。类型擦除具有与可变参数（也称为`varargs`）方法有关的后果，其`varargs`形式参数具有不可再生类型。有关`varargs`方法的更多信息，请参阅 [传递信息给方法或者构造器](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html) 章节中的 [任意数量参数](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs) 部分。

此页面包含以下主题：

- [不可再生类型](https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#non-reifiable-types)
- [堆污染](https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#heap_pollution)
- [具有不可再生形式参数的`Varargs`方法的潜在漏洞](https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#vulnerabilities)
- [防止使用不可再生形式参数的`Varargs`方法的警告](https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#suppressing)

**不可再生类型**

可再生类型是类型信息在运行时完全可用的类型。这包括基本数据类型，非泛型类型，原始类型和无界通配符的调用。

不可再生类型是在编译时通过类型擦除删除信息的类型 - 未定义为无界通配符的泛型类型的调用。不可重新生成的类型在运行时没有提供所有信息。不可再生类型的示例是`List <String>`和`List <Number>` ；JVM无法在运行时区分这些类型。如 [泛型的局限性](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html) 中所示，在某些情况下，不能使用不可重新生成的类型：例如，在 `instanceof` 表达式中，或作为数组中的元素。

**堆污染**

当参数化类型的变量引用不是该参数化类型的对象时，会发生*堆污染* 。如果程序执行某些操作，在编译时产生未经检查的警告，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，生成涉及参数化类型（例如，强制转换或方法调用）的操作的正确性无法验证，则会生成未经检查的警告。例如，在混合原始类型和参数化类型时，或者在执行未经检查的强制转换时，会发生堆污染。

在正常情况下，当所有代码同时编译时，编译器会发出未经检查的警告，以引起您对潜在堆污染的注意。如果单独编译代码的各个部分，则很难检测到堆污染的潜在风险。如果确保代码在没有警告的情况下编译，则不会发生堆污染。

**具有不可再生形式参数的`Varargs`方法的潜在漏洞**

包含可变输入参数的泛型方法可能会导致堆污染。

考虑下面的 `ArrayBuilder` 类：

```java
public class ArrayBuilder {

  public static <T> void addToList (List<T> listArg, T... elements) {
    for (T x : elements) {
      listArg.add(x);
    }
  }

  public static void faultyMethod(List<String>... l) {
    Object[] objectArray = l;     // Valid
    objectArray[0] = Arrays.asList(42);
    String s = l[0].get(0);       // ClassCastException thrown here
  }

}
```

下面的例子， `HeapPollutionExample` 使用 `ArrayBuiler` 类：

```java
public class HeapPollutionExample {

  public static void main(String[] args) {

    List<String> stringListA = new ArrayList<String>();
    List<String> stringListB = new ArrayList<String>();

    ArrayBuilder.addToList(stringListA, "Seven", "Eight", "Nine");
    ArrayBuilder.addToList(stringListB, "Ten", "Eleven", "Twelve");
    List<List<String>> listOfStringLists =
      new ArrayList<List<String>>();
    ArrayBuilder.addToList(listOfStringLists,
      stringListA, stringListB);

    ArrayBuilder.faultyMethod(Arrays.asList("Hello!"), Arrays.asList("World!"));
  }
}
```

编译时，`ArrayBuilder.addToList`方法的定义产生以下警告：

```shell
warning: [varargs] Possible heap pollution from parameterized vararg type T
```

当编译器遇到`varargs`方法时，它会将`varargs`形式参数转换为数组。但是，Java编程语言不允许创建参数化类型的数组。在方法`ArrayBuilder.addToList`中，编译器将`varargs`形式参数`T...`元素转换为形式参数`T[]`元素，即数组。但是，由于类型擦除，编译器会将`varargs`形式参数转换为`Object[]`元素。因此，存在堆污染的可能性。

以下语句将`varargs`形式参数`l`分配给`Object`数组`objectArgs`：

```java
Object[] objectArray = l;
```

以上语句可能会引入堆污染。与`varargs`形式参数`l`的参数化类型匹配的值可以分配给变量`objectArray`，因此可以分配给`l`。但是，编译器不会在此语句中生成未经检查的警告。编译器在将`varargs`形式参数`List <String> ... `l转换为形式参数`List []`l时已生成警告。以上语句有效：变量`l`的类型为`List []`，它是`Object []`的子类型。

因此，如果将任何类型的`List`对象分配给`objectArray`数组的任何数组组件，编译器不会发出警告或错误，如下所示：

```java
objectArray[0] = Arrays.asList(42);
```

此语句将包含一个`Integer`类型的对象的`List`对象分配给`objectArray`数组的第一个数组元素。

假设您使用以下语句调用`ArrayBuilder.faultyMethod`：

```java
ArrayBuilder.faultyMethod(Arrays.asList("Hello!"), Arrays.asList("World!"));
```

运行时，JVM 对下面的语句抛出一个 `ClassCastException` ：

```java
// ClassCastException thrown here
String s = l[0].get(0);
```

存储在变量`l`的第一个数组元素中的对象具有`List <Integer>`类型，但此语句需要一个`List <String>`类型的对象。

**防止使用不可再生形式参数的`Varargs`方法的警告**

如果声明具有参数化类型参数的`varargs`方法，并确保方法体不会因`varargs`形式参数处理不当而抛出`ClassCastException`或其他类似异常，则可以通过向静态和非构造方法声明添加以下注解来防止编译器为这些类型的varargs方法生成警告：

```java
@SafeVarargs
```

`@SafeVarargs`注解是方法契约的文档部分；这个注解断言该方法的实现不会不正确地处理`varargs`形式参数。

尽管不太可取，但通过在方法声明中添加以下内容来抑制此类警告也是可能的：

```java
@SuppressWarnings({"unchecked", "varargs"})
```

但是，此方法不会抑制从方法的调用生成的警告。如果您不熟悉`@SuppressWarnings`语法，请参阅 [注解](https://docs.oracle.com/javase/tutorial/java/annotations/index.html) 。

### 泛型的局限性

为了有效使用 Java 泛型，你必须了解以下限制：

- [不能用基本数据类型实例化泛型类型](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#instantiate)
- [不能创建类型参数的实例](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createObjects)
- [不能声明类型为类型参数的静态字段](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createStatic)
- [不能对参数化类型使用类型转换或者`instanceof`](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCast)
- [不能创建参数化类型数组](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createArrays)
- [不能创建、捕获或者抛出参数化类型对象](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCatch)
- [无法重载每个重载的形式参数类型擦除到相同原始类型的方法](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotOverload)

**不能用基本数据类型实例化泛型类型**

考虑下面的参数化类型：

```java
class Pair<K, V> {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    // ...
}
```

创建`Pair`对象时，不能用基本类型替换类型参数`K`或`V`：

```java
Pair<int, char> p = new Pair<>(8, 'a');  // compile-time error
```

你只能使用非基本数据类型来替换类型参数 `K` 和 `V` ：

```java
Pair<Integer, Character> p = new Pair<>(8, 'a');
```

注意，编译器会自动装箱 `8` 为 `Integer.valueOf(8)` 同时 '`a`' 装箱为 `Character('a')`：

```java
Pair<Integer, Character> p = new Pair<>(Integer.valueOf(8), new Character('a'));
```

有关自动装箱的更多信息，参考 [自动装箱和拆箱](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html) 。

**不能创建类型参数的实例**

您无法创建类型参数的实例。例如，以下代码导致编译时错误：

```java
public static <E> void append(List<E> list) {
    E elem = new E();  // compile-time error
    list.add(elem);
}
```

作为权宜之计，您可以通过反射创建类型参数的对象：

```java
public static <E> void append(List<E> list, Class<E> cls) throws Exception {
    E elem = cls.newInstance();   // OK
    list.add(elem);
}
```

你可以调用 `append` 方法如下：

```java
List<String> ls = new ArrayList<>();
append(ls, String.class);
```

**不能声明类型为类型参数的静态字段**

一个类的静态字段是被所有该类的非静态对象共享的类层面的变量。因此，类型参数静态字段是不允许的。考虑下面的类：

```java
public class MobileDevice<T> {
    private static T os;

    // ...
}
```

如果允许类型参数静态字段，则下面的代码就会让人无法理解：

```java
MobileDevice<Smartphone> phone = new MobileDevice<>();
MobileDevice<Pager> pager = new MobileDevice<>();
MobileDevice<TabletPC> pc = new MobileDevice<>();
```

因为静态字段`os`由`phone`，`pager`和`pc`共享，`os`的实际类型是什么？ 它不能同时是`Smartphone`，`Pager`和`TabletPC`。因此，您无法创建类型参数的静态字段。

**不能对参数化类型使用类型转换或者`instanceof`**

由于编译器会擦除泛型代码中的所有类型参数，所以你无法在运行时为一个泛型类型校验参数化类型：

```java
public static <E> void rtti(List<E> list) {
    if (list instanceof ArrayList<Integer>) {  // compile-time error
        // ...
    }
}
```

传递给`rtti`方法的参数化类型集是：

```java
S = { ArrayList<Integer>, ArrayList<String> LinkedList<Character>, ... }
```

运行时不跟踪类型参数，因此无法区分`ArrayList <Integer>`和`ArrayList <String>`。您可以做的最多是使用无界通配符来验证列表是否为`ArrayList`：

```java
public static void rtti(List<?> list) {
    if (list instanceof ArrayList<?>) {  // OK; instanceof requires a reifiable type
        // ...
    }
}
```

通常，除非通过无界通配符对参数化进行参数化，否则无法强制转换为参数化类型。例如：

```java
List<Integer> li = new ArrayList<>();
List<Number>  ln = (List<Number>) li;  // compile-time error
```

但是，在某些情况下，编译器知道类型参数始终有效并允许强制转换。例如：

```java
List<String> l1 = ...;
ArrayList<String> l2 = (ArrayList<String>)l1;  // OK
```

**不能创建参数化类型数组**

您无法创建参数化类型的数组。例如，以下代码无法编译：

```java
List<Integer>[] arrayOfLists = new List<Integer>[2];  // compile-time error
```

以下代码说明了将不同类型插入到数组中时会发生什么：

```java
Object[] strings = new String[2];
strings[0] = "hi";   // OK
strings[1] = 100;    // An ArrayStoreException is thrown.
```

如果您使用泛型列表尝试相同的操作，则会出现问题：

```java
Object[] stringLists = new List<String>[];  // compiler error, but pretend it's allowed
stringLists[0] = new ArrayList<String>();   // OK
stringLists[1] = new ArrayList<Integer>();  // An ArrayStoreException should be thrown,
                                            // but the runtime can't detect it.
```

如果允许参数化列表数组，则前面的代码将无法抛出所需的`ArrayStoreException`。

**不能创建、捕获或者抛出参数化类型对象**

泛型类不能直接或间接扩展`Throwable`类。例如，以下类将无法编译：

```java
// Extends Throwable indirectly
class MathException<T> extends Exception { /* ... */ }    // compile-time error

// Extends Throwable directly
class QueueFullException<T> extends Throwable { /* ... */ // compile-time error
```

方法无法捕获类型参数的实例：

```java
public static <T extends Exception, J> void execute(List<J> jobs) {
    try {
        for (J job : jobs)
            // ...
    } catch (T e) {   // compile-time error
        // ...
    }
}
```

但是，您可以在`throws`子句中使用类型参数：

```java
class Parser<T extends Exception> {
    public void parse(File file) throws T {     // OK
        // ...
    }
}
```

**无法重载每个重载的形式参数类型擦除到相同原始类型的方法**

类不能有两个在类型擦除后具有相同的签名的重载方法。

```java
public class Example {
    public void print(Set<String> strSet) { }
    public void print(Set<Integer> intSet) { }
}
```

重载将共享相同的类文件表示，并将生成编译错误。

## 包

本课章节解释了如何将类和接口打包到包中，如何使用包中的类，以及如何安排文件系统以便编译器可以找到源文件。

### 创建和使用包

为了使类型更容易查找和使用，避免命名冲突和控制访问，程序员将相关类型的组打包到包中。

------

**定义：** 包是一组提供访问保护和命名空间管理的相关类型。请注意，*types*指的是类，接口，枚举和注解类型。枚举和注解类型分别是特殊类型的类和接口，因此*类型*在本章节中通常简称为*类和接口*。

------

作为Java平台一部分的类型是按功能分类打包的各种包的成员：基本类在`java.lang`中，用于读写的类（输入和输出）在`java.io`中，等等。您也可以将你自己的类型放入包中。

假设您编写了一组表示图形对象的类，例如圆形，矩形，线条和点。您还可以编写一个接口`Draggable`，如果可以使用鼠标拖动它们，则应该实现该接口。

```java
//in the Draggable.java file
public interface Draggable {
    ...
}

//in the Graphic.java file
public abstract class Graphic {
    ...
}

//in the Circle.java file
public class Circle extends Graphic
    implements Draggable {
    . . .
}

//in the Rectangle.java file
public class Rectangle extends Graphic
    implements Draggable {
    . . .
}

//in the Point.java file
public class Point extends Graphic
    implements Draggable {
    . . .
}

//in the Line.java file
public class Line extends Graphic
    implements Draggable {
    . . .
}
```

您应该将这些类和接口打包在一个包中，原因有多种，包括：

- 您和其他程序员可以轻松确定这些类型是否相关。
- 您和其他程序员知道在哪里可以找到可以提供图形相关功能的类型。
- 类型的名称不会与其他包中的类型名称冲突，因为包会创建新的命名空间。
- 您可以允许程序包中的类型对彼此具有不受限制的访问权限，但仍限制对程序包外部类型的访问。

#### 创建包

要创建一个包，你可以选择一个包的名称（命名约定将在下一节讨论），并在要包含在包中的类型（类，接口， 枚举和注解类型）的每个源文件的顶部放置一个带有该名称的`package`语句。

`package`语句（例如，`package graphics;`）必须是源文件中的第一行。每个源文件中只能有一个`package`语句，它适用于文件中的所有类型。

------

**注意：** 如果在单个源文件中放置多个类型，则只有一个可以是`public`的，并且它必须与源文件具有相同的名称。例如，您可以在文件`Circle.java`中定义`public class Circle`，在文件`Draggable.java`中定义`public interface Draggable`，在`Day.java`文件中定义`public enum Day`， 等等。

您可以将非公共类型与公共类型包含在同一文件中（强烈建议不要这样做，除非非公共类型很小且与公共类型密切相关），但只有公共类型可以从公共类型所在的包外部访问。所有顶级非公开类型都将是*package private*的。

------

如果将上一节中列出的图形接口和类放在名为`graphics`的包中，则需要六个源文件，如下所示：

```java
//in the Draggable.java file
package graphics;
public interface Draggable {
    . . .
}

//in the Graphic.java file
package graphics;
public abstract class Graphic {
    . . .
}

//in the Circle.java file
package graphics;
public class Circle extends Graphic
    implements Draggable {
    . . .
}

//in the Rectangle.java file
package graphics;
public class Rectangle extends Graphic
    implements Draggable {
    . . .
}

//in the Point.java file
package graphics;
public class Point extends Graphic
    implements Draggable {
    . . .
}

//in the Line.java file
package graphics;
public class Line extends Graphic
    implements Draggable {
    . . .
}
```

如果你不使用`package`语句，你的类型最终会在一个未命名的包中。一般来说，一个未命名的包只适用于小型或临时应用程序，或者刚刚开始开发过程。否则，类和接口都属于某个命名包。

#### 包命名

随着全世界程序员使用Java编程语言编写类和接口，许多程序员可能会对不同类型使用相同的名称。实际上，前面的例子就是这样：当`java.awt`包中已经有一个`Rectangle`类时，它又定义了一个`Rectangle`类。尽管如此，编译器允许两个类在不同的包中具有相同的名称。每个`Rectangle`类的完全限定名称都包括包名称。也就是说，`graphics`包中`Rectangle`类的完全限定名是`graphics.Rectangle`，`java.awt`包中`Rectangle`类的完全限定名是`java.awt.Rectangle`。

除非两个独立的程序员为其包使用相同的名称，否则这很有效。 什么阻止了这个问题？ 惯例。

**命名惯例**

包名称全部用小写编写，以避免与类或接口的名称冲突。

公司使用他们的反向互联网域名来开始他们的包名称 - 例如，`com.example.mypackage`用于由`example.com`的程序员创建的名为`mypackage`的包。

在单个公司内发生的名称冲突需要通过公司内的约定来处理，可能是通过在公司名称后面包含区域或项目名称（例如，`com.example.region.mypackage`）。

Java语言本身的包以`java.`或`javax.`开头

在某些情况下，互联网域名可能不是有效的包名。如果域名包含连字符或其他特殊字符，如果包名称以数字或其他非法用作Java名称开头的字符开头，或者包名称包含保留的Java关键字，则会发生这种情况，例如`int`。在这种情况下，建议添加下划线。例如：

| 域名                            | 包名前缀                          |
| ----------------------------- | ----------------------------- |
| `hyphenated-name.example.org` | `org.example.hyphenated_name` |
| `example.int`                 | `int_.example`                |
| `123name.example.com`         | `com.example._123name`        |

#### 使用包成员

组成包的类型称为包成员。

要从其包外部使用公共包成员，您必须执行以下操作之一：

- 通过其完全限定名称引用该成员
- 导入包成员
- 导入成员所在的整个包

每种情况都适用于不同的情况，如以下各节所述。

**通过其完全限定名称引用该成员**

到目前为止，本教程中的大多数示例都通过简单名称引用类型，例如`Rectangle`和`StackOfInts`。如果您编写的代码与该成员位于同一个包中，或者已导入该成员，则可以使用包成员的简单名称。

但是，如果您尝试使用其他程序包中的成员并且尚未导入该程序包，则必须使用该成员的完全限定名称，该名称包括程序包名称。这是上一个示例中 `graphics` 包中声明的`Rectangle`类的完全限定名称。

```java
graphics.Rectangle
```

你也可以使用全限定名类创建实例 `graphics.Rectangle` ：

```java
graphics.Rectangle myRect = new graphics.Rectangle();
```

全限定名称可以不经常使用。但是，当重复使用名称时，重复键入名称会变得乏味，并且代码变得难以阅读。作为替代方法，您可以导入成员或其包，然后使用其简单名称。

**导入包成员**

要将特定成员导入当前文件，请在任何类型定义之前在文件开头放置`import`语句，但在`package`语句之后（如果有）。以下是从上一节中创建的 `graphics` 包导入`Rectangle`类的方法。

```java
import graphics.Rectangle;
```

现在您可以通过简单名称引用`Rectangle`类。

```java
Rectangle myRectangle = new Rectangle();
```

如果您只使用 `graphics` 包中的一些成员，这种方法很有效。但是如果从包中使用许多类型，则应导入整个包。

**导入整个包**

为了导入特定包中的所有类型，使用 `import` 语句和星号 (`*`) 通配符。

```java
import graphics.*;
```

接下来你就可以使用包内的类的简单名称引用它们：

```java
Circle myCircle = new Circle();
Rectangle myRectangle = new Rectangle();
```

`import`语句中的星号只能用于指定包中的所有类，如此处所示。它不能用于匹配包中类的子集。例如，以下内容与 `graphics` 包中以`A`开头的所有类都不匹配。

```java
// does not work
import graphics.A*;
```

相反，它会生成编译错误。使用`import`语句，通常只导入单个包成员或整个包。

------

注意：另一种不太常见的导入形式允许您导入包含特定类的公共嵌套类。例如，如果`graphics.Rectangle`类包含有用的嵌套类（如`Rectangle.DoubleWide`和`Rectangle.Square`），则可以使用以下两个语句导入`Rectangle`及其嵌套类。

```java
import graphics.Rectangle;
import graphics.Rectangle.*;
```

请注意，第二个`import`语句不会导入`Rectangle`。

另一种不常见的导入形式是*静态*导入语句，将在本节末尾讨论。

------

为方便起见，Java编译器自动为每个源文件导入两个完整的包：（1）`java.lang`包和（2）当前包（当前文件的包）。

**名称混淆**

如果一个包中的成员与另一个包中的成员共享其名称并且两个包都已导入，则必须通过其限定名称引用每个成员。例如， `graphics` 包定义了一个名为`Rectangle`的类。`java.awt`包还包含一个`Rectangle`类。如果已导入 `graphics` 和`java.awt` 包，则以下内容不明确。

```java
Rectangle rect;
```

在这种情况下，您必须使用成员的完全限定名称来准确指出您想要的`Rectangle`类。例如，

```java
graphics.Rectangle rect;
```

**静态导入语句**

在某些情况下，您需要经常访问`static final`字段（常量）和来自一个或两个类的`static`方法。反复对这些类的名称进行前缀可能会导致代码混乱。静态`import`语句为您提供了一种导入要使用的常量和静态方法的方法，这样您就不需要为其类的名称添加前缀。

`java.lang.Math`类定义`PI`常量和许多静态方法，包括计算正弦，余弦，切线，平方根，最大值，最小值，指数等的方法。 例如：

```java
public static final double PI 
    = 3.141592653589793;
public static double cos(double a)
{
    ...
}
```

通常，要从其他类使用这些对象，请在类名前加上前缀，如下所示。

```java
double r = Math.cos(Math.PI * theta);
```

您可以使用`static import`语句导入`java.lang.Math`的静态成员，这样就不需要为类名称添加前缀`Math`。`Math`的静态成员可以单独导入：

```java
import static java.lang.Math.PI;
```

或者作为一个组：

```java
import static java.lang.Math.*;
```

导入后，可以无限制地使用静态成员。例如，之前的代码段将变为：

```java
double r = cos(PI * theta);
```

显然，您可以编写自己的类，其中包含您经常使用的常量和静态方法，然后使用静态`import`语句。例如：

```java
import static mypackage.MyConstants.*;
```

------

**注意：** 要非常谨慎地使用静态导入。过度使用静态导入会导致代码难以阅读和维护，因为代码的读者不知道哪个类定义了特定的静态对象。正确使用静态导入可以通过删除类名重复使代码更具可读性。

------

#### 管理源代码和类文件

Java平台的许多实现依赖于分层文件系统来管理源文件和类文件，尽管Java语言规范不要求这样做。 策略如下。

将类，接口，枚举或注解类型的源代码放在文本文件中，该文件的名称是类型的简单名称，扩展名为`.java`。 例如：

```java
//in the Rectangle.java file 
package graphics;
public class Rectangle {
   ... 
}
```

然后，将源文件放在一个目录中，该目录的名称反映了该类型所属的包的名称：

```java
.....\graphics\Rectangle.java
```

假定 Microsoft Windows 文件名分隔符反斜杠（对于UNIX，使用正斜杠），包成员的限定名称和文件的路径名是并行的。

- **类名** -  `graphics.Rectangle`
- **文件路径名** -  `graphics\Rectangle.java`

您应该记得，按照惯例，公司使用其反向的互联网域名作为其包名。示例公司的 Internet 域名是`example.com`，它的所有包名都在`com.example`之前。包名称的每个组件对应一个子目录。因此，如果 Example 公司有一个包含`Rectangle.java`源文件的c`om.example.graphics`包，它将包含在一系列子目录中，如下所示：

```java
....\com\example\graphics\Rectangle.java
```

编译源文件时，编译器会为其中定义的每种类型创建不同的输出文件。输出文件的基本名称是类型的名称，其扩展名为`.class`。例如，如果源文件是这样的：

```java
//in the Rectangle.java file
package com.example.graphics;
public class Rectangle {
      . . . 
}

class Helper{
      . . . 
}
```

则编译之后生成的文件位于：

```
<path to the parent directory of the output files>\com\example\graphics\Rectangle.class
<path to the parent directory of the output files>\com\example\graphics\Helper.class
```

与`.java`源文件一样，已编译的`.class`文件应位于一系列反映包名称的目录中。但是，`.class`文件的路径不必与`.java`源文件的路径相同。您可以分开放置源文件和类目录，如下所示：

```
<path_one>\sources\com\example\graphics\Rectangle.java
<path_two>\classes\com\example\graphics\Rectangle.class
```

通过这样做，您可以将`classes`目录提供给其他程序员而不会泄露您的源文件。您还需要以这种方式管理源文件和类文件，以便编译器和Java虚拟机（JVM）可以找到程序使用的所有类型。

`classes`目录的完整路径`<path_two> \ classes`称为类路径，并使用`CLASSPATH`系统变量进行设置。编译器和JVM都通过将包名称添加到类路径来构造`.class`文件的路径。例如，如果

```
<path_two>\classes
```

是你的类路径，而包名是：

```
com.example.graphics,
```

则编译器和 JVM 在下面的路径寻找 `.class ` 文件：

```
<path_two>\classes\com\example\graphics.
```

类路径可能包含多个路径，由分号（Windows）或冒号（UNIX）分隔。默认情况下，编译器和JVM搜索当前目录和包含Java平台类的JAR文件，以便这些目录自动位于类路径中。

**设置`CLASSPATH`系统变量**

要显示当前的`CLASSPATH`变量，请在 Windows 和 UNIX（Bourne shell）中使用以下命令：

```
In Windows:   C:\> set CLASSPATH
In UNIX:      % echo $CLASSPATH
```

要删除`CLASSPATH`变量的当前内容，请使用以下命令：

```
In Windows:   C:\> set CLASSPATH=
In UNIX:      % unset CLASSPATH; export CLASSPATH
```

设置 `CLASSPATH` 变量，使用下面的命令：

```
In Windows:   C:\> set CLASSPATH=C:\users\george\java\classes
In UNIX:      % CLASSPATH=/home/george/java/classes; export CLASSPATH
```

#### 创建和使用包小结

要为类型创建包，请将`package`语句作为源文件中包含类型（类，接口，枚举或注解类型）的第一个语句。

要使用不同包中的公共类型，您有三种选择：（1）使用类型的完全限定名称，（2）导入类型，或（3）导入类型为成员的整个包。

包的源文件和类文件的路径名称反映了包的名称。

您可能必须设置`CLASSPATH`，以便编译器和JVM可以找到类型的`.class`文件。

# 必要的类

本章节讨论了Java平台中对大多数程序员来说必不可少的类。

[![Trail icon](https://docs.oracle.com/javase/tutorial/images/coreIcon.gif)**异常**](https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html) 解释了异常机制以及它如何用于处理错误和其他异常情况。本课程描述了异常是什么，如何抛出和捕获异常，一旦捕获异常后如何处理异常，以及如何使用异常类层次结构。

[![Trail icon](https://docs.oracle.com/javase/tutorial/images/coreIcon.gif)**基本 I/O**](https://docs.oracle.com/javase/tutorial/essential/io/index.html) 涵盖用于基本输入和输出的Java平台类。它主要关注I / O流，这是一个强大的概念，可以大大简化I / O操作。本课程还介绍了序列化，它允许程序将整个对象写入流并再次读回。然后，本课程将介绍一些文件系统操作，包括随机访问文件。最后，它简要介绍了新I / O API的高级功能。

[![Trail icon](https://docs.oracle.com/javase/tutorial/images/coreIcon.gif)**并发**](https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html) 解释了如何编写同时执行多个任务的应用程序。Java平台的设计初衷是为了支持并发编程，在Java编程语言和Java类库中提供基本的并发支持。从5.0版开始，Java平台还包含高级并发API。本课程介绍了平台的基本并发支持，并总结了`java.util.concurrent`包中的一些高级API。

[![Trail icon](https://docs.oracle.com/javase/tutorial/images/coreIcon.gif)**平台环境**](https://docs.oracle.com/javase/tutorial/essential/environment/index.html) 由启动应用程序时提供的底层操作系统，Java虚拟机，类库和各种配置数据定义。本课程描述了应用程序用于检查和配置其平台环境的一些API。

[![Trail icon](https://docs.oracle.com/javase/tutorial/images/coreIcon.gif)**正则表达式**](https://docs.oracle.com/javase/tutorial/essential/regex/index.html) 是一种基于集合中每个字符串共享的共同特征来描述一组字符串的方法。它们可用于搜索，编辑或操作文本和数据。正则表达式的复杂程度各不相同，但是一旦理解了它们的构造基础，您就能够解密（或创建）任何正则表达式。本课程讲授`java.util.regex` API支持的正则表达式语法，并提供了几个示例来说明各种对象如何交互。

## 异常

Java 编程语言使用*exceptions*处理错误和其他意外事件。本章节描述何时及如何使用异常。

[什么是异常？](https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html)

异常是程序运行过程中发生的某种事件，该事件会干扰指令的正常执行流程。

[捕获或指定强制要求](https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html)

本章节涵盖如何捕获及处理异常。这种套路包含 `try`, `catch`, 和 `finally` 块，以及链式异常和日志记录。

[如何抛出异常](https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html)

本章节涵盖 `throw` 语句和 `Throwable` 类以及它的子类。

[`try-with-resources` 语句](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)

本节描述了`try-with-resources`语句，它是一个声明一个或多个资源的`try`语句。资源是一个对象，必须在程序完成后关闭它。`try-with-resources`语句确保在语句结束时关闭每个资源。

[未检查异常 - 争议](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html)

本章节解释由`RuntimeException`子类表示的未检查异常的正确和错误应用。

[异常的优势](https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html)

使用异常来管理错误相对于传统的错误管理技术具有一些优势。本章节中将介绍它们。

[小结](https://docs.oracle.com/javase/tutorial/essential/exceptions/summary.html)

### 什么是异常

术语*异常*是异常事件的简称。

------

**定义：** 异常是一个事件，在程序执行过程中产生，打乱程序指令的正常执行流程。

------

当方法中发生错误时，该方法会创建一个对象并将其交给运行时系统。该对象称为异常对象，包含有关错误的信息，包括错误发生时的类型和程序状态。创建异常对象并将其交给运行时系统称为抛出异常。

在方法抛出异常后，运行时系统会尝试查找要处理它的内容。处理异常的可能“某事”的集合是已被调用以获取发生错误的方法的有序方法列表。该方法列表称为调用堆栈（请参见下图）。

![The call stack showing three method calls, where the first method called has the exception handler.](https://docs.oracle.com/javase/tutorial/figures/essential/exceptions-callstack.gif)

运行时系统在调用堆栈中搜索包含可以处理异常的代码块的方法。这段代码称为异常处理程序。搜索从发生错误的方法开始，并按照调用方法的相反顺序通过调用堆栈。找到适当的处理程序后，运行时系统会将异常传递给处理程序。如果抛出的异常对象的类型与处理程序可以处理的类型匹配，则认为异常处理程序是合适的。

选择的异常处理程序被称为可以捕获异常。如果运行时系统穷举搜索调用堆栈上的所有方法而没有找到适当的异常处理程序，如下图所示，则运行时系统（以及程序）终止。

![The call stack showing three method calls, where the first method called has the exception handler.](https://docs.oracle.com/javase/tutorial/figures/essential/exceptions-errorOccurs.gif)

使用异常管理错误相对于传统错误管理更有优势，这些优势在 [异常的的优势](https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html) 章节中介绍。

### 捕获或指定强制要求

有效的Java编程语言代码必须遵守*捕获或指定强制要求*。这意味着可能抛出某些异常的代码必须包含以下任一项：

- 捕获异常的`try`语句。`try`必须为异常提供处理程序，如 [捕获和处理异常](https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html) 中所述。
- 一个方法，指定它可以抛出异常。该方法必须提供一个`throws`子句，列出异常，如 [指定方法引发的异常](https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html) 中所述。

不符合捕获或指定强制要求的代码将无法编译。

并非所有例外都受捕获或指定强制要求的约束。为了理解原因，我们需要查看三个基本类别的异常，其中只有一个受要求限制。

**三种异常**

第一种异常是*受检查的异常*。这些是编写良好的应用程序应该能够预期和从中恢复的特殊异常条件。例如，假设应用程序提示用户输入文件名，然后通过将名称传递给`java.io.FileReader`的构造函数来打开该文件。通常，用户提供现有可读文件的名称，因此`FileReader`对象构造成功，并且应用程序的执行正常进行。但有时用户提供不存在的文件的名称，构造函数抛出`java.io.FileNotFoundException`。一个编写良好的程序将捕获此异常并通知用户该错误，可能提示需要正确的文件名。

受检查的异常受捕获或者指定强制要求的约束。除`Error`，`RuntimeException`及其子类指示的异常外，所有异常都是受检查的异常。

第二种异常是*错误*。这些是应用程序外部的特殊异常条件，应用程序通常无法预测或从中恢复。例如，假设应用程序成功打开文件以进行输入，但由于硬件或系统故障而无法读取文件。不成功的读取将抛出`java.io.IOError`。应用程序可能会选择捕获此异常，以便通知用户该问题 - 但它也可能有助于程序打印堆栈跟踪并退出。

错误不受捕获或者指定强制要求的约束。错误是`Error`及其子类指示的异常。

第三种异常是*运行时异常*。这些是应用程序内部的异常条件，应用程序通常无法预测或从中恢复。这些通常表示编程错误，例如逻辑错误或 API 的不当使用。例如，考虑前面描述的应用程序将文件名传递给`FileReader`的构造函数。如果逻辑错误导致将`null`传递给构造函数，则构造函数将抛出`NullPointerException`。应用程序可以捕获此异常，但消除导致异常发生的错误可能更有意义。

运行时异常不受捕获或者指定强制要求的约束。运行时异常是`RuntimeException`及其子类指示的异常。

错误和运行时异常统称为不受检查的异常。

**绕过捕获或者指定强制要求**

一些程序员认为捕获或者指定强制要求是异常机制中的一个严重缺陷，并通过使用未经检查的异常代替已检查的异常来绕过它。通常，不建议这样做。[未经检查的异常 - 争议](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html) 部分讨论何时适合使用未经检查的异常。

### 捕获并处理异常

本节描述如何使用三个异常处理程序组件`try`，`catch`和`finally`块 - 来编写异常处理程序。然后，解释了Java SE 7中引入的`try-with-resources`语句。`try-with-resources`语句特别适合使用`Closeable`资源的情况，例如流。

本节的最后一部分将介绍一个示例，并分析各种场景中发生的情况。

以下示例定义并实现名为`ListOfNumbers`的类。构造时，`ListOfNumbers`创建一个`ArrayList`，其中包含10个整数元素，顺序值为 0 到 9 。`ListOfNumbers`类还定义了一个名为`writeList`的方法，该方法将数字列表写入一个名为`OutFile.txt` 的文本文件。此示例使用`java.io`中定义的输出类，这些类在 [基本 I / O](https://docs.oracle.com/javase/tutorial/essential/io/index.html) 中介绍。

```java
// Note: This class will not compile yet.
import java.io.*;
import java.util.List;
import java.util.ArrayList;

public class ListOfNumbers {

    private List<Integer> list;
    private static final int SIZE = 10;

    public ListOfNumbers () {
        list = new ArrayList<Integer>(SIZE);
        for (int i = 0; i < SIZE; i++) {
            list.add(new Integer(i));
        }
    }

    public void writeList() {
	// The FileWriter constructor throws IOException, which must be caught.
        PrintWriter out = new PrintWriter(new FileWriter("OutFile.txt"));

        for (int i = 0; i < SIZE; i++) {
            // The get(int) method throws IndexOutOfBoundsException, which must be caught.
            out.println("Value at: " + i + " = " + list.get(i));
        }
        out.close();
    }
}
```

粗体的第一行是对构造函数的调用。构造函数初始化文件上的输出流。如果无法打开文件，构造函数将抛出`IOException`。第二个粗体行是对`ArrayList`类的`get`方法的调用，如果其参数的值太小（小于0）或太大（大于`ArrayList`当前包含的元素的数量），则抛出`IndexOutOfBoundsException`。

如果您尝试编译[`ListOfNumbers`](https://docs.oracle.com/javase/tutorial/essential/exceptions/examples/ListOfNumbers.java)类，编译器将打印一条错误消息，关于由`FileWriter`构造函数抛出的异常。但是，它不会显示有关`get`抛出的异常的错误消息。原因是构造函数抛出的异常`IOException`是一个受检查的异常，而`get`方法抛出的异常是一个不受检查的异常。

现在您已经熟悉了`ListOfNumbers`类以及可以在其中抛出异常的位置，您已准备好编写异常处理程序来捕获和处理这些异常。

#### `try`语句块

构造异常处理器的第一步是把可能抛出异常的代码放进`try`语句块中。通常，一个`try`语句块如下：

```
try {
    code
}
catch and finally blocks . . .
```

示例中标记为*code*的段包含一个或多个可能引发异常的合法代码行。 （`catch`和`finally`块将在接下来的两个小节中解释。）

要从`ListOfNumbers`类构造`writeList`方法的异常处理程序，请将`tryList`方法的异常抛出语句包含在`tryblock`中。有不止一种方法可以做到这一点。您可以将可能引发异常的每行代码放在其单独的`try`块中，并为每个代码提供单独的异常处理程序。或者，您可以将所有`writeList`代码放在一个`try`块中，并将多个处理程序与它相关联。以下列表对整个方法使用一个`try`块，因为所讨论的代码非常短。

```java
private List<Integer> list;
private static final int SIZE = 10;

public void writeList() {
    PrintWriter out = null;
    try {
        System.out.println("Entered try statement");
        out = new PrintWriter(new FileWriter("OutFile.txt"));
        for (int i = 0; i < SIZE; i++) {
            out.println("Value at: " + i + " = " + list.get(i));
        }
    }
    catch and finally blocks  . . .
}
```

如果`try`块中的代码发生异常，则该异常就会被与之相关联的异常处理器处理。为了将异常处理器关联到`try`块，你必须将一个`catch`块放在其后。下一节 [`catch` 块](https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html) 中详细介绍。

#### `catch`语句块

通过在`try`块之后直接提供一个或多个`catch`块，可以将异常处理程序与`try`块关联。`try`块的末尾和第一个`catch`块的开头之间没有代码。

```java
try {

} catch (ExceptionType name) {

} catch (ExceptionType name) {

}
```

每个`catch`块都是一个异常处理程序，它处理由其参数指示的异常类型。参数类型*ExceptionType*声明了处理程序可以处理的异常类型，并且必须是从`Throwable`类继承的类的名称。处理程序可以使用*name*引用异常。

`catch`块包含在调用异常处理程序时执行的代码。当处理程序是调用堆栈中的第一个处理程序时，运行时系统调用异常处理程序，其中*ExceptionType*与抛出的异常的类型匹配。如果抛出的对象可以合法地分配给异常处理程序的参数，则系统认为它是匹配的。

以下是`writeList`方法的两个异常处理程序：

```java
try {

} catch (IndexOutOfBoundsException e) {
    System.err.println("IndexOutOfBoundsException: " + e.getMessage());
} catch (IOException e) {
    System.err.println("Caught IOException: " + e.getMessage());
}
```

异常处理程序不仅可以打印错误消息或停止程序，它们还可以执行错误恢复，提示用户做出决定，或使用链式异常将错误传播到更高级别的处理程序，如 [链式异常](https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html) 部分所述。

**一个异常处理器捕获多个类型的异常**

在Java SE 7及更高版本中，单个`catch`块可以处理多种类型的异常。此功能可以减少代码重复并减少捕获过于宽泛的异常的诱惑。

在`catch`子句中，指定块可以处理的异常类型，并使用竖线`|`分隔每个异常类型：

```java
catch (IOException|SQLException ex) {
    logger.log(ex);
    throw ex;
}
```

**注意：**如果`catch`块处理多个异常类型，则`catch`参数隐式为`final`的。在此示例中，`catch`参数`ex`是`final`的，因此您无法在`catch`块中为其分配任何值。

#### `final` 语句块

当`try`块退出时，`finally`块总是执行。这确保即使发生意外异常也会执行`finally`块。但最终不仅仅是异常处理有用 - 它允许程序员避免因返回，继续或中断而意外绕过清理代码。将清理代码放在`finally`块中始终是一种很好的做法，即使没有预期的例外情况也是如此。

------

**注意：**如果在执行`try`或`catch`代码时 JVM 退出，则`finally`块可能无法执行。同样，如果执行`try`或`catch`代码的线程被中断或终止，则即使应用程序作为一个整体继续，`finally`块也可能不会执行。

------

您在此处使用的`writeList`方法的`try`块打开了`PrintWriter`。程序应该在退出`writeList`方法之前关闭该流。这带来了一个有点复杂的问题，因为`writeList`的`try`块可以以三种方式之一退出。

1. `new FileWriter`语句失败并抛出`IOException`。
2. `list.get(i)`语句失败并抛出`IndexOutOfBoundsException`。
3. 一切都成功，`try`块正常退出。

无论`try`块中发生了什么，运行时系统总是执行`finally`块中的语句。所以这是进行清理的最佳位置。

下面的`writeList`方法的`finally`块清理然后关闭`PrintWriter`。

```java
finally {
    if (out != null) { 
        System.out.println("Closing PrintWriter");
        out.close(); 
    } else { 
        System.out.println("PrintWriter not open");
    } 
}
```

------

**重要提示：**`finally`块是防止资源泄漏的关键工具。关闭文件或以其他方式恢复资源时，将代码放在`finally`块中以确保始终恢复资源。

请考虑在这些情况下使用`try-with-resources`语句，这会在不再需要时自动释放系统资源。[try-with-resources](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) 语句部分提供了更多信息。

------

#### `try-with-resources` 语句

`try-with-resources`语句是一个声明一个或多个资源的`try`语句。*资源*是一个在程序完成后必须关闭的对象。`try-with-resources`语句确保在语句结束时关闭每个资源。任何实现`java.lang.AutoCloseable`的对象（包括实现`java.io.Closeable`的所有对象）都可以用作资源。

以下示例从文件中读取第一行。它使用`BufferedReader`实例从文件中读取数据。`BufferedReader`是一个在程序完成后必须关闭的资源：

```java
static String readFirstLineFromFile(String path) throws IOException {
    try (BufferedReader br =
                   new BufferedReader(new FileReader(path))) {
        return br.readLine();
    }
}
```

在此示例中，在`try-with-resources`语句中声明的资源是`BufferedReader`。声明语句出现在`try`关键字后面的括号内。Java SE 7及更高版本中的类`BufferedReader`实现了接口`java.lang.AutoCloseable`。因为`BufferedReader`实例是在`try-with-resource`语句中声明的，所以无论`try`语句是正常还是意外结束（由于方法`BufferedReader.readLine`抛出一个异常`IOException`），它都会被关闭。

在Java SE 7之前，您可以使用`finally`块来确保资源被关闭，无论`try` 语句是正常还是意外结束。以下示例使用`finally`块而不是`try-with-resources`语句：

```java
static String readFirstLineFromFileWithFinallyBlock(String path)
                                                     throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(path));
    try {
        return br.readLine();
    } finally {
        if (br != null) br.close();
    }
}
```

但是，在这个例子中，如果方法`readLine`和`close`都抛出异常，那么方法`readFirstLineFromFileWithFinallyBlock`会抛出`finally`块抛出的异常；而从`try`块抛出的异常被抑制。相反，在示例`readFirstLineFromFile`中，如果从`try`块和`try-with-resources`语句抛出异常，则方法`readFirstLineFromFile`抛出从`try`块抛出的异常；而从`try-with-resources`块抛出的异常被抑制。在Java SE 7及更高版本中，您可以检索已抑制的异常。有关详细信息，请参阅 [Suppressed Exceptions](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html#suppressed-exceptions) 部分。

您可以在`try-with-resources`语句中声明一个或多个资源。以下示例检索`zip`文件`zipFileName`中打包的文件的名称，并创建包含这些文件名称的文本文件：

```java
public static void writeToFileZipFileContents(String zipFileName,
                                           String outputFileName)
                                           throws java.io.IOException {

    java.nio.charset.Charset charset =
         java.nio.charset.StandardCharsets.US_ASCII;
    java.nio.file.Path outputFilePath =
         java.nio.file.Paths.get(outputFileName);

    // Open zip file and create output file with 
    // try-with-resources statement

    try (
        java.util.zip.ZipFile zf =
             new java.util.zip.ZipFile(zipFileName);
        java.io.BufferedWriter writer = 
            java.nio.file.Files.newBufferedWriter(outputFilePath, charset)
    ) {
        // Enumerate each entry
        for (java.util.Enumeration entries =
                                zf.entries(); entries.hasMoreElements();) {
            // Get the entry name and write it to the output file
            String newLine = System.getProperty("line.separator");
            String zipEntryName =
                 ((java.util.zip.ZipEntry)entries.nextElement()).getName() +
                 newLine;
            writer.write(zipEntryName, 0, zipEntryName.length());
        }
    }
}
```

在这个例子中，`try-with-resources`语句包含两个由分号分隔的声明：`ZipFile`和`BufferedWriter`。当直接跟随它的代码块正常或由于异常而终止时，`BufferedWriter`和`ZipFile`对象的`close`方法将按此顺序自动调用。请注意，资源的“close”方法是在它们创建的*相反*顺序中调用的。

以下示例使用`try-with-resources`语句自动关闭`java.sql.Statement`对象：

```java
public static void viewTable(Connection con) throws SQLException {

    String query = "select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES";

    try (Statement stmt = con.createStatement()) {
        ResultSet rs = stmt.executeQuery(query);

        while (rs.next()) {
            String coffeeName = rs.getString("COF_NAME");
            int supplierID = rs.getInt("SUP_ID");
            float price = rs.getFloat("PRICE");
            int sales = rs.getInt("SALES");
            int total = rs.getInt("TOTAL");

            System.out.println(coffeeName + ", " + supplierID + ", " + 
                               price + ", " + sales + ", " + total);
        }
    } catch (SQLException e) {
        JDBCTutorialUtilities.printSQLException(e);
    }
}
```

此示例中使用的资源`java.sql.Statement`是 JDBC 4.1 及更高版本 API 的一部分。

**注意：** `try-with-resources`语句可以像普通的`try`语句一样使用`catch`和`finally`块。在`try-with-resources`语句中，任何`catch`或`finally`块在声明的资源关闭后运行。

**被抑制的异常**

可以从与`try-with-resources`语句关联的代码块中抛出异常。在示例`writeToFileZipFileContents`中，可以从`try`块抛出异常，当`try-with-resources`语句尝试关闭`ZipFile`和`BufferedWriter`时，最多可以抛出两个异常对象。 如果从`try`块抛出异常并且从`try-with-resources`语句抛出一个或多个异常，那么从`try-with-resources`语句抛出的那些异常将被抑制，并抛由`writeToFileZipFileContents`方法中的异常代码块抛出的异常。您可以通过从`try`块抛出的异常中调用`Throwable.getSuppressed`方法来检索这些被抑制的异常。

**实现`AutoCloseable`或`Closeable`接口的类**

请参阅[`AutoCloseable`](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html) 和 [`Closeable`](https:// docs.oracle.com/javase/8/docs/api/java/io/Closeable.html) 接口的Javadoc，其中包含实现这些接口之一的类列表。`Closeable`接口扩展了`AutoCloseable`接口。 `Closeable` 接口的`close`方法抛出类型为`IOException`的异常，而`AutoCloseable`接口的`close`方法抛出类型为`Exception`的异常。因此，`AutoCloseable`接口的子类可以覆盖`close`方法的这种行为，以抛出专门的异常，例如`IOException`，或者根本没有异常。

#### 把它们放在一起

前面的章节描述了如何为`ListOfNumbers`类中的`writeList`方法构造`try`，`catch`和`finally`代码块。现在，让我们来看看代码并研究会发生什么。

当所有组件放在一起时，`writeList`方法如下所示。

```java
public void writeList() {
    PrintWriter out = null;

    try {
        System.out.println("Entering" + " try statement");

        out = new PrintWriter(new FileWriter("OutFile.txt"));
        for (int i = 0; i < SIZE; i++) {
            out.println("Value at: " + i + " = " + list.get(i));
        }
    } catch (IndexOutOfBoundsException e) {
        System.err.println("Caught IndexOutOfBoundsException: "
                           +  e.getMessage());
                                 
    } catch (IOException e) {
        System.err.println("Caught IOException: " +  e.getMessage());
                                 
    } finally {
        if (out != null) {
            System.out.println("Closing PrintWriter");
            out.close();
        } 
        else {
            System.out.println("PrintWriter not open");
        }
    }
}
```

如前所述，这个方法的`try`块有三种不同的退出可能性，下面是其中两个：

1. `try`语句中的代码失败并抛出异常。这可能是由`new FileWriter`语句引起的`IOException`或由`for`循环中的错误索引值引起的`IndexOutOfBoundsException`。
2. 一切都成功，`try`语句正常退出。

让我们看一下在这两种退出可能性期间`writeList`方法会发生什么。

**场景1: 发生异常**

创建`FileWriter`的语句可能由于多种原因而失败。例如，如果程序无法创建或写入指定的文件，则`FileWriter`的构造函数将抛出`IOException`。

当`FileWriter`抛出`IOException`时，运行时系统立即停止执行`try`块；正在执行的方法调用未完成。然后，运行时系统开始在方法调用堆栈的顶部搜索适当的异常处理程序。在这个例子中，当发生`IOException`时，`FileWriter`构造函数位于调用堆栈的顶部。但是，`FileWriter`构造函数没有适当的异常处理程序，因此运行时系统在方法调用堆栈中检查下一个方法 - `writeList`方法。 `writeList`方法有两个异常处理程序：一个用于`IOException`，另一个用于`IndexOutOfBoundsException`。

运行时系统按照`try`语句之后出现的顺序检查`writeList`的处理程序。第一个异常处理程序的参数是`IndexOutOfBoundsException`。这与抛出的异常类型不匹配，因此运行时系统会检查下一个异常处理程序 - `IOException`。这与抛出的异常类型相匹配，因此运行时系统结束搜索适当的异常处理程序。既然运行时已经找到了一个合适的处理程序，那么执行`catch`块中的代码。

异常处理程序执行后，运行时系统将控制权传递给`finally`块。无论上面捕获的异常如何，`finally`块中的代码都会执行。在这种情况下，`FileWriter`从未打开过，不需要关闭。在`finally`块完成执行后，程序继续执行`finally`块之后的第一个语句。

这是`ListOfNumbers`程序的完整输出，当抛出`IOException`时出现。

```
Entering try statement
Caught IOException: OutFile.txt
PrintWriter not open 
```

以下清单中的粗体代码显示了在此场景中执行的语句：

```java
public void writeList() {
   PrintWriter out = null;

    try {
        System.out.println("Entering try statement");
        out = new PrintWriter(new FileWriter("OutFile.txt"));
        for (int i = 0; i < SIZE; i++)
            out.println("Value at: " + i + " = " + list.get(i));
                               
    } catch (IndexOutOfBoundsException e) {
        System.err.println("Caught IndexOutOfBoundsException: "
                           + e.getMessage());
                                 
    } catch (IOException e) {
        System.err.println("Caught IOException: " + e.getMessage());
    } finally {
        if (out != null) {
            System.out.println("Closing PrintWriter");
            out.close();
        } 
        else {
            System.out.println("PrintWriter not open");
        }
    }
}
```

**场景2: `try`语句块正常退出**

在这种情况下，`try`块范围内的所有语句都成功执行，并且不会抛出异常。执行从`try`块的末尾开始，运行时系统将控制传递给`finally`块。 因为一切都很成功，所以当控件到达`finally`块时，`PrintWriter`就是打开状态的，此时就会关闭`PrintWriter`。 同样，在`finally`块完成执行后，程序继续执行`finally`块之后的第一个语句。

当没有抛出异常时，这是`ListOfNumbers`程序的输出。

```
Entering try statement
Closing PrintWriter
```

以下示例中的粗体代码显示了在此场景中执行的语句。

```java
public void writeList() {
    PrintWriter out = null;
    try {
        System.out.println("Entering try statement");
        out = new PrintWriter(new FileWriter("OutFile.txt"));
        for (int i = 0; i < SIZE; i++)
            out.println("Value at: " + i + " = " + list.get(i));
                  
    } catch (IndexOutOfBoundsException e) {
        System.err.println("Caught IndexOutOfBoundsException: "
                           + e.getMessage());

    } catch (IOException e) {
        System.err.println("Caught IOException: " + e.getMessage());
                                 
    } finally {
        if (out != null) {
            System.out.println("Closing PrintWriter");
            out.close();
        } 
        else {
            System.out.println("PrintWriter not open");
        }
    }
}
```

### 指定方法产生的异常

上一节展示了如何在`ListOfNumbers`类中为`writeList`方法编写异常处理程序。有时，代码可以捕获可能在其中发生的异常。但是，在其他情况下，最好让调用堆栈中的方法进一步处理异常。例如，如果您将`ListOfNumbers`类作为类包的一部分提供，则可能无法预测包的所有用户的需求。在这种情况下，最好不要捕获异常而使允许进一步调用堆栈的方法来处理它。

如果`writeList`方法没有捕获可能在其中发生的受检查异常，则`writeList`方法必须指定它可以抛出这些异常。让我们修改原始的`writeList`方法来指定它可以抛出的异常。提醒您，这是不能编译的`writeList`方法的原始版本。

```java
public void writeList() {
    PrintWriter out = new PrintWriter(new FileWriter("OutFile.txt"));
    for (int i = 0; i < SIZE; i++) {
        out.println("Value at: " + i + " = " + list.get(i));
    }
    out.close();
}
```

要指定`writeList`可以抛出两个异常，请将`throws`子句添加到`writeList`方法的方法声明中。 `throws`子句包含`throws`关键字，后跟逗号分隔的该方法抛出的所有异常列表。该子句在方法名称和参数列表之后以及定义方法主体的大括号之前。下面是一个例子。

```java
public void writeList() throws IOException, IndexOutOfBoundsException {
```

请记住，`IndexOutOfBoundsException`是一个不受检查的异常；在`throws`子句中包含它不是强制性的。你可以写下面的内容。

```java
public void writeList() throws IOException {
```

### 如何抛出异常

在捕获异常之前，某些代码必须抛出一个异常。任何代码都可以抛出异常：您的代码，来自其他人编写的包中的代码，例如Java平台附带的包或Java运行时环境。无论什么抛出异常，它总是通过`throw`语句抛出。

您可能已经注意到，Java平台提供了许多异常类。所有类都是[`Throwable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html) 类的后代，所有类都允许程序区分各种类在程序执行期间可能发生的异常类型。

您还可以创建自己的异常类来表示您编写的类中可能出现的问题。实际上，如果您是程序包开发人员，则可能必须创建自己的一组异常类，以允许用户将程序包中可能发生的错误与Java平台或其他程序包中发生的错误区分开来。

您还可以创建*链式*异常。有关更多信息，请参阅 [链式异常](https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html) 部分。

**`throw` 语句**

所有方法都使用`throw`语句来抛出异常。 `throw`语句需要一个参数：一个throwable对象。 Throwable对象是`Throwable`类的任何子类的实例。 这是一个`throw`语句的例子：

```java
throw someThrowableObject;
```

让我们看一下上下文中的`throw`语句。以下`pop`方法取自实现公共堆栈对象的类。该方法从堆栈中删除顶部元素并返回该对象。

```java
public Object pop() {
    Object obj;

    if (size == 0) {
        throw new EmptyStackException();
    }

    obj = objectAt(size - 1);
    setObjectAt(size - 1, null);
    size--;
    return obj;
}
```

`pop`方法检查堆栈中是否有任何元素。如果堆栈为空（其大小等于`0`），则`pop`实例化一个新的`EmptyStackException`对象（`java.util`的成员）并抛出它。本章中的 [创建异常类](https://docs.oracle.com/javase/tutorial/essential/exceptions/creating.html) 部分介绍了如何创建自己的异常类。现在，您需要记住的是，您只能抛出从`java.lang.Throwable`类继承的对象。

请注意，`pop`方法的声明不包含`throws`子句。 `EmptyStackException`不是一个受检查的异常，因此不需要`pop`来声明它可能发生。

**可抛出的类及其子类**

从`Throwable`类继承的对象包括直接后代（直接从`Throwable`类继承的对象）和间接后代（从`Throwable`类的子孙继承的对象）。下图说明了`Throwable`类的类层次结构及其最重要的子类。正如你所看到的，`Throwable`有两个直接的后代：[`Error`](https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html) 和 [`Exception`](https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html) 

![The Throwable class and its most significant subclasses.](https://docs.oracle.com/javase/tutorial/figures/essential/exceptions-throwable.gif)

可抛出类

**`Error` 类**

当发生 Java 虚拟机的动态链接故障或其他硬故障时，虚拟机会抛出 `Error` 。 简单的程序通常会*不*捕获或抛出`Error` 。

**`Exception` 类**

大多数程序抛出并捕获派生自`Exception`类的对象。`Exception` 表示发生了问题，但这不是一个严重的系统问题。你编写的大多数程序都会抛出并捕获`Exception` 而不是`Error` 。

Java平台定义了`Exception`类的许多后代。这些后代表示可能发生的各种类型的异常。例如，`IllegalAccessException`表示无法找到特定方法，而`NegativeArraySizeException`表示程序试图创建一个负大小的数组。

一个`Exception`子类，`RuntimeException`，保留用于指示错误使用API的异常。运行时异常的一个示例是`NullPointerException` ，当方法尝试通过`null`引用访问对象的成员时发生。 [不受检查的异常－争议](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html) 部分讨论了为什么大多数应用程序不应抛出运行时异常或子类`RuntimeException`。

#### 链式异常

应用程序通常会通过抛出另一个异常来响应异常。实际上，第一个异常*导致*第二个异常。知道一个异常何时导致另一个异常非常有用。*链接异常*帮助程序员执行此操作。

以下是`Throwable`中支持链式异常的方法和构造函数。

```java
Throwable getCause()
Throwable initCause(Throwable)
Throwable(String, Throwable)
Throwable(Throwable)
```

`initCause`和`Throwable`构造函数的`Throwable`参数是导致当前异常的异常。 `getCause`返回导致当前异常的异常，`initCause`设置当前异常的原因。

以下示例显示如何使用链式异常。

```java
try {

} catch (IOException e) {
    throw new SampleException("Other IOException", e);
}
```

在此示例中，当捕获`IOException`时，将创建一个新的`SampleException`异常，并附加原始原因，并将异常链抛出到下一个更高级别的异常处理程序。

**访问堆栈轨迹信息**

现在让我们假设更高级别的异常处理程序想要以自己的格式转储堆栈跟踪信息。

------

**定义：** 堆栈跟踪提供有关当前线程的执行历史记录的信息，并列出在发生异常时调用的类和方法的名称。堆栈跟踪是一种有用的调试工具，通常在抛出异常时可以利用它。

------

以下代码显示如何在异常对象上调用`getStackTrace`方法。

```java
catch (Exception cause) {
    StackTraceElement elements[] = cause.getStackTrace();
    for (int i = 0, n = elements.length; i < n; i++) {       
        System.err.println(elements[i].getFileName()
            + ":" + elements[i].getLineNumber() 
            + ">> "
            + elements[i].getMethodName() + "()");
    }
}
```

**日志 API**

下一个代码片段记录了`catch`块中发生异常的位置。但是，它不是手动解析堆栈跟踪并将输出发送到`System.err()`，而是使用[`java.util.logging`](https：// docs .oracle.com / javase / 8 / docs / api / java / util / logging / package-summary.html) 包中的日志工具将输出发送到文件。

```java
try {
    Handler handler = new FileHandler("OutFile.log");
    Logger.getLogger("").addHandler(handler);
    
} catch (IOException e) {
    Logger logger = Logger.getLogger("package.name"); 
    StackTraceElement elements[] = e.getStackTrace();
    for (int i = 0, n = elements.length; i < n; i++) {
        logger.log(Level.WARNING, elements[i].getMethodName());
    }
}
```

#### 创建异常类

当面对选择要抛出的异常类型时，您可以使用其他人编写的异常 -  Java平台提供了许多可以使用的异常类 - 或者您可以编写自己的异常类。如果您对以下任何问题的回答是肯定的，您应该编写自己的异常类；否则，你可能会使用别人的。

- 您是否需要Java平台中未提供的异常类型？
- 它是否可以帮助用户将他们的异常与其他供应商编写的类别所引发的异常区分开来？
- 您的代码是否会抛出多个相关异常？
- 如果您使用其他人的异常，用户是否可以访问这些异常？ 一个类似的问题是，你的包是否是独立且自包含的？

**例子**

假设您正在编写链表类。该类支持以下方法，其中包括：

- **objectAt (int n)**  - 返回列表中第n个位置的对象。如果参数小于0或大于列表中当前对象的数量，则引发异常。
- **firstObject ()**  - 返回列表中的第一个对象。如果列表不包含任何对象，则抛出异常。
- **indexOf (Object o)**  - 在列表中搜索指定的`Object`并返回其在列表中的位置。如果传递给方法的对象不在列表中，则抛出异常。

链表类可以抛出多个异常，并且能够通过一个异常处理程序捕获链表所引发的所有异常是很方便的。此外，如果您计划在包中分发链接列表，则应将所有相关代码打包在一起。因此，链表应该提供自己的一组异常类。

下图说明了链接列表抛出的异常的一个可能的类层次结构。

![A possible class hierarchy for the exceptions thrown by a linked list.](https://docs.oracle.com/javase/tutorial/figures/essential/exceptions-hierarchy.gif)

**选择一个超类**

任何`Exception`子类都可以用作`LinkedListException`的父类。但是，快速浏览这些子类表明它们不合适，因为它们太专用或者与`LinkedListException`完全无关。因此，`LinkedListException`的父类应该是`Exception`。

您编写的大多数`applet`和应用程序都会抛出`Exception`的对象。`Error`通常用于系统中严重的硬错误，例如阻止JVM运行的错误。

------

**注意：** 对于可读代码，最好将字符串`Exception`附加到从`Exception`类继承（直接或间接）的所有类的名称中。

------

### 不受检查异常－争议

由于Java编程语言的方法不需要捕获或指定不受检查的异常（`RuntimeException`，`Error`及其子类），因此程序员可能会编写仅抛出不受检查的异常或使其所有异常子类继承自`RuntimeException`的代码。这两个便捷的方式都允许程序员编写代码而不必担心编译器错误，也不必费心去指定或捕获任何异常。虽然这对程序员来说似乎很方便，但它会回避`catch`的意图或`specify`强制需求的初衷，并且可能会导致其他人使用您的类时出现问题。

为什么设计者决定强制一个方法来指定可以在其范围内抛出的所有未捕获的受检查异常？方法抛出的任何异常都是方法的公共编程接口的一部分。那些调用方法的人必须知道方法可能抛出的异常，以便他们可以决定如何处理它们。这些异常与该方法的编程接口一样，也是其参数和返回值的一部分。

下一个问题可能是：“如果记录方法的API非常好，包括它可以抛出的异常，为什么不指定运行时异常呢？”运行时异常表示编程问题导致的问题，因此，无法合理地期望API客户端代码从它们恢复或以任何方式处理它们。这些问题包括算术异常，例如除以零；指针异常，例如尝试通过空引用访问对象；和索引异常，例如尝试通过太大或太小的索引来访问数组元素。

运行时异常可以在程序中的任何地方发生，而在典型的程序中，它们可以非常多。必须在每个方法声明中添加运行时异常会降低程序的清晰度。因此，编译器不要求您捕获或指定运行时异常（尽管您可以）。

抛出`RuntimeException`的常见做法之一是用户错误地调用方法。例如，方法可以检查其中一个参数是否错误地为`null`。如果参数为`null`，则该方法可能会抛出`NullPointerException`，这是一个不受检查的异常。

一般来说，不要抛出`RuntimeException`或创建`RuntimeException`的子类，如果您不希望因为指定方法可以抛出的异常而烦恼。

这是底线指南：如果可以合理地期望客户端从异常中恢复，则将其作为受检查的异常。如果客户端无法执行任何操作以从异常中恢复，请将其设置为不受检查的异常。

### 异常的优势

现在您已经知道了什么是异常以及如何使用它们，现在是时候了解在程序中使用异常的优势了。

**优点1：将错误处理代码与“常规”代码分开**

异常提供了一种方法，可以在程序的主要逻辑中分离出异常情况时要执行的操作的详细信息。在传统的编程中，错误检测，报告和处理通常会导致混乱的意大利面条式的代码。例如，考虑这里的伪代码方法将整个文件读入内存。

```
readFile {
    open the file;
    determine its size;
    allocate that much memory;
    read the file into memory;
    close the file;
}
```

乍一看，这个功能似乎很简单，但它忽略了以下所有潜在的错误。

- 如果无法打开文件会怎么样？
- 如果无法确定文件的长度会发生什么？
- 如果无法分配足够的内存会怎样？
- 如果读取失败会发生什么？
- 如果文件无法关闭会怎样？

要处理这种情况，`readFile`函数必须有更多的代码来进行错误检测，报告和处理。以下是函数的外观示例。

```java
errorCodeType readFile {
    initialize errorCode = 0;
    
    open the file;
    if (theFileIsOpen) {
        determine the length of the file;
        if (gotTheFileLength) {
            allocate that much memory;
            if (gotEnoughMemory) {
                read the file into memory;
                if (readFailed) {
                    errorCode = -1;
                }
            } else {
                errorCode = -2;
            }
        } else {
            errorCode = -3;
        }
        close the file;
        if (theFileDidntClose && errorCode == 0) {
            errorCode = -4;
        } else {
            errorCode = errorCode and -4;
        }
    } else {
        errorCode = -5;
    }
    return errorCode;
}
```

这里有很多错误检测，报告和返回，原始的七行代码在杂乱中丢失了。更糟糕的是，代码的逻辑流程也已丢失，因此很难判断代码是否正在做正确的事情：如果函数无法分配足够的内存，文件是否真的被关闭了？ 在编写方法三个月后修改方法时，确保代码继续做正确的事情变得更加困难。许多程序员通过忽略它来解决这个问题 - 当程序崩溃时会报告错误。

异常使您可以编写代码的主要流程并在其他地方处理异常情况。如果`readFile`函数使用异常而不是传统的错误管理技术，它看起来更像是下面的样子：

```java
readFile {
    try {
        open the file;
        determine its size;
        allocate that much memory;
        read the file into memory;
        close the file;
    } catch (fileOpenFailed) {
       doSomething;
    } catch (sizeDeterminationFailed) {
        doSomething;
    } catch (memoryAllocationFailed) {
        doSomething;
    } catch (readFailed) {
        doSomething;
    } catch (fileCloseFailed) {
        doSomething;
    }
}
```

请注意，异常不会使您无需执行检测，报告和处理错误的工作，但它们确实可以帮助您更有效地组织工作。

**优势2：在调用堆栈中传播错误**

异常的第二个优点是能够在方法的调用堆栈中传播错误报告。假设`readFile`方法是主程序进行的一系列嵌套方法调用中的第四种方法：`method1`调用`method2`，它调用`method3`，最后调用`readFile`。

```java
method1 {
    call method2;
}

method2 {
    call method3;
}

method3 {
    call readFile;
}
```

假设`method1`是唯一对`readFile`中可能出现的错误感兴趣的方法。传统的错误通知技术强制`method2`和`method3`将`readFile`返回的错误代码传播到调用堆栈，直到错误代码最终到达`method1`-唯一对它们感兴趣的方法。

```java
method1 {
    errorCodeType error;
    error = call method2;
    if (error)
        doErrorProcessing;
    else
        proceed;
}

errorCodeType method2 {
    errorCodeType error;
    error = call method3;
    if (error)
        return error;
    else
        proceed;
}

errorCodeType method3 {
    errorCodeType error;
    error = call readFile;
    if (error)
        return error;
    else
        proceed;
}
```

回想一下，Java运行时环境在调用堆栈中向后搜索，以查找对处理特定异常感兴趣的任何方法。一个方法可以躲避抛出到其中的任何异常，从而允许一个调用栈中更远的方法来捕获它。因此，只有关心错误的方法才需要注意检测错误。

```java
method1 {
    try {
        call method2;
    } catch (exception e) {
        doErrorProcessing;
    }
}

method2 throws exception {
    call method3;
}

method3 throws exception {
    call readFile;
}
```

但是，正如伪代码所示，躲避异常需要中间人方法的一些努力。必须在其`throws`子句中指定可以在方法中抛出的任何受检查异常。

**优势3：分组和区分错误类型**

因为在程序中抛出的所有异常都是对象，所以异常的分组或分类是类层次结构的自然结果。Java平台中的一组相关异常类的示例是在`java.io`-`IOException`及其后代中定义的那些。`IOException`是最常用的，表示执行I / O时可能发生的任何类型的错误。它的后代表示更具体的错误。例如，`FileNotFoundException`表示文件无法在磁盘上定位。

方法可以编写可以处理非常特定异常的特定处理程序。 `FileNotFoundException`类没有后代，因此以下处理程序只能处理一种类型的异常。

```java
catch (FileNotFoundException e) {
    ...
}
```

方法可以通过在`catch`语句中指定任何异常的超类来基于其组或常规类型捕获异常。例如，要捕获所有I / O异常，不管它们的具体类型如何，异常处理程序指定一个`IOException`参数就可以了。

```java
catch (IOException e) {
    ...
}
```

这个处理程序将能够捕获所有I / O异常，包括`FileNotFoundException`，`EOFException`等。您可以通过查询传递给异常处理程序的参数来查找有关所发生情况的详细信息。例如，使用以下命令打印堆栈跟踪：

```java
catch (IOException e) {
    // Output goes to System.err.
    e.printStackTrace();
    // Send trace to stdout.
    e.printStackTrace(System.out);
}
```

您甚至可以设置一个异常处理程序来处理任何`Exception`：

```java
// A (too) general exception handler
catch (Exception e) {
    ...
}
```

`Exception`类接近`Throwable`类层次结构的顶部。因此，除了处理程序要捕获的那些异常之外，此处理程序还将捕获许多其他异常。如果您希望程序执行所有操作，您可能希望以这种方式处理异常，例如，为用户打印出错误消息然后退出。

但是，在大多数情况下，您希望异常处理程序尽可能具体。原因是处理程序必须做的第一件事是确定在确定最佳恢复策略之前发生了什么类型的异常。实际上，通过不捕获特定错误，处理程序必须适应任何可能性。过于笼统的异常处理程序可能会因为捕获和处理程序员未预料到并且程序意图之外的异常而导致代码更容易出错。

如上所述，您可以创建异常组并以一般方式处理异常，或者您可以使用特定的异常类型来区分异常并以精确的方式处理异常。

### 小结

程序可以使用异常来指示发生了错误。要抛出异常，请使用`throw`语句并为其提供一个异常对象 -  `Throwable`的后代 - 以提供有关发生的特定错误的信息。抛出未捕获的受检查异常的方法必须在其声明中包含`throws`子句。

程序可以通过结合使用`try`，`catch`和`finally`块来捕获异常。

- `try`块标识可能发生异常的代码块。
- `catch`块标识一个代码块，称为异常处理程序，可以处理特定类型的异常。
- `finally`块标识了一个保证执行的代码块，并且是在`try`块中包含的代码之后关闭文件，恢复资源和清理的正确位置。

`try`语句应包含至少一个`catch`块或`finally`块，并且可能有多个`catch`块。

异常对象的类指示抛出的异常类型。异常对象可以包含有关错误的更多信息，包括错误消息。使用异常链时，异常可以指向导致异常的异常，异常又可以指向导致它的异常，依此类推。

## 基本I/O

本课程介绍用于基本I/O的Java平台类。它首先关注*I/O Streams*，这是一个强大的概念，可以大大简化I/O操作。本课程还介绍了序列化，它允许程序将整个对象写入流并再次读取它们。然后，本课将介绍文件I/O和文件系统操作，包括随机访问文件。

`I/O Streams`部分中涵盖的大多数类都在`java.io`包中。`File I/O`部分中涵盖的大多数类都在`java.nio.file`包中。

**[I/O Streams](https://docs.oracle.com/javase/tutorial/essential/io/streams.html)**

- [Byte Streams](https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html) 处理原始二进制数据的 I/O。
- [Character Streams](https://docs.oracle.com/javase/tutorial/essential/io/charstreams.html) 处理字符数据的I/O，自动处理与本地字符集的转换。
- [Buffered Streams](https://docs.oracle.com/javase/tutorial/essential/io/buffers.html) 通过减少对本机API的调用次数来优化输入和输出。
- [Scanning and Formatting](https://docs.oracle.com/javase/tutorial/essential/io/scanfor.html) 允许程序读取和写入格式化文本。
- [I/O from the Command Line](https://docs.oracle.com/javase/tutorial/essential/io/cl.html) 描述标准流和控制台对象。
- [Data Streams](https://docs.oracle.com/javase/tutorial/essential/io/datastreams.html) 处理原始数据类型的二进制I/O和`String`值。
- [Object Streams](https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html) 处理对象的二进制I/O。

**[File I/O (Featuring NIO.2)](https://docs.oracle.com/javase/tutorial/essential/io/fileio.html)**

- [What is a Path?](https://docs.oracle.com/javase/tutorial/essential/io/path.html) 检查文件系统中的文件路径的概念。
- [The Path Class](https://docs.oracle.com/javase/tutorial/essential/io/pathClass.html) 介绍了`java.nio.file`包的基石类。
- [Path Operations](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html) 查看`Path`类中处理语法操作的方法。
- [File Operations](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html) 介绍了许多文件I/O方法的共同概念。
- [Checking a File or Directory](https://docs.oracle.com/javase/tutorial/essential/io/check.html) 演示了如何检查文件的存在及其可访问性级别。
- [Deleting a File or Directory](https://docs.oracle.com/javase/tutorial/essential/io/delete.html).
- [Copying a File or Directory](https://docs.oracle.com/javase/tutorial/essential/io/copy.html).
- [Moving a File or Directory](https://docs.oracle.com/javase/tutorial/essential/io/move.html).
- [Managing Metadata](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) 解释如何读取和设置文件属性。
- [Reading, Writing and Creating Files](https://docs.oracle.com/javase/tutorial/essential/io/file.html) 显示用于读取和写入文件的流和通道方法。
- [Random Access Files](https://docs.oracle.com/javase/tutorial/essential/io/rafs.html) 演示了如何以非顺序方式读取或写入文件。
- [Creating and Reading Directories](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html) 涵盖了特定于目录的API，例如如何列出目录的内容。
- [Links, Symbolic or Otherwise](https://docs.oracle.com/javase/tutorial/essential/io/links.html) 涵盖了特定于符号和硬链接的问题。
- [Walking the File Tree](https://docs.oracle.com/javase/tutorial/essential/io/walk.html) 演示了如何递归访问文件树中的每个文件和目录。
- [Finding Files](https://docs.oracle.com/javase/tutorial/essential/io/find.html) 显示如何使用模式匹配搜索文件。
- [Watching a Directory for Changes](https://docs.oracle.com/javase/tutorial/essential/io/notification.html) 显示如何使用监视服务来检测在一个或多个目录中添加，删除或更新的文件。
- [Other Useful Methods](https://docs.oracle.com/javase/tutorial/essential/io/misc.html) 涵盖了本课程其他部分不适用的重要API。
- [Legacy File I/O Code](https://docs.oracle.com/javase/tutorial/essential/io/legacy.html) 展示了如果使用`java.io.File`类的旧代码，如何利用`Path`功能。提供了将`java.io.File` API映射到`java.nio.file` API的表。

**I/O 类实战**

 [自定义网络](https://docs.oracle.com/javase/tutorial/networking/index.html) 中的许多示例使用本课程中描述的I/O流来通过网络连接读取和写入数据。

------

**安全考虑：** 某些I/O操作需要得到当前安全经理的批准。 这些课程中包含的示例程序是独立应用程序，默认情况下没有安全管理器。要在`applet`中工作，大多数这些示例都必须进行修改。有关安装在`applet`上的安全限制的信息，请参阅 [哪些Applet可以执行](https://docs.oracle.com/javase/tutorial/deployment/applet/security.html) 。

------

### I/O Streams

*I/O流*表示输入源或输出目的地。流可以表示许多不同类型的源和目标，包括磁盘文件，设备，其他程序和内存数组。

流支持许多不同类型的数据，包括简单字节，原始数据类型，本地化字符和对象。有些流只是简单地传递数据，其他流则以有用的方式操纵和转换数据。

无论它们在内部如何工作，所有流都为使用它们的程序提供相同的简单模型：流是一系列数据。程序使用*输入流*从源读取数据，一次读取一个元素：

![Reading information into a program.](https://docs.oracle.com/javase/tutorial/figures/essential/io-ins.gif)

读取信息到程序中。

程序使用*输出流*将数据写入目标，一次一个元素：

![Writing information from a program.](https://docs.oracle.com/javase/tutorial/figures/essential/io-outs.gif)

从程序写出信息。

在本节中，我们将看到可以处理各种数据的流，从原始值到高级对象。

上图所示的数据源和数据目的地可以是保存，生成或使用数据的任何东西。显然这包括磁盘文件，但源或目标也可以是另一个程序，外围设备，网络套接字或数组对象。

在下一节中，我们将使用最基本的流类型字节流来演示流I/O的常见操作。对于示例输入，我们将使用示例文件 [`xanadu.txt`](https://docs.oracle.com/javase/tutorial/essential/io/examples/xanadu.txt) ，其中包含以下内容：

```
In Xanadu did Kubla Khan
A stately pleasure-dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.
```

#### Byte Streams

程序使用*字节流*来执行8位字节的输入和输出。所有字节流类都来自[`InputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html) 和 [`OutputStream`](https：//docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html) 。

有许多字节流类。为了演示字节流的工作原理，我们将重点关注文件I/O字节流，[`FileInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html) 和 [`FileOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/FileOutputStream.html) 。其他种类的字节流的使用方式大致相同；它们的不同之处主要在于它们的构造方式。

**使用 Byte Streams**

我们将通过检查一个名为[`CopyBytes`](https://docs.oracle.com/javase/tutorial/essential/io/examples/CopyBytes.java) 的示例程序来探索`FileInputStream`和`FileOutputStream`。字节流复制`xanadu.txt`，一次一个字节。

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
    public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("xanadu.txt");
            out = new FileOutputStream("outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}
```

`CopyBytes`大部分时间都消耗在一个简单的循环中，它读取输入流并一次写入一个字节的输出流，如下图所示。

![Simple byte stream input and output.](https://docs.oracle.com/javase/tutorial/figures/essential/byteStream.gif)

简单字节流输入输出。

**永远记住要关闭流**

在不再需要流时关闭流非常重要 - 同样重要的是`CopyBytes`使用`finally`块来保证即使发生错误也会关闭两个流。这种做法有助于避免严重的资源泄漏。

一个可能的错误是`CopyBytes`无法打开一个或两个文件。当发生这种情况时，对应于该文件的流变量永远不会从其初始的`null`值改变。这就是为什么`CopyBytes`在调用`close`之前需要确保每个流变量都包含一个对象引用。

**何时不使用字节流**

`CopyBytes`看起来像一个普通的程序，但它实际上代表了一种你应该避免的低级I/O. 由于`xanadu.txt`包含字符数据，最好的方法是使用[字符流](https://docs.oracle.com/javase/tutorial/essential/io/charstreams.html) ，如下一节所述。还有用于更复杂数据类型的流。字节流应仅用于最原始的I/O。

那么为什么要谈论字节流呢？因为所有其他流类型都是基于字节流构建的。

#### Character Streams

Java平台使用Unicode编码存储字符值。字符流I/O自动将此内部格式转换为本地字符集。在西文语言环境中，本地字符集通常是ASCII码的8位超集。

对于大多数应用程序，使用字符流的I/O并不比使用字节流的I/O复杂。使用流类完成的输入和输出会自动转换为本地字符集和从本地字符集转换。使用字符流代替字节流的程序会自动适应本地字符集，并且可以进行国际化 - 所有这些都不需要程序员的额外工作。

如果国际化不是优先考虑事项，您可以简单地使用字符流类而不必过多关注字符集问题。之后，如果国际化成为优先事项，您的程序可以进行调整而无需进行大量重新编码。更多信息，请参阅 [国际化](https://docs.oracle.com/javase/tutorial/i18n/index.html) 。

**使用 Character Streams**

所有字符流类都来自 [`Reader`](https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html) 和 [`Writer`](https://docs.oracle.com/javase/8/docs/api/java/io/Writer.html) 。 与字节流一样，还有专门用于文件I/O的字符流类： [`FileReader`](https://docs.oracle.com/javase/8/docs/api/java/io/FileReader.html) 和 [`FileWriter`](https://docs.oracle.com/javase/8/docs/api/java/io/FileWriter.html) 。  [`CopyCharacters`](https://docs.oracle.com/javase/tutorial/essential/io/examples/CopyCharacters.java) 示例说明了这些类。

```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CopyCharacters {
    public static void main(String[] args) throws IOException {

        FileReader inputStream = null;
        FileWriter outputStream = null;

        try {
            inputStream = new FileReader("xanadu.txt");
            outputStream = new FileWriter("characteroutput.txt");

            int c;
            while ((c = inputStream.read()) != -1) {
                outputStream.write(c);
            }
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
}
```

`CopyCharacters`与`CopyBytes`非常相似。最重要的区别是`CopyCharacters`使用`FileReader`和`FileWriter`来代替`FileInputStream`和`FileOutputStream`进行输入和输出。请注意，`CopyBytes`和`CopyCharacters`都使用`int`变量来读取和写入。但是，在`CopyCharacters`中，`int`变量在其最后16位中保存一个字符值；在`CopyBytes`中，`int`变量在其最后8位中保存一个字节值。

**使用字节流的字符流**

字符流通常是字节流的“包装器”。字符流使用字节流来执行物理I/O，而字符流处理字符和字节之间的转换。例如，`FileReader`使用`FileInputStream`，而`FileWriter`使用`FileOutputStream`。

有两个通用的字节到字符“桥接”流：[`InputStreamReader`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStreamReader.html) 和 [`OutputStreamWriter`](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStreamWriter.html)。当没有符合您需求的预打包字符流类时，使用它们来创建字符流。 [网络课程](https://docs.oracle.com/javase/tutorial/networking/index.html) 中的 [sockets](https://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html) 显示了如何从套接字类提供的字节流创建字符流。

**面向行的 I/O **

字符I/O通常以比单个字符更大的单位出现。 一个常见的单位是行：一串字符，末尾有一个行终止符。行终止符可以是回车/换行序列（`\r\n`），单个回车符（`\r`）或单个换行符（`\n`）。支持所有可能的行终止符允许程序读取在任何广泛使用的操作系统上创建的文本文件。

让我们修改`CopyCharacters`示例以使用面向行的I/O。为此，我们必须使用两个我们以前从未见过的类， [`BufferedReader`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html) 和 [`PrintWriter`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html)。我们将在 [Buffered I/O](https://docs.oracle.com/javase/tutorial/essential/io/buffers.html) 和 [Formatting](https://docs.oracle.com/javase/tutorial/essential/io/formatting.html) 中更深入地探索这些类。现在，我们只对他们对面向行的I/O的支持感兴趣。

`CopyLines`示例调用`BufferedReader.readLine`和`PrintWriter.println`来一次输入和输出一行。

```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.IOException;

public class CopyLines {
    public static void main(String[] args) throws IOException {

        BufferedReader inputStream = null;
        PrintWriter outputStream = null;

        try {
            inputStream = new BufferedReader(new FileReader("xanadu.txt"));
            outputStream = new PrintWriter(new FileWriter("characteroutput.txt"));

            String l;
            while ((l = inputStream.readLine()) != null) {
                outputStream.println(l);
            }
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
}
```

调用`readLine`会返回一行文本。`CopyLines`使用`println`输出每一行，`println`附加当前操作系统的行终止符。这可能与输入文件中使用的行终止符不同。

构造文本输入和输出的方法有很多种，不仅限于字符和行。有关更多信息，请参阅 [扫描和格式化](https://docs.oracle.com/javase/tutorial/essential/io/scanfor.html) 。

#### Buffered Streams

到目前为止，我们看到的大多数示例都使用无缓冲的I/O，这意味着每个读取或写入请求都由底层操作系统直接处理。这可以使程序效率低得多，因为每个这样的请求经常触发磁盘访问，网络活动或一些相对昂贵的其他操作。

为了减少这种开销，Java平台实现了带缓冲的I/O流。缓冲输入流从称为缓冲区的存储区读取数据；仅当缓冲区为空时才调用本机输入API。类似地，缓冲输出流将数据写入缓冲区，并且仅在缓冲区已满时才调用本机输出API。

程序可以使用我们现在多次使用的包装习惯用法将无缓冲的流转换为缓冲流，其中无缓冲的流对象被传递给缓冲流类的构造函数。 以下是如何修改`CopyCharacters`示例中的构造函数调用以使用缓冲I/O：

```java
inputStream = new BufferedReader(new FileReader("xanadu.txt"));
outputStream = new BufferedWriter(new FileWriter("characteroutput.txt"));
```

有四个用于包装无缓冲流的缓冲流类： [`BufferedInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html) 和 [`BufferedOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html) 创建缓冲字节流，[`BufferedReader`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html) 和 [`BufferedWriter`](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html) 创建缓冲字符流。

**刷新 Buffered Streams**

在关键时刻从缓冲区提取数据通常是有意义的，而无需等待它填充满。这称为刷新缓冲区。

一些缓冲的输出类支持`autoflush`，由可选的构造函数参数指定。启用`autoflush`时，某些关键事件会导致刷新缓冲区。例如，自动刷新的`PrintWriter`对象在每次调用`println`或`format`时刷新缓冲区。有关这些方法的更多信息，请参阅 [Formatting](https://docs.oracle.com/javase/tutorial/essential/io/formatting.html) 。

要手动刷新流，请调用其`flush`方法。`flush`方法在任何输出流上都有效，但除非缓冲流，否则无效。

#### 扫描和格式化

程序I/O通常涉及到人们喜欢使用的整齐格式化数据的转换。为了帮助您完成这些杂务，Java平台提供了两个API。 [scanner](https://docs.oracle.com/javase/tutorial/essential/io/scanning.html) API将输入分解为与数据位相关联的各个符号。 [formatting](https://docs.oracle.com/javase/tutorial/essential/io/formatting.html) API将数据组装成格式良好，人类可读的形式。

##### 扫描

[`Scanner`](https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html) 类型的对象非常有用，它可以将格式化的输入拆分为单个符号并按照符号各自的数据类型转换它们。

**将输入拆分为符号**

默认情况下，扫描程序使用空格分隔符号。（空格字符包括空格，制表符和行终止符。其完整列表，请参阅文档 [`Character.isWhitespace`](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-) ）要查看扫描的工作原理，让我们看看 [`ScanXan`](https://docs.oracle.com/javase/tutorial/essential/io/examples/ScanXan.java) ，这是一个读取`xanadu.txt`中单个单词的程序。将它们打印出来，每行一个。

```java
import java.io.*;
import java.util.Scanner;

public class ScanXan {
    public static void main(String[] args) throws IOException {

        Scanner s = null;

        try {
            s = new Scanner(new BufferedReader(new FileReader("xanadu.txt")));

            while (s.hasNext()) {
                System.out.println(s.next());
            }
        } finally {
            if (s != null) {
                s.close();
            }
        }
    }
}
```

请注意，`ScanXan`在使用`Scanner`对象完成后会调用`Scanner`的`close`方法。即使`Scanner`不是流，您也需要将其关闭以指示您已完成对其基础流的处理。

`ScanXan`的输出如下所示：

```
In
Xanadu
did
Kubla
Khan
A
stately
pleasure-dome
...
```

要使用不同的符号分隔符，请调用`useDelimiter()`，指定正则表达式。例如，假设您希望符号分隔符为逗号，可选地后跟空格。你可以调用：

```java
s.useDelimiter(",\\s*");
```

**转换单个符号**

`ScanXan`示例将所有输入符号视为简单的`String`值。`Scanner`还支持所有Java语言的原始类型（`char`除外）的符号，以及`BigInteger`和`BigDecimal`。此外，数值可以使用千位分隔符。因此，在美国语言环境中，`Scanner`正确读取字符串`32,767`表示整数值。

我们必须提到语言环境，因为千位分隔符和小数符号是特定于语言环境的。因此，如果我们未指定`Scanner`应使用美国语言环境，则以下示例将无法在所有语言环境中正常运行。这通常不必担心，因为您的输入数据通常来自使用相同语言环境的源。但是这个例子是Java Tutorial的一部分，并且分发到世界各地。

`ScanSum`示例读取双精度值列表并将其相加。代码如下：

```java
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Scanner;
import java.util.Locale;

public class ScanSum {
    public static void main(String[] args) throws IOException {

        Scanner s = null;
        double sum = 0;

        try {
            s = new Scanner(new BufferedReader(new FileReader("usnumbers.txt")));
            s.useLocale(Locale.US);

            while (s.hasNext()) {
                if (s.hasNextDouble()) {
                    sum += s.nextDouble();
                } else {
                    s.next();
                }   
            }
        } finally {
            s.close();
        }

        System.out.println(sum);
    }
}
```

下面是样本输入文件 [`usnumbers.txt`](https://docs.oracle.com/javase/tutorial/essential/io/examples/usnumbers.txt) ：

```
8.5
32,767
3.14159
1,000,000.1
```

输出字符串是`1032778.74159`。在某些语言环境中，句点将是不同的字符，因为`System.out`是`PrintStream`对象，并且该类不提供覆盖默认语言环境的方法。我们可以覆盖整个程序的语言环境 - 或者我们可以只使用格式化，如下一个主题 [Formatting](https://docs.oracle.com/javase/tutorial/essential/io/formatting.html) 中所述。

##### 格式化

实现格式化的流对象是 [`PrintWriter`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html)（字符流类）或 [`PrintStream`](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html)（字节流类）的实例。

------

**注意：** 您可能需要的唯一`PrintStream`对象是 [`System.out`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out) 和 [`System.err`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#err)。（有关这些对象的更多信息，请参阅 [命令行中的 I/O](https://docs.oracle.com/javase/tutorial/essential/io/cl.html) ）当您需要创建格式化的输出流时，请实例化`PrintWriter`，而不是`PrintStream`。

------

与所有字节流和字符流对象一样，`PrintStream`和`PrintWriter`的实例实现了一组标准的写入方法，用于简单的字节和字符输出。此外，`PrintStream`和`PrintWriter`都实现了将内部数据转换为格式化输出的同一组方法。提供两个级别的格式：

- 以标准方式`print`和`println`格式化各个值。
- `format`基于格式字符串格式化几乎任意数量的值，具有许多用于精确格式化的选项。

**`print` 和 `println` 方法**

在使用适当的`toString`方法转换值后，调用`print`或`println`输出单个值。我们可以在 [`Root`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Root.java) 示例中看到这一点：

```java
public class Root {
    public static void main(String[] args) {
        int i = 2;
        double r = Math.sqrt(i);
        
        System.out.print("The square root of ");
        System.out.print(i);
        System.out.print(" is ");
        System.out.print(r);
        System.out.println(".");

        i = 5;
        r = Math.sqrt(i);
        System.out.println("The square root of " + i + " is " + r + ".");
    }
}
```

`Root` 的输出：

```
The square root of 2 is 1.4142135623730951.
The square root of 5 is 2.23606797749979.
```

`i`和`r`变量被格式化两次：第一次在`print`的重载中使用代码，第二次由Java编译器自动生成的转换代码，也使用`toString`。您可以通过这种方式格式化任何值，但是您无法控制结果。

**`format` 方法**

`format`方法根据*格式字符串*格式化多个参数。格式字符串由嵌入*格式说明符*的静态文本组成；除格式说明符外，格式字符串输出不变。

格式字符串支持许多功能。在本教程中，我们将介绍一些基础知识。完整说明，请参阅API规范中的[`格式化字符串语法`](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax) 。

`Root2`示例使用单个`format`调用格式化两个值：

```java
public class Root2 {
    public static void main(String[] args) {
        int i = 2;
        double r = Math.sqrt(i);
        
        System.out.format("The square root of %d is %f.%n", i, r);
    }
}
```

输出：

```
The square root of 2 is 1.414214.
```

与本示例中使用的三个一样，所有格式说明符都以`％`开头，并以1或2个字符的*转换*结尾，指定生成的格式化输出的类型。这里使用的三个转换是：

- `d`将整数值格式化为十进制值。
- `f`将浮点值格式化为十进制值。
- `n`输出特定于平台的行终结符。

以下是其他一些转换：

- `x`将整数格式化为十六进制值。
- `s`将任何值格式化为字符串。
- `tB`将整数格式化为特定于语言环境的月份名称。

还有很多其他转换。

------

**注意：** 

除`%%`和`％n`外，所有格式说明符必须与参数匹配。如果不这样做，则会抛出异常。

在Java编程语言中，`\n`转义符始终生成换行符（`\u000A`）。除非您特别需要换行符，否则请勿使用`\n`。要获取本地平台的换行符，请使用`％n`。

------

除了转换之外，格式说明符还可以包含几个其他元素，以进一步自定义格式化输出。这是一个使用每种可能元素的示例 [`Format`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Format.java)。

```java
public class Format {
    public static void main(String[] args) {
        System.out.format("%f, %1$+020.10f %n", Math.PI);
    }
}
```

输出：

```
3.141593, +00000003.1415926536
```

附加元素都是可选的。下图显示了较长的格式说明符如何分解为单个元素。

![Elements of a format specifier](https://docs.oracle.com/javase/tutorial/figures/essential/io-spec.gif)

格式说明符的元素。

元素必须按所示顺序出现。从右侧开始，可选元素是：

- **精度** - 对于浮点值，这是格式化值的数学精度。对于s和其他常规转换，这是格式化值的最大宽度;如有必要，该值将被截断。
- **宽度** - 格式化值的最小宽度；必要时填充该值。默认情况下，该值使用空白填充。
- **标志** - 指定其他格式选项。在`Format`示例中，`+`标志指定应始终将数值格式化为带符号数字，`0`标志指定`0`是填充字符。其他标志包括`-`（右侧的填充）和`,`（具有特定于语言环境的千位分隔符的格式号）。请注意，某些标志不能与某些其他标志一起使用或与某些转换一起使用。
- **参数索引** - 允许您显式匹配指定的参数。您还可以指定`<`以匹配与前一个说明符相同的参数。因此该示例可以说写成：`System.out.format()"％f，％<+ 020.10f％n"，Math.PI)` 。

#### 命令行中的 I/O

程序经常从命令行运行，并在命令行环境中与用户交互。Java平台以两种方式支持这种交互：通过标准流和通过控制台。

**标准流**

标准流是许多操作系统的一个特性。默认情况下，他们从键盘读取输入并将输出写入显示器。它们还支持文件和程序之间的I/O，但该功能由命令行解释器控制，而不是程序。

Java平台支持三种标准流：*标准输入*，通过`System.in`访问；*标准输出*，通过`System.out`访问；和*标准错误*，通过`System.err`访问。这些对象是自动定义的，不需要打开。标准输出和标准错误均用于输出；单独的错误输出能力允许用户将常规输出转移到文件并在随后仍然能够读取错误消息。有关更多信息，请参阅命令行解释程序的文档。

您可能希望标准流是字符流，但由于历史原因，它们是字节流。`System.out`和`System.err`定义为`PrintStreamobjects`。虽然从技术上讲它是字节流，但`PrintStream`利用内部字符流对象来模拟字符流的许多功能。

相比之下，`System.in`是一个没有字符流功能的字节流。要将标准输入用作字符流，请在`InputStreamReader`中包装`System.in`。

```java
InputStreamReader cin = new InputStreamReader(System.in);
```

**控制台**

控制台是标准流的更高级替代方案。这是一个类型为`Console`的预定义对象，它具有标准流提供的大部分功能，以及其他功能。控制台对于安全密码输入特别有用。`Console`对象还通过其`reader`和`writer`方法提供作为真实字符流的输入和输出流。

在程序可以使用控制台之前，它必须通过调用`System.console()`来尝试检索`Console`对象。如果`Console`对象可用，则此方法返回该对象。如果`System.console`返回`NULL`，则不允许`Console`操作，因为操作系统不支持它们，或者因为程序是在非交互式环境中启动的。

`Console`对象通过其`readPassword`方法支持安全密码输入。此方法有助于以两种方式保护密码输入。首先，它抑制回显，因此密码在用户屏幕上不可见。其次，`readPassword`返回一个字符数组，而不是`String`，因此密码可以被覆盖，一旦不再需要就将其从内存中删除。

 [`Password`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Password.java) 示例是用于更改用户密码的原型程序。它演示了几种`Console`方法。

```java
import java.io.Console;
import java.util.Arrays;
import java.io.IOException;

public class Password {
    
    public static void main (String args[]) throws IOException {

        Console c = System.console();
        if (c == null) {
            System.err.println("No console.");
            System.exit(1);
        }

        String login = c.readLine("Enter your login: ");
        char [] oldPassword = c.readPassword("Enter your old password: ");

        if (verify(login, oldPassword)) {
            boolean noMatch;
            do {
                char [] newPassword1 = c.readPassword("Enter your new password: ");
                char [] newPassword2 = c.readPassword("Enter new password again: ");
                noMatch = ! Arrays.equals(newPassword1, newPassword2);
                if (noMatch) {
                    c.format("Passwords don't match. Try again.%n");
                } else {
                    change(login, newPassword1);
                    c.format("Password for %s changed.%n", login);
                }
                Arrays.fill(newPassword1, ' ');
                Arrays.fill(newPassword2, ' ');
            } while (noMatch);
        }

        Arrays.fill(oldPassword, ' ');
    }
    
    // Dummy change method.
    static boolean verify(String login, char[] password) {
        // This method always returns
        // true in this example.
        // Modify this method to verify
        // password according to your rules.
        return true;
    }

    // Dummy change method.
    static void change(String login, char[] password) {
        // Modify this method to change
        // password according to your rules.
    }
}
```

`Password`类遵循以下步骤：

1. 尝试检索`Console`对象。如果对象不可用，则中止。

2. 调用`Console.readLine`以提示并读取用户的登录名。

3. 调用`Console.readPassword`以提示并读取用户的现有密码。

4. 调用`verify`以确认用户有权更改密码。（在此示例中，`verify`是一个始终返回`true`的虚方法。）

5. 重复以下步骤，直到用户输入两次相同的密码：

     1. 两次调用`Console.readPassword`以提示并读取新密码。

        2. 如果用户同时输入相同的密码，请调用`change`以进行更改。（同样，`change`是一种虚拟方法。）

        3. 用空格覆盖两个密码。

6. 用空格覆盖旧密码。


#### 数据流

数据流支持原始数据类型值（`boolean`，`char`，`byte`，`short`，`int`，`long`，`float`和`double`）以及`String`值的二进制 I/O 。所有数据流都实现`DataInput`接口或`DataOutput`接口。本节重点介绍这些接口最广泛使用的实现 [`DataInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/DataInputStream.html) 和 [`DataOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/DataOutputStream.html) 。

 [`DataStreams`](https://docs.oracle.com/javase/tutorial/essential/io/examples/DataStreams.java) 示例通过写出一组数据记录然后再次读取它们来演示数据流。每条记录包含三个与发票上的项目相关的值，如下表所示：

| Order in record | Data type | Data description | Output Method                  | Input Method                 | Sample Value     |
| --------------- | --------- | ---------------- | ------------------------------ | ---------------------------- | ---------------- |
| 1               | `double`  | Item price       | `DataOutputStream.writeDouble` | `DataInputStream.readDouble` | `19.99`          |
| 2               | `int`     | Unit count       | `DataOutputStream.writeInt`    | `DataInputStream.readInt`    | `12`             |
| 3               | `String`  | Item description | `DataOutputStream.writeUTF`    | `DataInputStream.readUTF`    | `"Java T-Shirt"` |

我们来看看`DataStreams`中的关键代码。首先，程序定义了一些常量，包含数据文件的名称和将写入的数据：

```java
static final String dataFile = "invoicedata";

static final double[] prices = { 19.99, 9.99, 15.99, 3.99, 4.99 };
static final int[] units = { 12, 8, 13, 29, 50 };
static final String[] descs = {
    "Java T-shirt",
    "Java Mug",
    "Duke Juggling Dolls",
    "Java Pin",
    "Java Key Chain"
};
```

然后`DataStreams`打开输出流。由于`DataOutputStream`只能作为现有字节流对象的包装器创建，因此`DataStreams`提供带缓冲的文件输出字节流。

```java
out = new DataOutputStream(new BufferedOutputStream(
              new FileOutputStream(dataFile)));
```

`DataStreams`写出记录并关闭输出流。

```java
for (int i = 0; i < prices.length; i ++) {
    out.writeDouble(prices[i]);
    out.writeInt(units[i]);
    out.writeUTF(descs[i]);
}
```

`writeUTF`方法以`UTF-8`的改进形式写出`String`值。这是一个可变宽度的字符编码，只需要一个字节表示常见的西方字符。

现在，`DataStreams`再次读回数据。首先，它必须提供输入流和变量来保存输入数据。与`DataOutputStream`一样，`DataInputStream`必须构造为字节流的包装器。

```java
in = new DataInputStream(new
            BufferedInputStream(new FileInputStream(dataFile)));

double price;
int unit;
String desc;
double total = 0.0;
```

现在，`DataStreams`可以读取流中的每条记录，报告它遇到的数据。

```java
try {
    while (true) {
        price = in.readDouble();
        unit = in.readInt();
        desc = in.readUTF();
        System.out.format("You ordered %d" + " units of %s at $%.2f%n",
            unit, desc, price);
        total += unit * price;
    }
} catch (EOFException e) {
}
```

请注意，`DataStreams`通过捕获 [`EOFException`](https://docs.oracle.com/javase/8/docs/api/java/io/EOFException.html)来检测文件结束条件，而不是测试无效的返回值。`DataInput`方法的所有实现都使用`EOFException`而不是返回值。

另请注意，`DataStream`中的每个特定`write`都与相应的特定`read`完全匹配。程序员需要确保输出类型和输入类型以这种方式匹配：输入流由简单的二进制数据组成，没有任何内容可以指示单个值的类型，或者它们在流中开始的位置。

`DataStreams`使用一种非常糟糕的编程技术：它使用浮点数来表示货币值。通常，浮点对于精确值是不利的。对于小数分数尤其不好，因为常见的数值（例如`0.1`）没有二进制表示。

表示货币值的正确类型是`java.math.BigDecimal`。不幸的是，`BigDecimal`是一种对象类型，因此它不适用于数据流。但是，`BigDecimal`将使用对象流，这将在下一节中介绍。

#### 对象流

正如数据流支持原始数据类型的 I/O 一样，对象流也支持对象的 I/O 。大多数（但不是全部）标准类支持其对象的序列化。因为它们确实实现了标记接口[`Serializable`](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html) 。

对象流类是[`ObjectInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html)和[`ObjectOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html) 。这些类实现[`ObjectInput`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInput.html) 和 [`ObjectOutput`](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutput.html) ，它们是`DataInput`和`DataOutput`的子接口。这意味着 [数据流](https://docs.oracle.com/javase/tutorial/essential/io/datastreams.html) 中涵盖的所有原始数据 I/O 方法也在对象流中实现。因此，对象流可以包含原始值和对象值的混合。 [`ObjectStreams`](https://docs.oracle.com/javase/tutorial/essential/io/examples/ObjectStreams.java) 示例说明了这一点。 `ObjectStreams`创建了与`DataStreams`相同的应用程序，并进行了一些更改。首先，价格现在是[`BigDecimal`](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)对象，以更好地表示小数值。其次，将[`Calendar`](https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html)对象写入数据文件，表示发票日期。

如果`readObject()`没有返回预期的对象类型，试图将它强制转换为正确的类型可能抛出 [`ClassNotFoundException`](https://docs.oracle.com/javase/8/docs/api/java/lang/ClassNotFoundException.html) 。在这个简单的例子中，这不可能发生，因此我们不会尝试捕获异常。相反，我们通过在`main`方法的`throws`子句中添加`ClassNotFoundException`来通知编译器我们已经意识到了这个问题。

**复杂对象的输入输出**

`writeObject`和`readObject`方法使用起来很简单，但它们包含一些非常复杂的对象管理逻辑。这对像`Calendar`这样的类来说并不重要，它只封装了原始数据类型值。但是许多对象包含对其他对象的引用。如果`readObject`是从流中重构一个对象，它必须能够重建原始对象所引用的所有对象。这些附加对象可能有自己的引用，依此类推。在这种情况下，`writeObject`遍历整个对象引用网络，并将该网络中的所有对象写入流。因此，单次调用`writeObject`会导致大量对象被写入流。

下图中进行了演示，其中调用`writeObject`来写名为**a**的单个对象。该对象包含对象**b**和**c**的引用，而**b**包含对**d**和**e**的引用。调用`writeobject(a)`不仅会写**a **，而且还会写重建**a**所需的所有对象，因此此类依赖网络中的其他四个对象也会被写入。当**a**被`readObject`读回时，其他四个对象也被回读，并保留所有原始对象引用。

![I/O of multiple referred-to objects](https://docs.oracle.com/javase/tutorial/figures/essential/io-trav.gif)

多个引用对象的 I/O 。

您可能想知道如果同一个流上的两个对象都包含对某个对象的引用会发生什么。当他们回读时，他们都会引用一个对象吗？ 答案是肯定的。 流只能包含一个对象的副本，尽管它可以包含任意数量的对象。因此，如果您明确地将对象写入流两次，那么您实际上只写入了两次引用。例如，如果以下代码将对象`ob`两次写入流：

```java
Object ob = new Object();
out.writeObject(ob);
out.writeObject(ob);
```

每个`writeObject`必须与`readObject`匹配，因此读回流的代码将如下所示：

```java
Object ob1 = in.readObject();
Object ob2 = in.readObject();
```

这产生两个变量，`ob1`和`ob2`，它们是对同一个对象的引用。

但是，如果将单个对象写入两个不同的流，则它实际上是被复制的 - 读取两个流的单个程序将看到两个不同的对象。

### 文件 I/O

------

**注意：**  本教程介绍的文件 I/O 机制包含在 JDK 7 发布版本中。Java SE 6 版本中的文件 I/O 教程非常简短，不过你仍然可以下载 [Java SE Tutorial 2008-03-14](http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-tutorials-419421.html#tutorial-2008_03_14-oth-JPR) 版本的教程，其中包含早期版本的文件 I/O 内容。

------

`java.nio.file` 包以及它的相关包，`java.nio.file.attribute`，提供对文件 I/O 的完善支持，用来访问默认文件系统。尽管该 API 包含许多类，你只需要关注少量几个入口点。你将发现这些 API 非常直观而且容易使用。

本教程以一个问题 [path 是什么?](https://docs.oracle.com/javase/tutorial/essential/io/path.html) 开始，然后，介绍 [Path 类](https://docs.oracle.com/javase/tutorial/essential/io/pathClass.html) ，包的主要入口点。接下来解释了`Path` 类中的方法相关的 [语法操作](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html) 。本教程随后转向包中的其他主要的类，`Files` 类，其中包含文件操作方法。首先介绍许多 [文件操作](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html) 通用的概念。然后介绍用于文件 [检查](https://docs.oracle.com/javase/tutorial/essential/io/check.html), [删除](https://docs.oracle.com/javase/tutorial/essential/io/delete.html), [拷贝](https://docs.oracle.com/javase/tutorial/essential/io/copy.html), 以及 [移动](https://docs.oracle.com/javase/tutorial/essential/io/move.html) 的方法。

本教程介绍了如何管理 [元数据](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) ，在继续介绍 [文件I/O](https://docs.oracle.com/javase/tutorial/essential/io/file.html) 和 [目录I/O](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html) 之前。[随机访问文件](https://docs.oracle.com/javase/tutorial/essential/io/rafs.html) 解释了 [符号和硬链接](https://docs.oracle.com/javase/tutorial/essential/io/links.html) 特定的问题。 

接下来，介绍一些非常强大但更高级的主题。首先，演示了 [递归遍历文件树](https://docs.oracle.com/javase/tutorial/essential/io/walk.html) ，然后是有关如何 [使用通配符搜索文件的信息](https://docs.oracle.com/javase/tutorial/essential/io/find.html) 。接下来，将解释和演示如何 [查看更改目录](https://docs.oracle.com/javase/tutorial/essential/io/notification.html) 。然后，对 [不适合其他地方的方法](https://docs.oracle.com/javase/tutorial/essential/io/misc.html) 进行了一些介绍。

最后，如果您在 Java SE 7 发行版之前编写了文件 I/O代码，则会有[从旧API到新API的映射](https://docs.oracle.com/javase/tutorial/essential/io/legacy.html#mapping) ，以及关于`File.toPath`方法的重要信息，供希望 [利用新API而不重写现有代码](https://docs.oracle.com/javase/tutorial/essential/io/legacy.html#interop) 的开发人员使用。

#### 什么是 Path?（其他文件系统事实）

文件系统以某种形式存储和组织某些形式的媒体上的文件，通常是一个或多个硬盘驱动器，以便可以容易地检索它们。目前使用的大多数文件系统都以树（或*hierarchical*）结构存储文件。在树的顶部是一个（或多个）根节点。在根节点下，有文件和目录（Microsoft Windows中的*文件夹*）。每个目录都可以包含文件和子目录，而这些文件和子目录又可以包含文件和子目录，等等，可能达到几乎无限的深度。

本章节涵盖以下内容：

- [什么是 Path?](https://docs.oracle.com/javase/tutorial/essential/io/path.html#path)
- [相对还是绝对?](https://docs.oracle.com/javase/tutorial/essential/io/path.html#relative)
- [符号链接](https://docs.oracle.com/javase/tutorial/essential/io/path.html#symlink)

**什么是 Path?**

下图显示了包含单个根节点的示例目录树。Microsoft Windows支持多个根节点。每个根节点都映射到一个卷，例如`C:\`或`D:\`。Solaris OS支持单个根节点，用斜杠字符`/`表示。

![Sample directory structure](https://docs.oracle.com/javase/tutorial/figures/essential/io-dirStructure.gif)

目录结构示例

从根节点开始，文件通过文件系统的路径标识。例如，上图中的`statusReport`文件在Solaris OS中由以下表示法描述：

```
/home/sally/statusReport
```

在Microsoft Windows中，`statusReport`由以下表示法描述：

```
C:\home\sally\statusReport
```

用于分隔目录名称的字符（也称为*分隔符*）特定于文件系统：Solaris OS使用正斜杠（`/`），Microsoft Windows使用反斜杠斜杠（`\`）。

**相对还是绝对？**

路径是 *relative* 或 *absolute* 的。绝对路径始终包含查找文件所需的根元素和完整目录列表。例如，`/home/sally/statusReport`是绝对路径。查找文件所需的所有信息都包含在路径字符串中。

相对路径需要与另一个路径组合才能访问文件。例如，`joe/foo`是一个相对路径。没有更多信息，程序无法可靠地找到文件系统中的`joe/foo`目录。

**符号链接**

文件系统对象通常是目录或文件。每个人都熟悉这些对象。但是一些文件系统也支持符号链接的概念。符号链接也称为*符号链接*或*软链接*。

*符号链接*是一个特殊文件，用作对另一个文件的引用。在大多数情况下，符号链接对应用程序是透明的，符号链接上的操作会自动重定向到链接的目标。（指向的文件或目录称为链接的*target*。）例外情况是删除或重命名符号链接，在这种情况下链接本身被删除或重命名，而不是链接的目标。

在下图中，`logFile`似乎是用户的常规文件，但它实际上是指向`dir/logs/HomeLogFile`的符号链接。`HomeLogFile`是链接的目标。

![Sample symbolic link](https://docs.oracle.com/javase/tutorial/figures/essential/io-symlink.gif)

符号链接示例。

符号链接通常对用户是透明的。读取或写入符号链接与读取或写入任何其他文件或目录相同。

短语*解析链接*意味着用文件系统中的实际位置替换符号链接。在示例中，解析`logFile`会产生`dir/logs/HomeLogFile`。

在实际场景中，大多数文件系统都可以自由使用符号链接。偶尔，粗心创建的符号链接可能会导致循环引用。当链接的目标指向原始链接时，会发生循环引用。循环引用可能是间接引用：目录`a`指向目录`b`，而目录`b`指向目录`c`，目录`c`中包含一个指向目录`a`的子目录。当程序递归地遍历目录结构时，循环引用可能会导致严重破坏。但是，此问题已被考虑到，并且不会导致程序无限循环。

下一章节将讨论Java编程语言中文件 I/O 支持的核心，即`Path`类。

#### `Path`类

Java SE 7发行版中引入的`Path`类是`java.nio.file`包的主要入口点之一。如果您的应用程序使用文件 I/O，您将需要了解此类的强大功能。

------

**版本提醒：** 如果您的JDK7之前的代码使用的是`java.io.File`，则仍可以使用`File.toPath`方法来利用`Path`类功能。有关更多信息，请参阅 [遗留 文件 I/O 代码](https://docs.oracle.com/javase/tutorial/essential/io/legacy.html) 。

------

顾名思义，`Path`类是文件系统中路径的编程表示。`Path`对象包含用于构造路径的文件名和目录列表，用于检查，定位和操作文件。

`Path`实例反映了底层平台。在Solaris OS中，`Path`使用Solaris语法（`/home/joe/foo`），在Microsoft Windows中，`Path`使用Windows语法（`C:\home\joe\foo`）。路径不是系统无关的。您无法比较Solaris文件系统中的路径并期望它与Windows文件系统中的路径匹配，即使目录结构相同且两个实例都找到相同的相对文件路径。

与`Path`对应的文件或目录可能不存在。您可以创建一个`Path`实例并以各种方式对其进行操作：您可以将内容附加到它，提取它的部分内容，将它与另一个路径进行比较。在适当的时候，您可以使用 [`Files`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html) 类中的方法来检查`Path`对应的文件是否存在，创建文件，打开文件，删除文件，更改权限等等。

下一节详细介绍了`Path`类。

##### `Path`操作

`Path`类包括各种方法，可用于获取有关路径，访问路径元素，将路径转换为其他表单或提取路径部分的信息。还存在用于匹配路径字符串的方法和用于去除路径中的冗余的方法。本课程介绍了这些`Path`方法，有时称为语法操作，因为它们在路径本身上运行而不访问文件系统。

本小节涵盖以下内容：

- [创建 `Path`](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#create)
- [获取`Path`相关信息](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#info)
- [删除`Path`中的冗余内容](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#normal)
- [转化`Path`](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert)
- [合并两个`Path`](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#resolve)
- [在两个`Path`中间创建`Path`](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#relativize)
- [比较两个`Path`](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#compare)

**创建`Path`**

`Path`实例包含用于指定文件或目录位置的信息。在定义时，`Path`提供一个或多个名称。可能包含根元素或文件名，但两者都不是必需的。路径可能只包含一个目录或文件名。

您可以使用`Paths`（注意复数）帮助器类中的以下`get`方法之一轻松创建`Path`对象：

```java
Path p1 = Paths.get("/tmp/foo");
Path p2 = Paths.get(args[0]);
Path p3 = Paths.get(URI.create("file:///Users/joe/FileTest.java"));
```

`Paths.get`方法是以下代码的简写：

```java
Path p4 = FileSystems.getDefault().getPath("/users/sally");
```

The following example creates `/u/joe/logs/foo.log` assuming your home directory is `/u/joe`, or `C:\joe\logs\foo.log` if you are on Windows.

以下示例创建`/u/joe/logs/foo.log`，假设您的主目录是`/u/joe`，或者如果您在Windows上，则创建`C:\joe\logs\foo.log`。

```java
Path p5 = Paths.get(System.getProperty("user.home"),"logs", "foo.log");
```

**获取`Path`相关信息**

您可以将`Path`视为将这些名称元素存储为序列。目录结构中的最高元素位于索引`0`。目录结构中的最低元素位于索引`[n-1]`，其中`n`是`Path`中名称元素的数量。方法可用于使用这些索引检索单个元素或`Path`的子序列。

本课中的示例使用以下目录结构。

![Sample directory structure](https://docs.oracle.com/javase/tutorial/figures/essential/io-dirStructure.gif)

示例目录结构。

以下代码片段定义了`Path`实例，然后调用了几个方法来获取有关路径的信息：

```java
// None of these methods requires that the file corresponding
// to the Path exists.
// Microsoft Windows syntax
Path path = Paths.get("C:\\home\\joe\\foo");

// Solaris syntax
Path path = Paths.get("/home/joe/foo");

System.out.format("toString: %s%n", path.toString());
System.out.format("getFileName: %s%n", path.getFileName());
System.out.format("getName(0): %s%n", path.getName(0));
System.out.format("getNameCount: %d%n", path.getNameCount());
System.out.format("subpath(0,2): %s%n", path.subpath(0,2));
System.out.format("getParent: %s%n", path.getParent());
System.out.format("getRoot: %s%n", path.getRoot());
```

以下是Windows和Solaris OS的输出：

| Returns in the Solaris OS | Method Invoked | Returns in Microsoft Windows | Comment                                  |
| ------------------------- | -------------- | ---------------------------- | ---------------------------------------- |
| `/home/joe/foo`           | `toString`     | `C:\home\joe\foo`            | 返回`Path`的字符串表示形式。如果路径是使用`Filesystems.getDefault().getPath(String)`或`Paths.get`（后者是`getPath`的便捷方法）创建的，则该方法执行次要的语法清理。例如，在UNIX操作系统中，它会将输入字符串`//home/joe/foo`更正为`/home/joe/foo`。 |
| `foo`                     | `getFileName`  | `foo`                        | 返回文件名或名称元素序列的最后一个元素。                     |
| `home`                    | `getName(0)`   | `home`                       | 返回与指定索引对应的路径元素。第`0`个元素是最靠近根的路径元素。        |
| `3`                       | `getNameCount` | `3`                          | 返回路径中元素的个数。                              |
| `home/joe`                | `subpath(0,2)` | `home\joe`                   | 返回由开始和结束索引指定的`Path`（不包括根元素）的子序列。         |
| `/home/joe`               | `getParent`    | `\home\joe`                  | 返回上级文件夹路径。                               |
| `/`                       | `getRoot`      | `C:\`                        | 返回路径的根目录。                                |

前面的示例显示了绝对路径的输出。在以下示例中，指定了相对路径：

```
// Solaris syntax
Path path = Paths.get("sally/bar");
or
// Microsoft Windows syntax
Path path = Paths.get("sally\\bar");
```

以下是Windows和Solaris OS的输出：

| Method Invoked | Returns in the Solaris OS | Returns in Microsoft Windows |
| -------------- | ------------------------- | ---------------------------- |
| `toString`     | `sally/bar`               | `sally\bar`                  |
| `getFileName`  | `bar`                     | `bar`                        |
| `getName(0)`   | `sally`                   | `sally`                      |
| `getNameCount` | `2`                       | `2`                          |
| `subpath(0,1)` | `sally`                   | `sally`                      |
| `getParent`    | `sally`                   | `sally`                      |
| `getRoot`      | `null`                    | `null`                       |

**删除`Path`中的冗余**

许多文件系统使用“.” 符号表示当前目录，“..”表示父目录。您可能遇到路径包含冗余目录信息的情况。也许服务器配置为将其日志文件保存在“/dir/logs/.”目录，并且您要删除路径末尾的“/.” 符号。

下面的例子都包含冗余信息：

```
/home/./joe/foo
/home/sally/../joe/foo
```

`normalize`方法删除任何冗余元素，包括出现的任何“.” 或“*directory*/..”。前面的两个示例都规范化为`/home/joe/foo`。

值得注意的是，`normalize`在清理路径时不会检查文件系统。这是一种纯粹的语法操作。在第二个示例中，如果`sally`是符号链接，则删除`sally/..`可能会导致`Path`不再定位目标文件。

要在确保结果找到正确文件的同时清理路径，可以使用`toRealPath`方法。此方法将在下一节 [转换路径](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert) 中介绍。

**转换路径**

您可以使用三种方法转换`Path`。如果需要将路径转换为可以从浏览器打开的字符串，则可以使用 [`toUri`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toUri--)。 例如：

```java
Path p1 = Paths.get("/home/logfile");
// Result is file:///home/logfile
System.out.format("%s%n", p1.toUri());
```

[`toAbsolutePath`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toAbsolutePath--)方法将路径转换为绝对路径。如果传入的路径已经是绝对路径，则返回相同的`Path`对象。处理用户输入的文件名时，`toAbsolutePath`方法非常有用。例如：

```java
public class FileTest {
    public static void main(String[] args) {

        if (args.length < 1) {
            System.out.println("usage: FileTest file");
            System.exit(-1);
        }

        // Converts the input string to a Path object.
        Path inputPath = Paths.get(args[0]);

        // Converts the input Path
        // to an absolute path.
        // Generally, this means prepending
        // the current working
        // directory.  If this example
        // were called like this:
        //     java FileTest foo
        // the getRoot and getParent methods
        // would return null
        // on the original "inputPath"
        // instance.  Invoking getRoot and
        // getParent on the "fullPath"
        // instance returns expected values.
        Path fullPath = inputPath.toAbsolutePath();
    }
}
```

`toAbsolutePath`方法转换用户输入并返回在查询时返回有用值的`Path`。此方法无需该文件存在。

[`toRealPath`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toRealPath-java.nio.file.LinkOption...-)方法返回现有文件的实际路径。此方法执行多个操作：

- 如果将`true`传递给此方法并且文件系统支持符号链接，则此方法将解析路径中的所有符号链接。
- 如果`Path`是相对的，则返回绝对路径。
- 如果`Path`包含任何冗余元素，则返回删除了这些元素的路径。

如果文件不存在或无法访问，则此方法将引发异常。当您想要处理任何这些情况时，您可以捕获异常。例如：

```java
try {
    Path fp = path.toRealPath();
} catch (NoSuchFileException x) {
    System.err.format("%s: no such" + " file or directory%n", path);
    // Logic for case when file doesn't exist.
} catch (IOException x) {
    System.err.format("%s%n", x);
    // Logic for other sort of file error.
}
```

**连接两个路径**

您可以使用`resolve`方法组合路径。传入*部分路径*，这是一个不包含根元素的路径，则该部分路径将附加到原始路径之后。

例如，请考虑以下代码段：

```java
// Solaris
Path p1 = Paths.get("/home/joe/foo");
// Result is /home/joe/foo/bar
System.out.format("%s%n", p1.resolve("bar"));

or

// Microsoft Windows
Path p1 = Paths.get("C:\\home\\joe\\foo");
// Result is C:\home\joe\foo\bar
System.out.format("%s%n", p1.resolve("bar"));
```

将绝对路径传递给`resolve`方法会返回传入的路径：

```java
// Result is /home/joe
Paths.get("foo").resolve("/home/joe");
```

**在两个路径中间创建路径**

编写文件 I/O 代码时的一个常见需求是能够构建从文件系统中的一个位置到另一个位置的路径。你可以使用`relativize`方法来满足这个要求。此方法构造一个源自原始路径并在传入路径指定的位置结束的路径。新路径*相对与*原始路径。

例如，考虑定义为`joe`和`sally`的两个相对路径：

```java
Path p1 = Paths.get("joe");
Path p2 = Paths.get("sally");
```

在没有任何其他信息的情况下，假设`joe`和`sally`是兄弟目录，意味着节点位于目录树结构中的同一级别。要从`joe`导航到`sally`，你可能会先向上导航到共同的父节点，然后再导航到`sally`：

```java
// Result is ../sally
Path p1_to_p2 = p1.relativize(p2);
// Result is ../joe
Path p2_to_p1 = p2.relativize(p1);
```

考虑下面的稍微复杂一些的例子：

```java
Path p1 = Paths.get("home");
Path p3 = Paths.get("home/sally/bar");
// Result is sally/bar
Path p1_to_p3 = p1.relativize(p3);
// Result is ../..
Path p3_to_p1 = p3.relativize(p1);
```

在这个例子中，两个路径共享同一个节点`home`。要从`home`导航到`bar`，首先要向上导航到`sally`，然后再向下导航到`bar`。从`bar`到`home`的导航需要向上移动两个级别。

如果只有一个路径包含根元素，则不能构造相对路径。如果两个路径都包含根元素，则是否能够构造相对路径取决于系统。

递归[`Copy`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java)示例使用`relativize`和`resolve`方法。

**比较两个路径**

`Path`类支持[`equals`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#equals-java.lang.Object-)， 使您能够测试两条路径是否相等。[`startsWith`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#startsWith-java.nio.file.Path-)和[`endsWith `](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#endsWith-java.nio.file.Path-)方法使您可以测试路径是否以特定字符串开头或结尾。这些方法易于使用。 例如：

```java
Path path = ...;
Path otherPath = ...;
Path beginning = Paths.get("/home");
Path ending = Paths.get("foo");

if (path.equals(otherPath)) {
    // equality logic here
} else if (path.startsWith(beginning)) {
    // path begins with "/home"
} else if (path.endsWith(ending)) {
    // path ends with "foo"
}
```

`Path`类实现[`Iterable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)接口。[`iterator`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#iterator--)方法返回一个对象，使您可以迭代路径中的名称元素。返回的第一个元素是最接近目录树中的根的元素。以下代码片段遍历路径，打印每个名称元素：

```java
Path path = ...;
for (Path name: path) {
    System.out.println(name);
}
```

`Path`类还实现了[`Comparable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)接口。您可以使用`compareTo`来比较`Path`对象，这对于排序很有用。

您还可以将`Path`对象放入`Collection`中。有关此强大功能的详细信息，请参阅 [Collections](https://docs.oracle.com/javase/tutorial/collections/index.html) 。

如果要验证两个`Path`对象是否表示同一个文件，可以使用`isSameFile`方法，如 [检查两个路径是否定位到相同文件](https://docs.oracle.com/javase/tutorial/essential/io/check.html#same) 中所述。

#### 文件操作

[`Files`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html)类是`java.nio.file`包的另一个主要入口点。该类提供了一组丰富的静态方法，用于读取，写入和操作文件和目录。`Files`方法适用于`Path`对象的实例。在继续讨论其余部分之前，您应该熟悉以下常见概念：

- [释放系统资源](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#resources)
- [捕获异常](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#exception)
- [可变参数](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#varargs)
- [原子操作](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#atomic)
- [方法链](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#chaining)
- [什么*是* Glob?](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob)
- [连接敏感](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#linkaware)

**释放系统资源**

此API中使用的许多资源（如流或通道）实现或扩展 [`java.io.Closeable`](https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html) 接口。`Closeable`资源意味着是必须调用`close`方法以在不再需要时释放资源。忽略关闭资源可能会对应用程序的性能产生负面影响。下一节中描述的`try-with-resources`语句为您处理此步骤。

**捕获异常**

对于文件 I/O，意外情况是客观事实：预期中的文件存在（或不存在），程序无法访问文件系统，默认文件系统实现不支持特定功能 ， 等等。可能遇到许多错误。

访问文件系统的所有方法都可以抛出`IOException`。最佳实践是通过将这些方法嵌入Java SE 7发行版中引入的`try-with-resources`语句来捕获这些异常。`try-with-resources`语句的优点是编译器在不再需要时自动生成代码以关闭资源。以下代码显示了它的样子：

```java
Charset charset = Charset.forName("US-ASCII");
String s = ...;
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
```

更多信息，请参阅 [try-with-resources语句](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) 。

或者，您可以将文件 I/O方法嵌入到`try`块中，然后在`catch`块中捕获所有异常。如果你的代码打开了任何流或通道，你应该在`finally`块中关闭它们。前面的示例使用`try-catch-finally`方法看起来如下所示：

```java
Charset charset = Charset.forName("US-ASCII");
String s = ...;
BufferedWriter writer = null;
try {
    writer = Files.newBufferedWriter(file, charset);
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
} finally {
    if (writer != null) writer.close();
}
```

更多信息，请参阅 [捕获和处理异常](https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html) 。

除了`IOException`之外，许多特定的异常扩展了[`FileSystemException`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html)。这个类有一些有用的方法可以返回涉及的文件[`getFile`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getFile-- )，详细的消息字符串[`getMessage`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getMessage--)，文件系统操作失败的原因[`getReason`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getReason--)和涉及的其他文件，如果有的话[`getOtherFile`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getOtherFile--)。

以下代码段显示了如何使用`getFile`方法：

```java
try (...) {
    ...    
} catch (NoSuchFileException x) {
    System.err.format("%s does not exist\n", x.getFile());
}
```

为清楚起见，本课程中的文件 I/O 示例可能不会包含异常处理，但您的代码应始终包含它。

**可变参数**

当指定标志时，几个`Files`方法接受任意数量的参数。例如，在以下方法签名中，`CopyOption`参数后面的省略号表示该方法接受可变数量的参数，或*varargs*，因为它们通常的调用方法为：

```java
Path Files.move(Path, Path, CopyOption...)
```

当方法接受可变参数时，您可以传递一个以逗号分隔的值列表或值的数组（`CopyOption []`）。

在`move`示例中，可以按如下方式调用该方法：

```java
import static java.nio.file.StandardCopyOption.*;

Path source = ...;
Path target = ...;
Files.move(source,
           target,
           REPLACE_EXISTING,
           ATOMIC_MOVE);
```

有关可变参数语法的更多信息，请参阅 [任意数量的参数](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs) 。

**原子操作**

一些`Files`方法，例如`move`，可以在某些文件系统中以原子方式执行某些操作。

*原子文件操作*是不能被中断或“部分”执行的操作。执行整个操作或操作失败。当您在文件系统的同一区域上运行多个进程时，这很重要，并且您需要保证每个进程都访问一个完整的文件。

**方法链**

许多文件 I/O 方法都支持*方法链*的概念。

您首先调用返回对象的方法。然后，您立即在*该*对象上调用一个方法，该对象返回另一个对象，依此类推。许多 I/O 示例使用以下技术：

```java
String value = Charset.defaultCharset().decode(buf).toString();
UserPrincipal group =
    file.getFileSystem().getUserPrincipalLookupService().
         lookupPrincipalByName("me");
```

此技术生成紧凑的代码，使您可以避免声明不需要的临时变量。

**什么是 Glob?**

`Files`类中的两个方法接受一个glob参数，但什么是*glob*？

您可以使用glob语法指定模式匹配行为。

glob模式被指定为字符串，并与其他字符串匹配，例如目录或文件名。Glob语法遵循几个简单的规则：

- 星号，`*`匹配任意数量的字符（包括无）。
- 两个星号，`**`，就像`*`一样，但是跨越目录边界。此语法通常用于匹配完整路径。
- 问号`?`与一个字符精确匹配。
- 大括号指定子模式的集合。例如：
  - `{sun，moon，stars}`匹配"sun"，“moon”或“stars”。
  - `{temp *，tmp *}`匹配以“temp”或“tmp”开头的所有字符串。
- 方括号表示一组单个字符，或者，当使用连字符（`-`）时，表示一系列字符。例如：
  - `[aeiou]`匹配任何小写元音。
  - `[0-9]`匹配任何数字。
  - `[A-Z]`匹配任何大写字母。
  - `[a-z，A-Z]`匹配任何大写或小写字母。

  在方括号内，`*`，`？`和`\`匹配自己。

- 所有其他字符匹配自己。
- 要匹配`*`，`?`或其他特殊字符，可以使用反斜杠字符`\`来转义它们。例如：`\\`匹配单个反斜杠，`\?`匹配问号。

以下是glob语法的一些示例：

- `* .html`  - 匹配以*.html*结尾的所有字符串
- `???` - 匹配所有字符串，正好是三个字母或数字
- `* [0-9] *` - 匹配包含数值的所有字符串
- `*。{htm，html，pdf}` - 匹配任何以*.htm* *，* *.html* *或* *.pdf*结尾的字符串
- `a?*。java`  - 匹配以`a`开头的任何字符串，后跟至少一个字母或数字，以*.java*结尾
- `{foo *，* [0-9] *}` - 匹配以*foo*开头的任何字符串或包含数字值的任何字符串

------

**注意：** 如果您在键盘上键入glob模式并且它包含一个特殊字符，则必须将模式放在引号（`“*”`）中，使用反斜杠（`\ *`）或使用命令行支持任何转义机制。

------

glob语法功能强大且易于使用。但是，如果它不足以满足您的需求，您还可以使用正则表达式。有关详细信息，请参阅 [正则表达式](https://docs.oracle.com/javase/tutorial/essential/regex/index.html) 课程。

有关glob语法的更多信息，请参阅`FileSystem`类中的方法 [`getPathMatcher`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-) 的API规范。

**链接敏感**

`Files`类是“链接感知”的。 每个`Files`方法都会检测遇到符号链接时要执行的操作，或者它提供了一个选项，使您可以配置在遇到符号链接时的行为。

#### 检查文件或者目录

你有一个表示文件或目录的`Path`实例，但该文件是否存在于文件系统中？它可读吗？可写？可执行？

**校验文件或者目录的存在性**

`Path`类中的方法是语法意义上的，这意味着它们在`Path`实例上运行。但最终您必须访问文件系统以验证特定的`Path`是否存在。您可以使用 [`exists(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#exists-java.nio.file.Path-java.nio.file.LinkOption...-) 和 [`notExists(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#notExists-java.nio.file.Path-java.nio.file.LinkOption...-) 方法。注意`!Files.exists(path)`不等同于`Files.notExists(path)`。当您测试文件存在时，可能会有三个结果：

- 验证文件存在。
- 验证文件不存在。
- 文件的状态未知。当程序无权访问该文件时，可能会发生此结果。

如果`exists`和`notExists`都返回`false`，则无法验证文件是否存在。

**检查文件的可访问性**

To verify that the program can access a file as needed, you can use the [`isReadable(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isReadable-java.nio.file.Path-), [`isWritable(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isWritable-java.nio.file.Path-), and [`isExecutable(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isExecutable-java.nio.file.Path-) methods.

The following code snippet verifies that a particular file exists and that the program has the ability to execute the file.

```java
Path file = ...;
boolean isRegularExecutableFile = Files.isRegularFile(file) &
         Files.isReadable(file) & Files.isExecutable(file);
```

------

**注意：** 一旦这些方法中的任何一个完成，就无法保证可以访问该文件。许多应用程序中的常见安全漏洞是执行检查然后访问该文件。有关更多信息，请使用您最喜欢的搜索引擎查找`TOCTTOU`（发音为*TOCK-too*）。

------

**检查两个路径是否定位同一个文件**

当您有一个使用符号链接的文件系统时，可能有两个不同的路径来定位同一个文件。 [`isSameFile(Path, Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSameFile-java.nio.file.Path-java.nio.file.Path-) 方法比较两个路径以确定它们是否在文件系统上找到相同的文件。例如：

```java
Path p1 = ...;
Path p2 = ...;

if (Files.isSameFile(p1, p2)) {
    // Logic when the paths locate the same file
}
```

#### 删除文件或者目录

您可以删除文件，目录或链接。使用符号链接时，链接将被删除，而不是链接的目标。对于目录，目录必须为空，否则删除失败。

`Files`类提供了两种删除方法。

[`delete(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#delete-java.nio.file.Path-)方法 如果删除失败，则删除文件或抛出异常。例如，如果文件不存在，则抛出`NoSuchFileException`。您可以捕获异常以确定删除失败的原因，如下所示：

```java
try {
    Files.delete(path);
} catch (NoSuchFileException x) {
    System.err.format("%s: no such" + " file or directory%n", path);
} catch (DirectoryNotEmptyException x) {
    System.err.format("%s not empty%n", path);
} catch (IOException x) {
    // File permission problems are caught here.
    System.err.println(x);
}
```

[`deleteIfExists(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#deleteIfExists-java.nio.file.Path-) 方法 还会删除该文件，但如果该文件不存在，则不会抛出异常。如果有多个线程删除文件并且您不想仅因为一个线程首先执行此操作而抛出异常，则静默失败非常有用。

#### 复制文件或者目录

您可以使用[`copy(Path, Path, CopyOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-) 方法复制文件或目录。如果目标文件存在，则复制失败，除非指定了`REPLACE_EXISTING`选项。

目录可以复制。但是，目录中的文件不会被复制，因此即使原始目录包含文件，新目录也是空的。

复制符号链接时，将复制链接的目标。如果要复制链接本身而不是链接的内容，请指定`NOFOLLOW_LINKS`或`REPLACE_EXISTING`选项。

此方法采用`varargs`参数。支持以下`StandardCopyOption`和`LinkOption`枚举：

- `REPLACE_EXISTING`  - 即使目标文件已存在，也执行复制。如果目标是符号链接，则复制链接本身（而不是链接的目标）。如果目标是非空目录，则复制将失败，并抛出`FileAlreadyExistsException`异常。
- `COPY_ATTRIBUTES`  - 将与文件关联的文件属性复制到目标文件。支持的确切文件属性是文件系统和平台相关的，但跨平台支持`last-modified-time`并复制到目标文件。
- `NOFOLLOW_LINKS`  - 表示不应遵循符号链接。如果要复制的文件是符号链接，则复制链接（而不是链接的目标）。

如果你不熟悉 `enums`，参考 [Enum Types](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html) 。

下面的例子展示了如何使用 `copy` 方法：

```java
import static java.nio.file.StandardCopyOption.*;
...
Files.copy(source, target, REPLACE_EXISTING);
```

除了文件复制，`Files`类还定义了可以用来在文件和流之间复制的方法。[`copy(InputStream, Path, CopyOptions...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...-) 方法可以被用来从输入流复制所有字节到文件。[`copy(Path, OutputStream)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.io.OutputStream-) 方法可以被用于将文件中的所有字节拷贝到输出流中。

[`Copy`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java) 例子使用 `copy` 和 `Files.walkFileTree` 方法来支持递归复制。参考 [Walking the File Tree](https://docs.oracle.com/javase/tutorial/essential/io/walk.html) 获取跟多信息。

#### 移动文件或者目录

您可以使用 [`move(Path, Path, CopyOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-) 方法移动文件或目录。如果目标文件存在，则移动失败，除非指定了`REPLACE_EXISTING`选项。

可以移动空目录。如果目录不为空，则在不移动该目录内容的情况下移动目录时允许移动。在UNIX系统上，移动同一分区中的目录通常包括重命名目录。在这种情况下，即使目录包含文件，此方法也可以工作。

此方法采用`varargs`参数 - 支持以下`StandardCopyOption`枚举：

- `REPLACE_EXISTING`  - 即使目标文件已存在，也执行移动。如果目标是符号链接，则替换符号链接，但它指向的内容不受影响。
- `ATOMIC_MOVE`  - 将移动作为原子文件操作执行。如果文件系统不支持原子移动，则抛出异常。使用`ATOMIC_MOVE`，您可以将文件移动到目录中，并保证观察目录的任何进程都可以访问完整的文件。

以下显示了如何使用`move`方法：

```java
import static java.nio.file.StandardCopyOption.*;
...
Files.move(source, target, REPLACE_EXISTING);
```

虽然您可以在单个目录上实现`move`方法，但该方法通常与文件树递归机制一起使用。更多信息，请参阅 [遍历文件树](https://docs.oracle.com/javase/tutorial/essential/io/walk.html) 。

#### 管理元数据（文件和文件存储属性）

*元数据*的定义是“关于其他数据的数据”。使用文件系统，数据包含在其文件和目录中，元数据跟踪有关每个文件和目录对象的信息：它是常规文件，目录还是链接？ 它的大小，创建日期，上次修改日期，文件所有者，组所有者和访问权限是什么？

文件系统的元数据通常称为其*文件属性*。`Files`类包括可用于获取文件的单个属性或设置属性的方法。

| 方法                                       | 说明                                   |
| ---------------------------------------- | ------------------------------------ |
| [`size(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#size-java.nio.file.Path-) | 返回给定文件的字节尺寸。                         |
| [`isDirectory(Path, LinkOption)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isDirectory-java.nio.file.Path-java.nio.file.LinkOption...-) | 如果给定的`Path`定位到一个目录时返回`true`。         |
| [`isRegularFile(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-) | 如果给定的`Path`定位到一个常规文件时返回`true`。       |
| [`isSymbolicLink(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSymbolicLink-java.nio.file.Path-) | 如果给定的`Path`定位到一个符号链接时返回`true`。       |
| [`isHidden(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isHidden-java.nio.file.Path-) | 如果给定的`Path`定位到一个文件系统中的隐藏文件时返回`true`。 |
| [`getLastModifiedTime(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getLastModifiedTime-java.nio.file.Path-java.nio.file.LinkOption...-) [`setLastModifiedTime(Path, FileTime)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setLastModifiedTime-java.nio.file.Path-java.nio.file.attribute.FileTime-) | 返回或者设置给定文件的最后修改时间。                   |
| [`getOwner(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getOwner-java.nio.file.Path-java.nio.file.LinkOption...-) [`setOwner(Path, UserPrincipal)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setOwner-java.nio.file.Path-java.nio.file.attribute.UserPrincipal-) | 返回或者设置文件所有者。                         |
| [`getPosixFilePermissions(Path, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getPosixFilePermissions-java.nio.file.Path-java.nio.file.LinkOption...-) [`setPosixFilePermissions(Path, Set)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setPosixFilePermissions-java.nio.file.Path-java.util.Set-) | 返回或者设置文件的 POSIX 文件权限。                |
| [`getAttribute(Path, String, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-) [`setAttribute(Path, String, Object, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-) | 返回或者设置一个文件属性的值。                      |

如果程序在同一时间需要多个文件属性，则使用检索单个属性的方法可能效率低下。重复访问文件系统以检索单个属性可能会对性能产生负面影响。因此，`Files`类提供了两个`readAttributes`方法，用于在一次批量操作中获取文件的属性。

| 方法                                       | 说明                                       |
| ---------------------------------------- | ---------------------------------------- |
| [`readAttributes(Path, String, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-) | 批量读取文件属性，其中的`String`参数指定需要读取的属性。         |
| [`readAttributes(Path, Class, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-) | 批量读取文件属性。 `Class <A>`参数是请求的属性类型，该方法返回该类的对象。 |

在展示`readAttributes`方法的示例之前，应该指出不同的文件系统对于应该跟踪哪些属性有不同的概念。因此，相关文件属性被组合在一起成为视图。*视图*映射到特定的文件系统实现，例如 POSIX 或 DOS，或者映射到常用功能，例如文件所有权。

支持的视图如下：

- [`BasicFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributeView.html) - 提供所有文件系统实现都需要支持的基本属性的视图。
- [`DosFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributeView.html）) - 以标准的4位支持扩展基本属性视图支持DOS属性的文件系统。
- [`PosixFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributeView.html)  - 使用文件系统支持的属性扩展基本属性视图支持POSIX标准系列，例如UNIX。这些属性包括文件所有者，组所有者和九个相关的访问权限。
- [`FileOwnerAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/FileOwnerAttributeView.html) - 被支持文件所有者概念的任何文件系统实现支持。
- [`AclFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/AclFileAttributeView.html) - 支持读取或更新文件的访问控制列表（ACL） 。支持NFSv4 ACL模型。也可以支持任何ACL模型，例如Windows ACL模型，它具有到NFSv4模型的定义良好的映射。
- [`UserDefinedFileAttributeView`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserDefinedFileAttributeView.html) - 支持用户定义的元数据。此视图可以映射到系统支持的任何扩展机制。例如，在Solaris OS中，您可以使用此视图来存储文件的MIME类型。

特定文件系统实现可能仅支持基本文件属性视图，或者它可能支持其中几个文件属性视图。文件系统实现可能支持此API中未包含的其他属性视图。

在大多数情况下，您不必直接处理任何`FileAttributeView`接口。（如果你确实需要直接使用`FileAttributeView`，你可以通过 [`getFileAttributeView(Path, Class, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileAttributeView-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-) 方法来访问它。）

`readAttributes`方法使用泛型，可用于读取任何文件属性视图的属性。本节其余部分的示例使用`readAttributes`方法。

本节的其余部分包括以下主题：

- [基本文件属性](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#basic)
- [设定时间戳](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#time)
- [DOS 文件属性](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#dos)
- [POSIX 文件权限](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#posix)
- [设定文件或者组所有者](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#lookup)
- [用户自定义文件属性](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#user)
- [文件存储属性](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#store)

**基本文件属性**

如前所述，要读取文件的基本属性，可以使用`Files.readAttributes`方法之一，该方法批量读取所有基本属性。这比单独访问文件系统以读取每个单独的属性要有效得多。可变参数目前支持[`LinkOption`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/LinkOption.html) 枚举，`NOFOLLOW_LINKS`。如果不希望遵循符号链接，请使用此选项。

------

**关于时间戳的一个词：** 基本属性集包括三个时间戳：`creationTime`，`lastModifiedTime`和`lastAccessTime`。在特定实现中可能不支持任何这些时间戳，在这种情况下，相应的访问器方法返回特定于实现的值。当特定实现支持时，时间戳将作为 [`FileTime`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/FileTime.html) 对象返回。

------

以下代码片段读取并打印给定文件的基本文件属性，并使用 [`BasicFileAttributes`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributes.html) 类中的方法。

```java
Path file = ...;
BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);

System.out.println("creationTime: " + attr.creationTime());
System.out.println("lastAccessTime: " + attr.lastAccessTime());
System.out.println("lastModifiedTime: " + attr.lastModifiedTime());

System.out.println("isDirectory: " + attr.isDirectory());
System.out.println("isOther: " + attr.isOther());
System.out.println("isRegularFile: " + attr.isRegularFile());
System.out.println("isSymbolicLink: " + attr.isSymbolicLink());
System.out.println("size: " + attr.size());
```

除了本例中显示的访问器方法之外，还有一个`fileKey`方法，它返回唯一标识文件的对象，如果没有可用的文件密钥，则返回“null”。

**设定时间戳**

下面的代码片段蛇形文件的最后修改时间毫秒值。

```java
Path file = ...;
BasicFileAttributes attr =
    Files.readAttributes(file, BasicFileAttributes.class);
long currentTime = System.currentTimeMillis();
FileTime ft = FileTime.fromMillis(currentTime);
Files.setLastModifiedTime(file, ft);
}
```

**DOS 文件属性**

除DOS之外的文件系统也支持DOS文件属性，例如 Samba。以下代码段使用 [`DosFileAttributes`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributes.html) 类的方法。

```java
Path file = ...;
try {
    DosFileAttributes attr =
        Files.readAttributes(file, DosFileAttributes.class);
    System.out.println("isReadOnly is " + attr.isReadOnly());
    System.out.println("isHidden is " + attr.isHidden());
    System.out.println("isArchive is " + attr.isArchive());
    System.out.println("isSystem is " + attr.isSystem());
} catch (UnsupportedOperationException x) {
    System.err.println("DOS file" +
        " attributes not supported:" + x);
}
```

不过，你可以设定一个 DOS 属性，使用 [`setAttribute(Path, String, Object, LinkOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-) 方法，如下：

```java
Path file = ...;
Files.setAttribute(file, "dos:hidden", true);
```

**POSIX 文件权限**

*POSIX*是用于UNIX的可移植操作系统接口的首字母缩写，是一组 IEEE 和 ISO 标准，旨在确保不同版本的 UNIX 之间的互操作性。如果程序符合这些 POSIX 标准，则应该可以轻松移植到其他符合 POSIX 标准的操作系统。

除文件所有者和组所有者外，POSIX还支持九种文件权限：文件所有者、同一组成员以及“其他所有人“的读，写，执行权限。

以下代码段读取给定文件的 POSIX 文件属性并将其打印到标准输出。该代码使用 [`PosixFileAttributes`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributes.html) 类中的方法。

```java
Path file = ...;
PosixFileAttributes attr =
    Files.readAttributes(file, PosixFileAttributes.class);
System.out.format("%s %s %s%n",
    attr.owner().getName(),
    attr.group().getName(),
    PosixFilePermissions.toString(attr.permissions()));
```

[`PosixFilePermissions`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFilePermissions.html) 帮助类提供了几种有用的方法，如下所示：

- 在前面的代码片段中使用的`toString`方法将文件权限转换为字符串（例如，`rw-r--r-- `）。
- `fromString`方法接受表示文件权限的字符串，并构造文件权限的集合`Set`。
- `asFileAttribute`方法接受文件权限的集合`Set`并构造一个可以传递给`Path.createFile`或`Path.createDirectory`方法的文件属性。

以下代码段从一个文件中读取属性并创建一个新文件，将原始文件中的属性分配给新文件：

```java
Path sourceFile = ...;
Path newFile = ...;
PosixFileAttributes attrs =
    Files.readAttributes(sourceFile, PosixFileAttributes.class);
FileAttribute<Set<PosixFilePermission>> attr =
    PosixFilePermissions.asFileAttribute(attrs.permissions());
Files.createFile(file, attr);
```

`asFileAttribute`方法将权限包装为`FileAttribute`。然后，代码尝试使用这些权限创建新文件。请注意，`umask`也适用，因此新文件可能比请求的权限更安全。

要将文件的权限设置为表示为硬编码字符串的值，可以使用以下代码：

```java
Path file = ...;
Set<PosixFilePermission> perms =
    PosixFilePermissions.fromString("rw-------");
FileAttribute<Set<PosixFilePermission>> attr =
    PosixFilePermissions.asFileAttribute(perms);
Files.setPosixFilePermissions(file, perms);
```

 [`Chmod`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Chmod.java) 例子递归修改文件权限，类似于 `chmod` 工具指令。

**设定文件或者组所有者**

要将名称转换为可以存储为文件所有者或组所有者的对象，可以使用 [`UserPrincipalLookupService`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserPrincipalLookupService.html) 服务。此服务将查找名称或组名称字符串，并返回表示该字符串的`UserPrincipal`对象。您可以使用 [`FileSystem.getUserPrincipalLookupService`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getUserPrincipalLookupService--) 方法获取默认文件系统的用户主体查找服务。

以下代码段显示了如何使用`setOwner`方法设置文件所有者：

```java
Path file = ...;
UserPrincipal owner = file.GetFileSystem().getUserPrincipalLookupService()
        .lookupPrincipalByName("sally");
Files.setOwner(file, owner);
```

`Files`类中没有用于设置组所有者的特殊方法。但是，直接执行此操作的安全方法是通过POSIX文件属性视图，如下所示：

```java
Path file = ...;
GroupPrincipal group =
    file.getFileSystem().getUserPrincipalLookupService()
        .lookupPrincipalByGroupName("green");
Files.getFileAttributeView(file, PosixFileAttributeView.class)
     .setGroup(group);
```

**用户自定义文件属性**

如果文件系统实现支持的文件属性不足以满足您的需要，您可以使用`UserDefinedAttributeView`来创建和跟踪您自己的文件属性。

一些实现将此概念映射到NTFS备用数据流等功能以及文件系统（如ext3和ZFS）上的扩展属性。大多数实现都对值的大小施加了限制，例如，ext3将大小限制为4千字节。

通过使用以下代码片段，可以将文件的MIME类型存储为用户定义的属性：

```java
Path file = ...;
UserDefinedFileAttributeView view = Files
    .getFileAttributeView(file, UserDefinedFileAttributeView.class);
view.write("user.mimetype",
           Charset.defaultCharset().encode("text/html");
```

要读取MIME类型属性，您可以使用以下代码段：

```java
Path file = ...;
UserDefinedFileAttributeView view = Files
.getFileAttributeView(file,UserDefinedFileAttributeView.class);
String name = "user.mimetype";
ByteBuffer buf = ByteBuffer.allocate(view.size(name));
view.read(name, buf);
buf.flip();
String value = Charset.defaultCharset().decode(buf).toString();
```

 [`Xdd`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Xdd.java) 示例显示了如何获取，设置和删除用户定义的属性。

------

**注意：** 在Linux中，您可能必须启用扩展属性才能使用户定义的属性起作用。如果在尝试访问用户定义的属性视图时收到`UnsupportedOperationException`，则需要重新挂载文件系统。以下命令使用ext3文件系统的扩展属性重新挂载根分区。如果此命令不适合您的Linux风格，请参阅文档。

```shell
$ sudo mount -o remount,user_xattr /
```

如果要使更改成为永久更改，请添加条目到 `/etc/fstab`。

------

**文件存储属性**

您可以使用 [`FileStore`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileStore.html) 类来了解有关文件存储的信息，例如有多少可用空间。 [`getFileStore(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileStore-java.nio.file.Path-) 方法 获取指定文件的文件存储。

以下代码段打印特定文件所在的文件存储的空间使用情况：

```java
Path file = ...;
FileStore store = Files.getFileStore(file);

long total = store.getTotalSpace() / 1024;
long used = (store.getTotalSpace() -
             store.getUnallocatedSpace()) / 1024;
long avail = store.getUsableSpace() / 1024;
```

 [`DiskUsage`](https://docs.oracle.com/javase/tutorial/essential/io/examples/DiskUsage.java) 示例使用此API打印默认文件系统中所有存储的磁盘空间信息。此示例使用`FileSystem`类中的 [`getFileStores`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getFileStores--) 方法 获取文件系统的所有文件存储。

#### 读、写以及创建文件

This page discusses the details of reading, writing, creating, and opening files. There are a wide array of file I/O methods to choose from. To help make sense of the API, the following diagram arranges the file I/O methods by complexity.

本页讨论了读取，写入，创建和打开文件的细节。有多种文件I/O方法可供选择。为了帮助理解API，下图按复杂性排列文件I/O方法。

![Line drawing with file I/O methods arranged from least complex (on the left) to most complex (on the right).](https://docs.oracle.com/javase/tutorial/figures/essential/io-fileiomethods.gif)

文件 I/O 方法从简单到复杂排列

图的最左边是实用方法`readAllBytes`，`readAllLines`和`write`方法，专为简单的常见情况而设计。在这些方法的右边是用于迭代一行或多行文本的方法，例如`newBufferedReader`，`newBufferedWriter`，然后是`newInputStream`和`newOutputStream`。这些方法可与`java.io`包互操作。这些方法的右边是处理`ByteChannels`，`SeekableByteChannels`和`ByteBuffers`的方法，例如`newByteChannel`方法。最后，最右边的是使用`FileChannel`的方法，用于需要文件锁定或内存映射I/O的高级应用程序。

------

**注意：** 创建新文件的方法使您可以为文件指定一组可选的初始属性。例如，在支持POSIX标准集（例如UNIX）的文件系统上，您可以在创建文件时指定文件所有者，组所有者或文件权限。 [管理元数据](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) 页面介绍了文件属性以及如何访问和设置它们。

------

本章节包括以下几个主题：

- [ `OpenOptions` 参数](https://docs.oracle.com/javase/tutorial/essential/io/file.html#openOptions)
- [为小文件提供的通用方法](https://docs.oracle.com/javase/tutorial/essential/io/file.html#common)
- [文本文件使用的带缓冲的I/O方法](https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles)
- [无缓冲的流使用的方法及可以与 `java.io` APIs 互操作的方法](https://docs.oracle.com/javase/tutorial/essential/io/file.html#streams)
- [Channels 和 `ByteBuffers` 使用的方法](https://docs.oracle.com/javase/tutorial/essential/io/file.html#channels)
- [创建常规文件和临时文件的方法](https://docs.oracle.com/javase/tutorial/essential/io/file.html#creating)

**`OpenOptions` 参数**

本节中的几个方法采用可选的`OpenOptions`参数。此参数是可选的，API会告诉您在未指定时该方法的默认行为。

支持以下`StandardOpenOptions`枚举：

- `WRITE` – 打开文件用于写入。
- `APPEND` – 添加新数据到文件末尾。该选项与`WRITE`或者`CREATE`选项配合使用。
- `TRUNCATE_EXISTING` – 将文件截断为 0 字节。该选项与`WRITE`选项配合使用。
- `CREATE_NEW` – 创建一个新文件，如果文件已经存在，则抛出异常。
- `CREATE` – 如果文件存在则打开，否者创建一个新文件。
- `DELETE_ON_CLOSE` – 当流被关闭时删除文件。此选项对临时文件很有用。
- `SPARSE` – 提示新创建的文件将是稀疏的。此高级选项在某些文件系统（例如NTFS）上使用，其中具有数据“间隙”的大文件可以以更有效的方式存储，其中这些空间隙不占用磁盘空间。
- `SYNC` – 保持文件（内容和元数据）与底层存储设备同步。
- `DSYNC` – 保持文件内容与底层存储设备同步。

**为小文件提供的通用方法**

读取文件中所有字节或所有行

如果你有一个小文件并且想要一次读取它的全部内容，你可以使用 [`readAllBytes(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAllBytes-java.nio.file.Path-) 或 [`readAllLines(Path, Charset)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAllLines-java.nio.file.Path-java.nio.charset.Charset-) 方法。这些方法可以为您完成大部分工作，例如打开和关闭流，但不适用于处理大型文件。以下代码显示了如何使用`readAllBytes`方法：

```java
Path file = ...;
byte[] fileArray;
fileArray = Files.readAllBytes(file);
```

将所有字节或所有行写入文件

你可以使用一个写入方法将字节或者行写入文件。

- [`write(Path, byte[], OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#write-java.nio.file.Path-byte:A-java.nio.file.OpenOption...-)
- [`write(Path, Iterable< extends CharSequence>, Charset, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#write-java.nio.file.Path-java.lang.Iterable-java.nio.charset.Charset-java.nio.file.OpenOption...-)

下面的代码片段展示了如何使用 `write` 方法。

```java
Path file = ...;
byte[] buf = ...;
Files.write(file, buf);
```
**文本文件使用的带缓冲的I/O方法**

`java.nio.file`包支持通道 I/O，它在缓冲区中移动数据，绕过一些可能阻塞流 I/O 的层。

使用带缓冲的流 I/O 读取文件

 [`newBufferedReader(Path, Charset)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedReader-java.nio.file.Path-java.nio.charset.Charset-) 方法打开一个文件进行读取，返回一个`BufferedReader`，可用于以高效的方式从文件中读取文本。

以下代码段显示了如何使用`newBufferedReader`方法从文件中读取。该文件以“US-ASCII”编码。

```java
Charset charset = Charset.forName("US-ASCII");
try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
```

使用带缓冲的流 I/O 写入文件

您可以使用 [`newBufferedWriter(Path, Charset, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedWriter-java.nio.file.Path-java.nio.charset.Charset-java.nio.file.OpenOption...-) 方法使用`BufferedWriter`写入文件。

以下代码段显示了如何使用此方法创建以“US-ASCII”编码的文件：

```java
Charset charset = Charset.forName("US-ASCII");
String s = ...;
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
```

**无缓冲流的方法和可与java.io API互操作的方法**

使用流 I/O 读取文件

要打开文件进行读取，可以使用 [`newInputStream(Path, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newInputStream-java.nio.file.Path-java.nio.file.OpenOption...-) 方法。此方法返回一个无缓冲的输入流，用于从文件中读取字节。

```java
Path file = ...;
try (InputStream in = Files.newInputStream(file);
    BufferedReader reader =
      new BufferedReader(new InputStreamReader(in))) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException x) {
    System.err.println(x);
}
```

使用流 I/O 创建并写入文件

您可以使用 [`newOutputStream(Path, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newOutputStream-java.nio.file.Path-java.nio.file.OpenOption...-) 方法创建文件，附加到文件或写入文件。此方法打开或创建用于写入字节的文件，并返回无缓冲的输出流。

该方法采用可选的`OpenOption`参数。如果未指定打开选项，并且该文件不存在，则会创建一个新文件。如果文件存在，则会被截断。此选项等效于使用`CREATE和TRUNCATE_EXISTING`选项调用该方法。

以下示例打开一个日志文件。如果该文件不存在，则创建该文件。如果该文件存在，则打开该文件以进行追加。

```java
import static java.nio.file.StandardOpenOption.*;
import java.nio.file.*;
import java.io.*;

public class LogFileTest {

  public static void main(String[] args) {

    // Convert the string to a
    // byte array.
    String s = "Hello World! ";
    byte data[] = s.getBytes();
    Path p = Paths.get("./logfile.txt");

    try (OutputStream out = new BufferedOutputStream(
      Files.newOutputStream(p, CREATE, APPEND))) {
      out.write(data, 0, data.length);
    } catch (IOException x) {
      System.err.println(x);
    }
  }
}
```

**Channels和ByteBuffers的方法**

使用通道I / O读取和写入文件

当流 I/O 一次读取一个字符时，通道 I/O 一次读取一个缓冲区。 [`ByteChannel`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ByteChannel.html) 接口提供基本的读写功能。  [`SeekableByteChannel`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html) 是一个`ByteChannel`，它能够维持通道中的位置并改变该位置。`SeekableByteChannel`还支持截断与通道关联的文件并查询文件的大小。

移动到文件中的不同点然后从该位置读取或写入的能力使得可以随机访问文件。有关更多信息，请参阅 [Random Access Files](https://docs.oracle.com/javase/tutorial/essential/io/rafs.html) 。

下面是两个读写通道 I/O 的方法：

- [`newByteChannel(Path, OpenOption...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newByteChannel-java.nio.file.Path-java.nio.file.OpenOption...-)
- [`newByteChannel(Path, Set, FileAttribute...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-)

------

**注意：** `newByteChannel`方法返回`SeekableByteChannel`的实例。使用默认文件系统，您可以将此可搜索字节通道转换为 [`FileChannel`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html) ，从而提供对更高级功能的访问，例如将文件区域直接映射到内存中以便更快地访问，锁定文件的某个区域以便其他进程无法访问它，或者从绝对位置读取和写入字节而不影响通道的当前位置。

------

两种`newByteChannel`方法都允许您指定`OpenOption`选项列表。 除了支持`newOutputStream`方法使用的相同 [open options](https://docs.oracle.com/javase/tutorial/essential/io/file.html#openOptions) ，还有一个选项：需要`READ`，因为`SeekableByteChannel`支持读取和写入。

指定`READ`将打开要读取的通道。指定`WRITE`或`APPEND`会打开要写入的通道。如果未指定这些选项，则打开通道进行读取。

以下代码段读取文件并将其打印到标准输出：

```java
// Defaults to READ
try (SeekableByteChannel sbc = Files.newByteChannel(file)) {
    ByteBuffer buf = ByteBuffer.allocate(10);

    // Read the bytes with the proper encoding for this platform.  If
    // you skip this step, you might see something that looks like
    // Chinese characters when you expect Latin-style characters.
    String encoding = System.getProperty("file.encoding");
    while (sbc.read(buf) > 0) {
        buf.rewind();
        System.out.print(Charset.forName(encoding).decode(buf));
        buf.flip();
    }
} catch (IOException x) {
    System.out.println("caught exception: " + x);
}
```

以下示例是为 UNIX 和其他 POSIX 文件系统编写的，它创建了一个具有一组特定文件权限的日志文件。此代码创建日志文件或附加到日志文件（如果已存在）。创建日志文件时，所有者具有读/写权限，组具有只读权限。

```java
import static java.nio.file.StandardOpenOption.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.*;
import java.util.*;

public class LogFilePermissionsTest {

  public static void main(String[] args) {
  
    // Create the set of options for appending to the file.
    Set<OpenOption> options = new HashSet<OpenOption>();
    options.add(APPEND);
    options.add(CREATE);

    // Create the custom permissions attribute.
    Set<PosixFilePermission> perms =
      PosixFilePermissions.fromString("rw-r-----");
    FileAttribute<Set<PosixFilePermission>> attr =
      PosixFilePermissions.asFileAttribute(perms);

    // Convert the string to a ByteBuffer.
    String s = "Hello World! ";
    byte data[] = s.getBytes();
    ByteBuffer bb = ByteBuffer.wrap(data);
    
    Path file = Paths.get("./permissions.log");

    try (SeekableByteChannel sbc =
      Files.newByteChannel(file, options, attr)) {
      sbc.write(bb);
    } catch (IOException x) {
      System.out.println("Exception thrown: " + x);
    }
  }
}
```

**创建常规文件和临时文件的方法**

创建文件

您可以使用 [`createFile(Path, FileAttribute)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) 方法创建具有初始属性集的空文件。例如，如果在创建时希望文件具有特定的文件权限集，请使用`createFile`方法执行此操作。如果未指定任何属性，则使用默认属性创建文件。如果该文件已存在，则`createFile`将抛出异常。

在单个原子操作中，`createFile`方法检查文件是否存在，并使用指定的属性创建该文件，这使得该过程对恶意代码更安全。

以下代码段创建一个具有默认属性的文件：

```java
Path file = ...;
try {
    // Create the empty file with default permissions, etc.
    Files.createFile(file);
} catch (FileAlreadyExistsException x) {
    System.err.format("file named %s" +
        " already exists%n", file);
} catch (IOException x) {
    // Some other sort of failure, such as permissions.
    System.err.format("createFile error: %s%n", x);
}
```

[POSIX文件权限](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#posix) 有一个示例，它使用 `createFile(Path, FileAttribute<?>)` 来创建具有预设权限的文件。

您还可以使用`newOutputStream`方法创建新文件，如 [使用流 I/O 创建和写入文件](https://docs.oracle.com/javase/tutorial/essential/io/file.html#createStream) 中所述。如果打开新输出流并立即关闭它，则会创建一个空文件。

创建临时文件

您可以使用以下`createTempFile`方法之一创建临时文件：

- [`createTempFile(Path, String, String, FileAttribute)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)
- [`createTempFile(String, String, FileAttribute)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-)

第一种方法允许代码指定临时文件的目录，第二种方法在默认临时文件目录中创建新文件。这两种方法都允许您为文件名指定后缀，第一种方法允许您指定前缀。以下代码段给出了第二种方法的示例：

```java
try {
    Path tempFile = Files.createTempFile(null, ".myapp");
    System.out.format("The temporary file" +
        " has been created: %s%n", tempFile)
;
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
```

运行此文件的结果如下所示：

```
The temporary file has been created: /tmp/509668702974537184.myapp
```

临时文件名的特定格式是特定于平台的。

#### 随机存取文件

*随机访问文件*允许对文件内容进行非顺序或随机访问。要随机访问文件，请打开文件，查找特定位置，然后读取或写入该文件。

使用 [`SeekableByteChannel`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html) 接口可以实现此功能。 `SeekableByteChannel`接口使用当前位置的概念扩展通道 I/O. 使用方法可以设置或查询位置，然后可以从该位置读取数据或将数据写入该位置。API由一些易于使用的方法组成：

- [`position`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position--) – 返回通道的当前位置
- [`position(long)`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position-long-) – 设定通道的当前位置
- [`read(ByteBuffer)`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#read-java.nio.ByteBuffer-) – 从通道读取字节进入缓冲区
- [`write(ByteBuffer)`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#write-java.nio.ByteBuffer-) – 将缓冲区中的字节写入通道
- [`truncate(long)`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#truncate-long-) – 切断文件（或者其它实体）与通道的联系

[使用通道 I/O 读取和写入文件](https://docs.oracle.com/javase/tutorial/essential/io/file.html#channelio)  展示了`Path.newByteChannel`方法返回`SeekableByteChannel`的实例。在默认文件系统上，您可以按原样使用该通道，也可以将其强制转换为 [`FileChannel`](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html) ，以便访问更高级的功能，例如将文件区域直接映射到内存中以便更快地访问，锁定文件区域，或从绝对位置读取和写入字节而不影响通道的当前位置。

以下代码段使用`newByteChannel`方法之一打开用于读取和写入的文件。返回的`SeekableByteChannel`将强制转换为`FileChannel`。然后，从文件的开头读取12个字节，字符串 "I was here!" 是在那个地方写的。文件中的当前位置移动到末尾，并附加从开头的12个字节。最后，字符串， "I was here!" 附加，并关闭文件上的通道。

```java
String s = "I was here!\n";
byte data[] = s.getBytes();
ByteBuffer out = ByteBuffer.wrap(data);

ByteBuffer copy = ByteBuffer.allocate(12);

try (FileChannel fc = (FileChannel.open(file, READ, WRITE))) {
    // Read the first 12
    // bytes of the file.
    int nread;
    do {
        nread = fc.read(copy);
    } while (nread != -1 && copy.hasRemaining());

    // Write "I was here!" at the beginning of the file.
    fc.position(0);
    while (out.hasRemaining())
        fc.write(out);
    out.rewind();

    // Move to the end of the file.  Copy the first 12 bytes to
    // the end of the file.  Then write "I was here!" again.
    long length = fc.size();
    fc.position(length-1);
    copy.flip();
    while (copy.hasRemaining())
        fc.write(copy);
    while (out.hasRemaining())
        fc.write(out);
} catch (IOException x) {
    System.out.println("I/O Exception: " + x);
}
```

#### 创建和读取目录

前面讨论过的一些方法，如`delete`，可以处理文件，链接和目录。但是如何列出文件系统的所有顶层目录？如何列出目录的内容或创建目录？

本节介绍以下特定于目录的功能：

- [列出文件系统根目录](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listall)
- [创建目录](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#create)
- [创建临时目录](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#createTemp)
- [列出目录内容](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listdir)
- [使用通配符过滤目录列表](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#glob)
- [编写你自己的目录过滤器](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#filter)

**列出文件系统根目录**

您可以使用 [`FileSystem.getRootDirectories`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getRootDirectories--) 方法列出文件系统的所有根目录。 此方法返回 `Iterable`，这使您可以使用 [增强的for语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html)  迭代所有根目录。

以下代码段打印默认文件系统的根目录：

```java
Iterable<Path> dirs = FileSystems.getDefault().getRootDirectories();
for (Path name: dirs) {
    System.err.println(name);
}
```

**创建目录**

您可以使用 [`createDirectory(Path, FileAttribute)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) 方法创建新目录。如果未指定任何`FileAttributes`，则新目录将具有默认属性。例如：

```java
Path dir = ...;
Files.createDirectory(path);
```

以下代码段在具有特定权限的POSIX文件系统上创建新目录：

```java
Set<PosixFilePermission> perms =
    PosixFilePermissions.fromString("rwxr-x---");
FileAttribute<Set<PosixFilePermission>> attr =
    PosixFilePermissions.asFileAttribute(perms);
Files.createDirectory(file, attr);
```

要在一个或多个父目录可能尚不存在时创建多个级别的目录，可以使用简便方法 [`createDirectories(Path, FileAttribute)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) 。与 `createDirectory(Path, FileAttribute<?>)` 方法一样，您可以指定一组可选的初始文件属性。以下代码段使用默认属性：

```java
Files.createDirectories(Paths.get("foo/bar/test"));
```

根据需要，从上到下创建目录。在 `foo/bar/test` 示例中，如果`foo`目录不存在，则创建它。接下来，如果需要，将创建`bar`目录，最后创建`test`目录。

创建一些（但不是全部）父目录后，此方法可能会失败。

**创建临时目录**

你可以使用下面的 `createTempDirectory` 方法之一创建临时目录：

- [`createTempDirectory(Path, String, FileAttribute...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-)
- [`createTempDirectory(String, FileAttribute...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.lang.String-java.nio.file.attribute.FileAttribute...-)

第一种方法允许代码指定临时目录的位置，第二种方法在默认的temporary-fle目录中创建新目录。

**列出目录内容**

您可以使用 [`newDirectoryStream(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-) 方法列出目录的所有内容。此方法返回实现 [`DirectoryStream`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.html) 接口的对象。实现 [`DirectoryStream`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.html) 接口的类也实现了 `Iterable`，因此您可以遍历目录流，读取所有对象。这种方法适用于非常大的目录。

------

**请记住：** 返回的`DirectoryStream` 是一个流。如果您没有使用`try-with-resources`语句，请不要忘记在`finally`块中关闭流。`try-with-resources`语句会为您解决此问题。

------

以下代码段显示了如何打印目录的内容：

```java
Path dir = ...;
try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
    for (Path file: stream) {
        System.out.println(file.getFileName());
    }
} catch (IOException | DirectoryIteratorException x) {
    // IOException can never be thrown by the iteration.
    // In this snippet, it can only be thrown by newDirectoryStream.
    System.err.println(x);
}
```

迭代器返回的`Path`对象是针对目录解析的条目的名称。因此，如果要列出`/tmp`目录的内容，则返回的条目格式为 `/tmp/a`，`/tmp/b`，依此类推。

此方法返回目录的全部内容：文件，链接，子目录和隐藏文件。如果您希望对检索的内容更具选择性，可以使用其他 `newDirectoryStream` 方法之一，如本页后面所述。

请注意，如果在目录迭代期间发生异常，则抛出 `DirectoryIteratorException` ，并以`IOException`作为原因。迭代器方法不能抛出异常。

**使用通配符过滤目录列表**

如果只想获取每个名称与特定模式匹配的文件和子目录，可以使用 [`newDirectoryStream(Path, String)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-java.lang.String-) 方法，该方法提供内置的全局过滤器。如果您不熟悉通配符语法，请参阅 [什么是通配符](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob) 。

例如，以下代码段列出了与Java相关的文件：`.class`，`.java`和`.jar`文件：

```java
Path dir = ...;
try (DirectoryStream<Path> stream =
     Files.newDirectoryStream(dir, "*.{java,class,jar}")) {
    for (Path entry: stream) {
        System.out.println(entry.getFileName());
    }
} catch (IOException x) {
    // IOException can never be thrown by the iteration.
    // In this snippet, it can // only be thrown by newDirectoryStream.
    System.err.println(x);
}
```

**编写你自己的目录过滤器**

您可能希望根据模式匹配以外的某些条件过滤目录的内容。您可以通过实现 [`DirectoryStream.Filter`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.Filter.html) 接口来创建自己的过滤器。此接口由一个方法`accept`组成，该方法确定文件是否满足搜索要求。

例如，以下代码段实现了仅检索目录的过滤器：

```java
DirectoryStream.Filter<Path> filter =
    newDirectoryStream.Filter<Path>() {
    public boolean accept(Path file) throws IOException {
        try {
            return (Files.isDirectory(path));
        } catch (IOException x) {
            // Failed to determine if it's a directory.
            System.err.println(x);
            return false;
        }
    }
};
```

创建过滤器后，可以使用 [`newDirectoryStream(Path, DirectoryStream.Filter)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-java.nio.file.DirectoryStream.Filter-) 方法调用它。以下代码段使用`isDirectory`过滤器仅将目录的子目录打印到标准输出：

```java
Path dir = ...;
try (DirectoryStream<Path>
                       stream = Files.newDirectoryStream(dir, filter)) {
    for (Path entry: stream) {
        System.out.println(entry.getFileName());
    }
} catch (IOException x) {
    System.err.println(x);
}
```

此方法仅用于过滤单个目录。但是，如果要查找文件树中的所有子目录，可以使用 [遍历文件树](https://docs.oracle.com/javase/tutorial/essential/io/walk.html) 机制。

#### 符号链接或其它链接

如前所述，`java.nio.file`包，特别是`Path`类，是“链接感知”的。每个`Path`方法都会检测遇到符号链接时要执行的操作，或者它提供了一个选项，使您可以在遇到符号链接时配置行为。

到目前为止的讨论是关于 [符号或软链接](https://docs.oracle.com/javase/tutorial/essential/io/path.html#symlink) ，但一些文件系统也支持硬链接。*硬链接*比符号链接更具限制性，如下所示：

- 链接的目标必须存在。
- 目录上通常不允许使用硬链接。
- 不允许硬链接跨越分区或卷。因此，它们不能跨文件系统存在。
- 硬链接的样子和行为像普通文件一样，因此很难分辨它们。
- 对于所有意图和目的，硬链接是与原始文件相同的实体。它们具有相同的文件权限，时间戳等。所有属性都相同。

由于这些限制，硬链接不像符号链接那样频繁使用，但`Path`方法与硬链接无缝协作。

有几种方法专门处理链接，并在以下部分中介绍：

- [创建符号链接](https://docs.oracle.com/javase/tutorial/essential/io/links.html#symLink)
- [创建硬链接](https://docs.oracle.com/javase/tutorial/essential/io/links.html#hardLink)
- [删除符号链接](https://docs.oracle.com/javase/tutorial/essential/io/links.html#detect)
- [寻找链接的目标](https://docs.oracle.com/javase/tutorial/essential/io/links.html#read)

**创建符号链接**

如果文件系统支持，则可以使用 [`createSymbolicLink(Path, Path, FileAttribute)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createSymbolicLink-java.nio.file.Path-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) 方法创建符号链接。第二个`Path`参数表示目标文件或目录，可能存在也可能不存在。以下代码段创建了具有默认权限的符号链接：

```java
Path newLink = ...;
Path target = ...;
try {
    Files.createSymbolicLink(newLink, target);
} catch (IOException x) {
    System.err.println(x);
} catch (UnsupportedOperationException x) {
    // Some file systems do not support symbolic links.
    System.err.println(x);
}
```

`FileAttributes` 可变参数使您可以指定在创建链接时以原子方式设置的初始文件属性。但是，此参数仅供将来使用，目前尚未实现。

**创建硬链接**

您可以使用 [`createLink(Path, Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createLink-java.nio.file.Path-java.nio.file.Path-) 方法创建指向现有文件的硬（或常规）链接。第二个`Path`参数定位现有文件，它必须存在或抛出`NoSuchFileException`。以下代码段显示了如何创建链接：

```java
Path newLink = ...;
Path existingFile = ...;
try {
    Files.createLink(newLink, existingFile);
} catch (IOException x) {
    System.err.println(x);
} catch (UnsupportedOperationException x) {
    // Some file systems do not
    // support adding an existing
    // file to a directory.
    System.err.println(x);
}
```

**删除符号链接**

要确定`Path`实例是否为符号链接，可以使用 [`isSymbolicLink(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSymbolicLink-java.nio.file.Path-) 方法。以下代码段显示了如何使用：

```java
Path file = ...;
boolean isSymbolicLink =
    Files.isSymbolicLink(file);
```

更多信息，参考 [管理元数据](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html).

**寻找链接的目标**

您可以使用 [`readSymbolicLink(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readSymbolicLink-java.nio.file.Path-) 方法获取符号链接的目标，如下所示：

```java
Path link = ...;
try {
    System.out.format("Target of link" +
        " '%s' is '%s'%n", link,
        Files.readSymbolicLink(link));
} catch (IOException x) {
    System.err.println(x);
}
```

如果`Path`不是符号链接，则此方法将抛出`NotLinkException`。

#### 遍历文件树

您是否需要创建一个递归访问文件树中所有文件的应用程序？ 也许您需要删除树中的每个`.class`文件，或查找去年未访问过的每个文件。您可以使用`FileVisitor`接口执行此操作。

本章节涵盖以下内容：

- [`FileVisitor` 接口](https://docs.oracle.com/javase/tutorial/essential/io/walk.html#filevisitor)
- [启动流程](https://docs.oracle.com/javase/tutorial/essential/io/walk.html#invoke)
- [考虑何时创建 `FileVisitor`](https://docs.oracle.com/javase/tutorial/essential/io/walk.html#order)
- [流程控制](https://docs.oracle.com/javase/tutorial/essential/io/walk.html#return)
- [实例](https://docs.oracle.com/javase/tutorial/essential/io/walk.html#ex)

**`FileVisitor` 接口**

要遍历文件树，首先需要实现`FileVisitor`。`FileVisitor`指定遍历过程中关键点所需的行为：访问文件时，访问目录之前，访问目录之后，或发生故障时。该接口有四种方法对应于这些情况：

- [`preVisitDirectory`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#preVisitDirectory-T-java.nio.file.attribute.BasicFileAttributes-) – 目录实体被访问之前被调用。
- [`postVisitDirectory`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#postVisitDirectory-T-java.io.IOException-) – 目录下所有实体都被访问之后被调用。如果发生异常，特定异常会被传递给此方法。
- [`visitFile`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#visitFile-T-java.nio.file.attribute.BasicFileAttributes-) – 当文件被访问时被调用。文件的 `BasicFileAttributes` 属性被传递给此方法，或者你可以使用 [file attributes](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) 包读取特定属性集合。比如，你可以选择读取文件的 `DosFileAttributeView` 属性来确定该文件是否设置了“隐藏”位。
- [`visitFileFailed`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#visitFileFailedy-T-java.io.IOException-) – 无法访问文件时调用。特定异常传递给该方法。您可以选择是抛出异常，将其打印到控制台还是日志文件，等等。

如果您不需要实现所有四个`FileVisitor`方法，而不是实现`FileVisitor`接口，则可以扩展`SimpleFileVisitor`类。此类实现`FileVisitor`接口，访问树中的所有文件，并在遇到错误时抛出`IOError`。您可以扩展此类并仅覆盖所需的方法。

下面是一个扩展`SimpleFileVisitor`以打印文件树中所有条目的示例。它打印条目是条目是常规文件，符号链接，目录或者其他“未指定”类型的文件。它还会打印每个文件的大小（以字节为单位）。遇到的任何异常都会打印到控制台。

`FileVisitor` 方法以粗体字表示：

```java
import static java.nio.file.FileVisitResult.*;

public static class PrintFiles
    extends SimpleFileVisitor<Path> {

    // Print information about
    // each type of file.
    @Override
    public FileVisitResult visitFile(Path file,
                                   BasicFileAttributes attr) {
        if (attr.isSymbolicLink()) {
            System.out.format("Symbolic link: %s ", file);
        } else if (attr.isRegularFile()) {
            System.out.format("Regular file: %s ", file);
        } else {
            System.out.format("Other: %s ", file);
        }
        System.out.println("(" + attr.size() + "bytes)");
        return CONTINUE;
    }

    // Print each directory visited.
    @Override
    public FileVisitResult postVisitDirectory(Path dir,
                                          IOException exc) {
        System.out.format("Directory: %s%n", dir);
        return CONTINUE;
    }

    // If there is some error accessing
    // the file, let the user know.
    // If you don't override this method
    // and an error occurs, an IOException 
    // is thrown.
    @Override
    public FileVisitResult visitFileFailed(Path file,
                                       IOException exc) {
        System.err.println(exc);
        return CONTINUE;
    }
}
```

**启动流程**

一旦实现了`FileVisitor`，如何启动文件遍历？`Files`类中有两个`walkFileTree`方法。

- [`walkFileTree(Path, FileVisitor)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walkFileTree-java.nio.file.Path-java.nio.file.FileVisitor-)
- [`walkFileTree(Path, Set, int, FileVisitor)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-)

第一种方法只需要指定遍历的起点和`FileVisitor`实例。您可以按如下方式调用`PrintFiles`文件访问者：

```java
Path startingDir = ...;
PrintFiles pf = new PrintFiles();
Files.walkFileTree(startingDir, pf);
```

第二个`walkFileTree`方法使您可以另外指定访问目录层级数和一组`FileVisitOption`枚举的限制。如果要确保此方法遍历整个文件树，可以为最大深度参数指定`Integer.MAX_VALUE`。

您可以指定`FileVisitOption`枚举，`FOLLOW_LINKS`，表示应遵循符号链接。

此代码段显示了如何调用四参数方法：

```java
import static java.nio.file.FileVisitResult.*;

Path startingDir = ...;

EnumSet<FileVisitOption> opts = EnumSet.of(FOLLOW_LINKS);

Finder finder = new Finder(pattern);
Files.walkFileTree(startingDir, opts, Integer.MAX_VALUE, finder);
```

**考虑何时创建文件访问器**

首先深度遍历文件树，但是您不能对访问子目录的迭代顺序做出任何假设。

如果您的程序将更改文件系统，则需要仔细考虑如何实现`FileVisitor`。

例如，如果您正在编写递归删除，则首先删除目录中的文件，然后再删除目录本身。在这种情况下，您需要在`postVisitDirectory`中删除目录。

如果您正在编写递归拷贝，则需要在尝试将文件复制到`preVisitDirectory`之前（在`visitFiles`中）创建新目录。如果要保留源目录的属性（类似于UNIX `cp -p`命令），则需要在`postVisitDirectory`中复制文件后执行此操作。复制示例展示了如何执行此操作。

如果您正在编写文件搜索，则在`visitFile`方法中执行比较。此方法查找符合条件的所有文件，但不查找目录。如果要查找文件和目录，还必须在`preVisitDirectory`或`postVisitDirectory`方法中执行比较。`Find`示例展示了如何执行此操作。

您需要决定是否要遵循符号链接。例如，如果要删除文件，则可能不建议使用符号链接。如果要复制文件树，则可能需要允许它。默认情况下，`walkFileTree`不遵循符号链接。

为文件调用`visitFile`方法。如果已指定`FOLLOW_LINKS`选项，并且文件树具有指向父目录的循环链接，则使用`FileSystemLoopException`在`visitFileFailed`方法中报告循环目录。以下来自 [`Copy`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java) 的代码段展示了如何捕获循环链接：

```java
@Override
public FileVisitResult
    visitFileFailed(Path file,
        IOException exc) {
    if (exc instanceof FileSystemLoopException) {
        System.err.println("cycle detected: " + file);
    } else {
        System.err.format("Unable to copy:" + " %s: %s%n", file, exc);
    }
    return CONTINUE;
}
```

这种情况只会发生在程序遵循符号链接时。

**流程控制**

也许您想要遍历文件树以查找特定目录，并且在找到时，您希望该进程终止。也许你想跳过特定的目录。

`FileVisitor`方法返回 [`FileVisitResult`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitResult.html) 值。您可以使用在`FileVisitor`方法中返回的值中止文件遍历过程或控制是否访问目录：

- `CONTINUE` – 表示文件遍历应继续。如果`preVisitDirectory`方法返回`CONTINUE`，则访问该目录。
- `TERMINATE` – 立即终止文件遍历。此值返回之后不会再有文件遍历方法被调用。
- `SKIP_SUBTREE` – 当 `preVisitDirectory` 返回此值，特定目录及其子目录被跳过。该分支被从目录树上修剪出去。
- `SKIP_SIBLINGS` – 当 `preVisitDirectory` 返回此值时，不访问特定目录，`postVisitDirectory` 不会被调用，未被访问的兄弟都不再会被访问。如果改值由 `postVisitDirectory` 方法返回，兄弟目录或文件就不再会被访问。基本上，特定目录中不会有后续访问发生。

下面的代码片段中，名为 `SCCS` 的目录被跳过：

```java
import static java.nio.file.FileVisitResult.*;

public FileVisitResult
     preVisitDirectory(Path dir,
         BasicFileAttributes attrs) {
    (if (dir.getFileName().toString().equals("SCCS")) {
         return SKIP_SUBTREE;
    }
    return CONTINUE;
}
```

下面的代码片段中，一旦特定文件被找到，文件名就会被打印输出到标准输出，同时文件遍历过程结束。

```java
import static java.nio.file.FileVisitResult.*;

// The file we are looking for.
Path lookingFor = ...;

public FileVisitResult
    visitFile(Path file,
        BasicFileAttributes attr) {
    if (file.getFileName().equals(lookingFor)) {
        System.out.println("Located file: " + file);
        return TERMINATE;
    }
    return CONTINUE;
}
```

**实例**

下面的例子展示了文件遍历机制：

- [`Find`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Find.java) – 递归遍历文件树寻找符合符合特定通配符模式的文件或者目录。该实例在 [查找文件](https://docs.oracle.com/javase/tutorial/essential/io/find.html) 章节中介绍。
- [`Chmod`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Chmod.java) – 递归修改文件树的权限（仅适用于 POSIX 系统）。
- [`Copy`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java) – 递归拷贝文件树。
- [`WatchDir`](https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java) – 演示监视目录以查找已创建，删除或修改的文件的机制。使用`-r`选项调用此程序会监视整个树以进行更改。有关文件通知服务的详细信息，请参阅 [查看目录以进行更改](https://docs.oracle.com/javase/tutorial/essential/io/notification.html) 。

#### 查找文件

如果您曾经使用过shell脚本，则很可能使用模式匹配来查找文件。事实上，你可能已经广泛使用它了。如果您还没有使用它，模式匹配使用特殊字符来创建模式，然后可以将文件名与该模式进行比较。例如，在大多数shell脚本中，星号`*`匹配任意数量的字符。例如，以下命令列出当前目录中以`.html`结尾的所有文件：

```
% ls *.html
```

`java.nio.file`包为此有用功能提供了编程支持。每个文件系统实现都提供 [`PathMatcher`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html)。您可以使用`FileSystem`类中的 [`getPathMatcher(String)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-) 方法检索文件系统的`PathMatcher`。以下代码段获取默认文件系统的路径匹配器：

```java
String pattern = ...;
PathMatcher matcher =
    FileSystems.getDefault().getPathMatcher("glob:" + pattern);
```

传递给`getPathMatcher`的字符串参数指定语法风格和要匹配的模式。此示例指定通配符语法。如果您不熟悉通配符语法，请参阅 [什么是通配符](https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob) 。

通配符语法易于使用且灵活，但如果您愿意，还可以使用正则表达式或*正则*语法。有关正则表达式的更多信息，请参阅 [正则表达式](https://docs.oracle.com/javase/tutorial/essential/regex/index.html) 。某些文件系统实现可能支持其他语法。

如果要使用其他形式的基于字符串的模式匹配，可以创建自己的`PathMatcher`类。此页面中的示例使用通配符语法。

一旦创建了`PathMatcher`实例，就可以将文件与文件进行匹配。`PathMatcher`接口有一个方法 [`matches`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html#matches-java.nio.file.Path-) ，它接受一个`Path` 参数并返回一个布尔值：它匹配模式，或者不匹配。以下代码段查找以`.java`或`.class`结尾的文件，并将这些文件打印到标准输出：

```java
PathMatcher matcher =
    FileSystems.getDefault().getPathMatcher("glob:*.{java,class}");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
```

**递归模式匹配**

搜索与特定模式匹配的文件与遍历文件树同时进行。有多少次你知道文件在文件系统的某个地方，但具体在哪里？ 或者您可能需要在文件树中找到具有特定文件扩展名的所有文件。

`Find`示例就是这样做的。`Find`类似于UNIX的`find`实用程序，但在功能上已经减少了。您可以扩展此示例以包含其他功能。例如，`find`实用程序支持`-prune`标志以从搜索中排除整个子树。您可以通过在`preVisitDirectory`方法中返回`SKIP_SUBTREE`来实现该功能。要实现符号链接后面的`-L`选项，可以使用四参数`walkFileTree`方法并传入`FOLLOW_LINKS`枚举（但请确保在`visitFile`方法中测试循环链接）。

要运行`Find`应用程序，请使用以下格式：

```
% java Find <path> -name "<glob_pattern>"
```

模式放在引号内，因此shell不会解释任何通配符。 例如：

```
% java Find . -name "*.html"
```

以下是`Find`示例的源代码：

```java
/**
 * Sample code that finds files that match the specified glob pattern.
 * For more information on what constitutes a glob pattern, see
 * https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob
 *
 * The file or directories that match the pattern are printed to
 * standard out.  The number of matches is also printed.
 *
 * When executing this application, you must put the glob pattern
 * in quotes, so the shell will not expand any wild cards:
 *              java Find . -name "*.java"
 */

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import static java.nio.file.FileVisitResult.*;
import static java.nio.file.FileVisitOption.*;
import java.util.*;


public class Find {

    public static class Finder
        extends SimpleFileVisitor<Path> {

        private final PathMatcher matcher;
        private int numMatches = 0;

        Finder(String pattern) {
            matcher = FileSystems.getDefault()
                    .getPathMatcher("glob:" + pattern);
        }

        // Compares the glob pattern against
        // the file or directory name.
        void find(Path file) {
            Path name = file.getFileName();
            if (name != null && matcher.matches(name)) {
                numMatches++;
                System.out.println(file);
            }
        }

        // Prints the total number of
        // matches to standard out.
        void done() {
            System.out.println("Matched: "
                + numMatches);
        }

        // Invoke the pattern matching
        // method on each file.
        @Override
        public FileVisitResult visitFile(Path file,
                BasicFileAttributes attrs) {
            find(file);
            return CONTINUE;
        }

        // Invoke the pattern matching
        // method on each directory.
        @Override
        public FileVisitResult preVisitDirectory(Path dir,
                BasicFileAttributes attrs) {
            find(dir);
            return CONTINUE;
        }

        @Override
        public FileVisitResult visitFileFailed(Path file,
                IOException exc) {
            System.err.println(exc);
            return CONTINUE;
        }
    }

    static void usage() {
        System.err.println("java Find <path>" +
            " -name \"<glob_pattern>\"");
        System.exit(-1);
    }

    public static void main(String[] args)
        throws IOException {

        if (args.length < 3 || !args[1].equals("-name"))
            usage();

        Path startingDir = Paths.get(args[0]);
        String pattern = args[2];

        Finder finder = new Finder(pattern);
        Files.walkFileTree(startingDir, finder);
        finder.done();
    }
}
```

递归遍历文件树内容在 [遍历文件树](https://docs.oracle.com/javase/tutorial/essential/io/walk.html) 中介绍。

#### 监控目录和文件变化

您是否曾经发现自己使用IDE或其他编辑器编辑文件，并出现一个对话框，通知您文件系统中的某个打开文件已更改并需要重新加载？ 或者，与NetBeans IDE一样，应用程序只是在不通知您的情况下安静地更新文件。以下示例对话框显示了此通知在免费编辑器 [jEdit](http://sourceforge.net/projects/jedit/) 中的显示方式：

![Sample jEdit Dialog stating: The following files were changed on disk by another program.](https://docs.oracle.com/javase/tutorial/figures/essential/io-jEditDialog.png)

`jEdit`对话框显示检测到修改过的文件

要实现此功能（称为文件更改通知），程序必须能够检测文件系统上相关目录的内容。一种方法是轮询文件系统以查找更改，但这种方法效率低下。它不能扩展到具有数百个要监视的打开文件或目录的应用程序。

`java.nio.file`包提供了一个名为`Watch Service API`的文件更改通知API。此API使您可以使用监视服务注册目录（或多个目录）。注册时，您告诉服务您感兴趣的事件类型：文件创建，文件删除或文件修改。当服务检测到感兴趣的事件时，它将被转发到注册的进程。已注册的进程有一个线程（或一个线程池），专门用于监视它已注册的任何事件。当一个事件进入时，它会根据需要进行处理。

本章节涵盖以下内容：

- [监控服务概览](https://docs.oracle.com/javase/tutorial/essential/io/notification.html#overview)
- [试一试](https://docs.oracle.com/javase/tutorial/essential/io/notification.html#try)
- [创建监控服务并注册事件](https://docs.oracle.com/javase/tutorial/essential/io/notification.html#register)
- [事件处理](https://docs.oracle.com/javase/tutorial/essential/io/notification.html#process)
- [获取文件名](https://docs.oracle.com/javase/tutorial/essential/io/notification.html#name)
- [此 API 的使用时机](https://docs.oracle.com/javase/tutorial/essential/io/notification.html#concerns)

**监控服务概览**

`WatchService` API相当底层，允许自定义。您可以按原样使用它，也可以选择在此机制之上创建高级API，以便它适合您的特定需求。

以下是实现监视服务所需的基本步骤：

- 为文件系统创建`WatchService` “观察者”。
- 对于要监视的每个目录，请将其注册到观察程序。注册目录时，您可以指定要通知的事件类型。您为每个注册的目录收到一个`WatchKey`实例。
- 实现无限循环以等待传入事件。当事件发生时，`WatchKey`将发出信号并放入观察者的队列中。
- 从观察者的队列中检索`WatchKey`。您可以从`WatchKey`中获取文件名。
- 检索`WatchKey`的每个待处理事件（可能有多个事件）并根据需要进行处理。
- 重置`WatchKey`，然后继续等待事件。
- 关闭服务：当线程退出或关闭时（通过调用其`closed`方法），监视服务退出。

`WatchKeys`是线程安全的，可以与`java.nio.concurrent`包一起使用。您可以将 [线程池](https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html) 专用于此工作。

**试一试**

因为此API更高级，所以在继续之前尝试一下。将 [`WatchDir`](https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java) 示例保存到您的计算机，然后进行编译。创建将传递给示例的`test`目录。`WatchDir`使用单个线程来处理所有事件，因此它在等待事件时阻止键盘输入。在单独的窗口中或在后台运行程序，如下所示：

```
java WatchDir test &
```

在`test`目录中创建，删除和编辑文件。发生任何这些事件时，会向控制台输出一条消息。完成后，删除`test`目录并退出`WatchDir`。或者，如果您愿意，可以手动终止该过程。

您还可以通过指定`-r`选项来查看整个文件树。指定`-r`时，`WatchDir`遍历文件树，使用监视服务注册每个目录。

**创建监控服务并注册事件**

第一步是使用`FileSystem`类中的 [`newWatchService`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#newWatchService--) 方法创建一个新的 [`WatchService`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html) ，如下所示：

```java
WatchService watcher = FileSystems.getDefault().newWatchService();
```

接下来，使用监视服务注册一个或多个对象。可以注册实现 [`Watchable`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Watchable.html) 接口的任何对象。`Path`类实现`Watchable`接口，因此每个要监视的目录都注册为`Path`对象。

与任何`Watchable`一样，`Path类`实现两个 `register` 方法。此页面使用双参数版本， [`register(WatchService, WatchEvent.Kind...)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind...-) 。（三参数版本采用`WatchEvent.Modifier`，目前尚未实现。）

使用监视服务注册对象时，可以指定要监视的事件类型。支持的 [`StandardWatchEventKinds`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/StandardWatchEventKinds.html) 事件类型如下：

- `ENTRY_CREATE` – 目录实体被创建
- `ENTRY_DELETE` – 目录实体被删除
- `ENTRY_MODIFY` – 目录实体被修改
- `OVERFLOW` – 表示事件可能已丢失或丢弃。您无需注册`OVERFLOW`事件即可接收它。

以下代码段显示了如何为所有三种事件类型注册`Path`实例：

```java
import static java.nio.file.StandardWatchEventKinds.*;

Path dir = ...;
try {
    WatchKey key = dir.register(watcher,
                           ENTRY_CREATE,
                           ENTRY_DELETE,
                           ENTRY_MODIFY);
} catch (IOException x) {
    System.err.println(x);
}
```

**事件处理**

事件处理循环中事件的顺序如下：

1. 获取一个`WatchKey`。提供了3个方法：
   - [`poll`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#poll--) – 返回排队的键（如果可用）。如果不可用，则立即返回`null`值。
   - [`poll(long, TimeUnit)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#poll-long-java.util.concurrent.TimeUnit-) – 返回排队的键（如果有）。如果排队的键不能立即可用，程序将等待指定的时间。`TimeUnit`参数确定指定的时间是纳秒，毫秒还是某个其他时间单位。
   - [`take`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#take--) – 返回排队的键。如果没有可用的排队键，则此方法将等待。
2. 处理`WatchKey`对应的等待事件。您从 [`pollEvents`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html#pollEvents--) 方法获取 [`WatchEvents`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html) 的 `List` 。
3. 使用 [`kind`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#kind--) 方法检索事件类型。无论`WatchKey`注册的是什么事件，都可以收到`OVERFLOW`事件。您可以选择处理它或忽略它，但您应该测试这种情况。
4. 检索与事件关联的文件名。文件名存储为事件的上下文，因此 [`context`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#context--) 方法用于检索它。
5. 处理完`WatchKey`事件后，需要通过调用 [`reset`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#reset--) 将`WatchKey`恢复到 `ready` 状态。如果此方法返回`false`，则该`WatchKey`不再有效，并且循环可以退出。这一步非常重要。如果您未能调用`reset`，则此`WatchKey`不会再接收任何事件。

`WatchKey`是有状态的，在任何给定时刻，它的状态可能是下面中的一个：

- `Ready` 表示`WatchKey`已准备好接受事件。首次创建时，`WatchKey`处于就绪状态。
- `Signaled` 表示一个或多个事件已排队。一旦发出`WatchKey`信号，它就不再处于就绪状态，直到调用 [`reset`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html#reset--) 方法。
- `Invalid` 表示`WatchKey`不再有效。发生以下事件之一时会进入此状态：
  - 该过程使用 [`cancel`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html#cancel--) 方法明确取消`WatchKey`。
  - 目录变为不可访问。
  - 监控服务被 [关闭](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#close--) 。

以下是事件处理循环的示例。它取自 [`Email`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java) 示例，该示例监视目录，等待新文件出现。当新文件可用时，将使用 [`probeContentType(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#probeContentType-java.nio.file.Path-) 方法检查它是否为`text/plain`文件。目的是将`text/plain`文件通过电子邮件发送到一个地址别名，但该实现细节留给读者。

监控服务API特有的方法以粗体显示：

```java
for (;;) {

    // wait for key to be signaled
    WatchKey key;
    try {
        key = watcher.take();
    } catch (InterruptedException x) {
        return;
    }

    for (WatchEvent<?> event: key.pollEvents()) {
        WatchEvent.Kind<?> kind = event.kind();

        // This key is registered only
        // for ENTRY_CREATE events,
        // but an OVERFLOW event can
        // occur regardless if events
        // are lost or discarded.
        if (kind == OVERFLOW) {
            continue;
        }

        // The filename is the
        // context of the event.
        WatchEvent<Path> ev = (WatchEvent<Path>)event;
        Path filename = ev.context();

        // Verify that the new
        //  file is a text file.
        try {
            // Resolve the filename against the directory.
            // If the filename is "test" and the directory is "foo",
            // the resolved name is "test/foo".
            Path child = dir.resolve(filename);
            if (!Files.probeContentType(child).equals("text/plain")) {
                System.err.format("New file '%s'" +
                    " is not a plain text file.%n", filename);
                continue;
            }
        } catch (IOException x) {
            System.err.println(x);
            continue;
        }

        // Email the file to the
        //  specified email alias.
        System.out.format("Emailing file %s%n", filename);
        //Details left to reader....
    }

    // Reset the key -- this step is critical if you want to
    // receive further watch events.  If the key is no longer valid,
    // the directory is inaccessible so exit the loop.
    boolean valid = key.reset();
    if (!valid) {
        break;
    }
}
```

**获取文件名**

从事件上下文中检索文件名。[`Email`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java) 示例使用以下代码检索文件名：

```java
WatchEvent<Path> ev = (WatchEvent<Path>)event;
Path filename = ev.context();
```

编译 `Email` 示例时，它会生成以下错误：

```
Note: Email.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
```

此错误是将`WatchEvent<T>`强制转换为 `WatchEvent<Path>`的代码行的结果。[`WatchDir`](https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java) 示例通过创建一个抑制未经检查的警告的实用程序强制转换方法来避免此错误，如下所示：

```java
@SuppressWarnings("unchecked")
static <T> WatchEvent<T> cast(WatchEvent<?> event) {
    return (WatchEvent<Path>)event;
}
```

如果不熟悉 `@SuppressWarnings` 语法，参考 [注解](https://docs.oracle.com/javase/tutorial/java/annotations/index.html) 。

**使用时机**

Watch Service API专为需要通知文件更改事件的应用程序而设计。它非常适合任何应用程序，如编辑器或IDE，可能有许多打开的文件，需要确保文件与文件系统同步。它也非常适合于监视目录的应用程序服务器，可能等待`.jsp`或`.jar`文件变化，以便随时部署它们。

此API不适用于索引硬盘驱动器。大多数文件系统实现都具有文件更改通知的本机支持。Watch Service API在可用的情况下利用此支持。但是，当文件系统不支持此机制时，Watch Service将轮询文件系统，等待事件。

#### 其它有用的方法

一些有用的方法不适用于本课程的其他地方，在此处介绍。本节包括以下内容：

- [确定`MIME`类型](https://docs.oracle.com/javase/tutorial/essential/io/misc.html#mime)
- [默认文件系统](https://docs.oracle.com/javase/tutorial/essential/io/misc.html#default)
- [路径分隔符](https://docs.oracle.com/javase/tutorial/essential/io/misc.html#separator)
- [文件系统文件存储](https://docs.oracle.com/javase/tutorial/essential/io/misc.html#stores)

**确定`MIME`类型**

要确定文件的MIME类型，您可能会发现 [`probeContentType(Path)`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#probeContentType-java.nio.file.Path-) 方法很有用。 例如：T

```java
try {
    String type = Files.probeContentType(filename);
    if (type == null) {
        System.err.format("'%s' has an" + " unknown filetype.%n", filename);
    } else if (!type.equals("text/plain") {
        System.err.format("'%s' is not" + " a plain text file.%n", filename);
        continue;
    }
} catch (IOException x) {
    System.err.println(x);
}
```

请注意，如果无法确定内容类型，则 `probeContentType` 将返回`null`。

此方法的实现具有高度平台相关性，并非绝对可靠。内容类型由平台的默认文件类型检测器确定。例如，如果检测器根据`.class`扩展名将文件的内容类型确定为`application/x-java`，则可能会被欺骗。

如果默认值不足以满足您的需要，您可以提供自定义 [`FileTypeDetector`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/spi/FileTypeDetector.html) 。

 [`Email`](https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java) 示例使用 `probeContentType`方法。

**默认文件系统**

要检索默认文件系统，请使用 [`getDefault`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystems.html#getDefault--) 方法。通常，这个 `FileSystems` 方法（注意复数）被链接到 `FileSystem` 方法之一（注意单数），如下所示：

```java
PathMatcher matcher =
    FileSystems.getDefault().getPathMatcher("glob:*.*");
```

**路径分隔符**

POSIX文件系统的路径分隔符是正斜杠，`/`，对于Microsoft Windows，是反斜杠`\`。其他文件系统可能使用其他分隔符。要检索默认文件系统的路径分隔符，可以使用以下方法之一：

```java
String separator = File.separator;
String separator = FileSystems.getDefault().getSeparator();
```

 [`getSeparator`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getSeparator--) 方法还用于检索任何可用文件系统的路径分隔符。

**文件系统的文件存储**

文件系统具有一个或多个文件存储来保存其文件和目录。文件存储表示底层存储设备。在UNIX操作系统中，每个安装的文件系统都由文件存储表示。在Microsoft Windows中，每个卷都由文件存储表示：`C:`，`D:`，依此类推。

要检索文件系统的所有文件存储列表，可以使用 [`getFileStores`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getFileStores--) 方法。此方法返回一个`Iterable`，它允许您使用增强的for语句迭代所有根目录。

```java
for (FileStore store: FileSystems.getDefault().getFileStores()) {
   ...
}
```

如果要检索特定文件所在的文件存储，请使用`Files`类中的 [`getFileStore`](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileStore-java.nio.file.Path-) 方法，如下所示：

```java
Path file = ...;
FileStore store= Files.getFileStore(file);
```

 [`DiskUsage`](https://docs.oracle.com/javase/tutorial/essential/io/examples/DiskUsage.java) 示例使用 `getFileStores` 方法。

#### 遗留文件 I/O 代码

**与遗留代码互操作**

在Java SE 7发布之前，`java.io.File`类是用于文件I/O的机制，但它有几个缺点。

- 许多方法在失败时都没有抛出异常，因此无法获得有用的错误消息。例如，如果文件删除失败，程序将收到“删除失败”，但不知道是否因为该文件不存在，用户没有权限，或者还有其他问题。
- 重命名方法不能跨平台一致地工作。
- 对符号链接没有真正的支持。
- 需要更多对元数据的支持，例如文件权限，文件所有者和其他安全属性。
- 访问文件元数据效率低下。
- 许多`File`方法都没有扩展。通过服务器请求大型目录列表可能会导致挂起。大目录也可能导致内存资源问题，导致拒绝服务。
- 如果存在循环符号链接，则无法编写可递归遍历文件树的可靠代码并进行适当响应。

也许你有遗留代码使用`java.io.File`并希望利用`java.nio.file.Path`功能，而对代码的影响最小。

`java.io.File`类提供了`toPath`方法，该方法将旧样式`File`实例转换为`java.nio.file.Path`实例，如下所示：

```java
Path input = file.toPath();
```

然后，您可以利用`Path`类可用的丰富功能集。

例如，假设您有一些删除文件的代码：

```java
file.delete();
```

您可以修改此代码以使用`Files.delete`方法，如下所示：

```java
Path fp = file.toPath();
Files.delete(fp);
```

相反，`Path.toFile`方法为`Path`对象构造`java.io.File`对象。

**`java.io.File`功能映射到`java.nio.file`**

由于文件I/O的Java实现已在Java SE 7发行版中完全重新构建，因此您无法将一种方法替换为另一种方法。如果要使用`java.nio.file`包提供的丰富功能，最简单的解决方案是使用上一节中建议的`File.toPath`方法。但是，如果您不想使用该方法或者它不足以满足您的需求，则必须重写文件I/O代码。

这两个API之间没有一对一的对应关系，但是下表让您全面了解`java.io.File` API中的哪些功能在`java.nio.file` API中映射到哪里，并告诉您哪里可以获取更多信息。

| java.io.File Functionality               | java.nio.file Functionality              | Tutorial Coverage                        |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| `java.io.File`                           | `java.nio.file.Path`                     | [The Path Class](https://docs.oracle.com/javase/tutorial/essential/io/pathClass.html) |
| `java.io.RandomAccessFile`               | The `SeekableByteChannel` functionality. | [Random Access Files](https://docs.oracle.com/javase/tutorial/essential/io/rafs.html) |
| `File.canRead`, `canWrite`, `canExecute` | `Files.isReadable`, `Files.isWritable`, and `Files.isExecutable`.On UNIX file systems, the [Managing Metadata (File and File Store Attributes)](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) package is used to check the nine file permissions. | [Checking a File or Directory](https://docs.oracle.com/javase/tutorial/essential/io/check.html)[Managing Metadata](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) |
| `File.isDirectory()`, `File.isFile()`, and `File.length()` | `Files.isDirectory(Path, LinkOption...)`, `Files.isRegularFile(Path, LinkOption...)`, and `Files.size(Path)` | [Managing Metadata](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) |
| `File.lastModified()` and `File.setLastModified(long)` | `Files.getLastModifiedTime(Path, LinkOption...)` and `Files.setLastMOdifiedTime(Path, FileTime)` | [Managing Metadata](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) |
| The `File` methods that set various attributes: `setExecutable`, `setReadable`, `setReadOnly`, `setWritable` | These methods are replaced by the `Files` method `setAttribute(Path, String, Object, LinkOption...)`. | [Managing Metadata](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html) |
| `new File(parent, "newfile")`            | `parent.resolve("newfile")`              | [Path Operations](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html) |
| `File.renameTo`                          | `Files.move`                             | [Moving a File or Directory](https://docs.oracle.com/javase/tutorial/essential/io/move.html) |
| `File.delete`                            | `Files.delete`                           | [Deleting a File or Directory](https://docs.oracle.com/javase/tutorial/essential/io/delete.html) |
| `File.createNewFile`                     | `Files.createFile`                       | [Creating Files](https://docs.oracle.com/javase/tutorial/essential/io/file.html#createFile) |
| `File.deleteOnExit`                      | Replaced by the `DELETE_ON_CLOSE` option specified in the `createFile` method. | [Creating Files](https://docs.oracle.com/javase/tutorial/essential/io/file.html#createFile) |
| `File.createTempFile`                    | `Files.createTempFile(Path, String, FileAttributes<?>)`, `Files.createTempFile(Path, String, String, FileAttributes<?>)` | [Creating Files](https://docs.oracle.com/javase/tutorial/essential/io/file.html#createFile)[Creating and Writing a File by Using Stream I/O](https://docs.oracle.com/javase/tutorial/essential/io/file.html#createStream)[Reading and Writing Files by Using Channel I/O](https://docs.oracle.com/javase/tutorial/essential/io/file.html#channelio) |
| `File.exists`                            | `Files.exists` and `Files.notExists`     | [Verifying the Existence of a File or Directory](https://docs.oracle.com/javase/tutorial/essential/io/check.html) |
| `File.compareTo` and `equals`            | `Path.compareTo` and `equals`            | [Comparing Two Paths](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#compare) |
| `File.getAbsolutePath` and `getAbsoluteFile` | `Path.toAbsolutePath`                    | [Converting a Path](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert) |
| `File.getCanonicalPath` and `getCanonicalFile` | `Path.toRealPath` or `normalize`         | [Converting a Path (`toRealPath`)](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert)[Removing Redundancies From a Path (`normalize`)](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#normal) |
| `File.toURI`                             | `Path.toURI`                             | [Converting a Path](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert) |
| `File.isHidden`                          | `Files.isHidden`                         | [Retrieving Information About the Path](https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#info) |
| `File.list` and `listFiles`              | `Path.newDirectoryStream`                | [Listing a Directory's Contents](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listdir) |
| `File.mkdir` and `mkdirs`                | `Path.createDirectory`                   | [Creating a Directory](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#create) |
| `File.listRoots`                         | `FileSystem.getRootDirectories`          | [Listing a File System's Root Directories](https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listall) |
| `File.getTotalSpace`, `File.getFreeSpace`, `File.getUsableSpace` | `FileStore.getTotalSpace`, `FileStore.getUnallocatedSpace`, `FileStore.getUsableSpace`, `FileStore.getTotalSpace` | [File Store Attributes](https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#store) |

### 小结

`java.io`包中包含许多程序可用于读写数据的类。大多数类实现顺序访问流。顺序访问流可以分为两类：读取和写入字节的以及读取和写入Unicode字符的。每个顺序访问流都具有特殊性，例如读取或写入文件，过滤数据作为其读取或写入，或序列化对象。

`java.nio.file`包为文件和文件系统I/O提供了广泛的支持。这是一个非常全面的API，但关键切入点如下：

- `Path`类具有操作路径的方法。
- `Files`类具有文件操作的方法，例如移动，复制，删除，以及用于检索和设置文件属性的方法。
- `FileSystem`类有多种方法可用于获取有关文件系统的信息。

有关`NIO.2`的更多信息，请访问 [OpenJDK: NIO](http://openjdk.java.net/projects/nio/) 项目网站。此站点包含`NIO.2`提供的功能的资源，这些功能超出了本教程的范围，例如多播，异步I/O和创建自己的文件系统实现。

## 并发

计算机用户理所当然地认为他们的系统一次可以做多件事。他们假设他们可以继续在文字处理器中工作，而其他应用程序则下载文件，管理打印队列和流式传输音频。即使是单个应用程序通常也希望一次完成多个任务。例如，流式音频应用程序必须同时从网络读取数字音频，解压缩，管理播放和更新其显示。即使文字处理器应始终准备好响应键盘和鼠标事件，无论重新格式化文本或更新显示有多繁忙。可以执行此类操作的软件称为并发软件。

Java平台的设计初衷是为了支持并发编程，在Java编程语言和Java类库中提供基本的并发支持。从5.0版开始，Java平台还包含高级并发API。本课程介绍了平台的基本并发支持，并总结了`java.util.concurrent`包中的一些高级API。

### 进程和线程

在并发编程中，有两个基本的执行单元：进程和线程。在Java编程语言中，并发编程主要涉及线程。但是，进程也很重要。

计算机系统通常具有许多活动进程和线程。即使在只有一个执行核心的系统中也是如此，只不过在任何给定时刻只有一个线程实际执行。通过称为时间切片的OS功能，在进程和线程之间共享单个核的处理时间。

对于具有多个处理器或具有多个执行核心的处理器的计算机系统来说，并发极大地增强了系统并发执行进程和线程的能力 - 但即使在没有多个处理器或执行核心的简单系统上也可以实现并发。

**进程**

进程具有自包含的执行环境。进程通常具有完整的私有基本运行时资源集：特别是，每个进程都有自己的内存空间。

进程通常被视为程序或应用程序的同义词。但是，用户看到的单个应用程序实际上可能是一组协作进程。为了促进进程之间的通信，大多数操作系统都支持进程间通信（IPC）资源，例如管道和套接字。IPC不仅用于同一系统上的进程之间的通信，而且还用于不同系统上的进程。

Java虚拟机的大多数实现都作为单个进程运行。Java应用程序可以使用`ProcessBuilder`对象创建其他进程。多进程应用程序超出了本课程的范围。

**线程**

线程有时被称为轻量级进程。进程和线程都提供执行环境，但创建新线程所需的资源比创建新进程要少。

线程存在于进程中 - 每个进程至少有一个线程。线程共享进程的资源，包括内存和打开文件。这使得有效但可能有问题的通信成为可能。

多线程执行是Java平台的基本特性。每个应用程序至少有一个线程 - 或几个，如果你算上所谓的“系统”线程，它们执行内存管理和信号处理等操作。但是从应用程序员的角度来看，你只从一个线程开始，称为主线程。该线程具有创建其他线程的能力，我们将在下一节中进行演示。

### `Thread `对象

每个线程都与`Thread`类的实例相关联。使用`Thread`对象创建并发应用程序有两种基本策略。

- 要直接控制线程创建和管理，只需在每次应用程序需要启动异步任务时实例化`Thread`。
- 要从应用程序的其余部分抽象线程管理，请将应用程序的任务传递给*执行器*。

本节介绍`Thread`对象的使用。执行器与其他 [高级并发对象](https://docs.oracle.com/javase/tutorial/essential/concurrency/highlevel.html) 共同讨论。

#### 创建和启动线程

创建`Thread`实例的应用程序必须提供将在该线程中运行的代码。有两种方法可以做到这一点：

- *提供一个Runnable对象* [`Runnable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html) 接口定义了一个单独的方法`run`， 意味着包含在线程中执行的代码。 `Runnable`对象传递给`Thread`constructor，如 [`HelloRunnable`](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/HelloRunnable.java) 示例：

  ```java
  public class HelloRunnable implements Runnable {

      public void run() {
          System.out.println("Hello from a thread!");
      }

      public static void main(String args[]) {
          (new Thread(new HelloRunnable())).start();
      }

  }
  ```

- *Thread 的子类* `Thread`类本身实现`Runnable`，尽管它的`run`方法什么都不做。应用程序可以子类化`Thread`，提供自己的`run`实现，如 [`HelloRunnable`](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/HelloRunnable.java) 示例。

  ```java
  public class HelloThread extends Thread {

      public void run() {
          System.out.println("Hello from a thread!");
      }

      public static void main(String args[]) {
          (new HelloThread()).start();
      }

  }
  ```

请注意，两个示例都调用`Thread.start`以启动新线程。

你应该使用哪个方法？使用`Runnable`对象是更通用的，因为`Runnable`对象可以子类化除了`Thread`之外的类。第二个习惯用法在简单的应用程序中更容易使用，但受限于你的任务类必须是`Thread`的子类。本课重点介绍第一种方法，它将`Runnable`任务与执行任务的`Thread`对象分开。这种方法不仅更灵活，而且适用于后面介绍的高级线程管理API。

`Thread`类定义了许多对线程管理有用的方法。这些包括`static`方法，它们提供有关调用方法的线程的信息或影响其状态。从管理线程和`Thread`对象所涉及的其他线程调用其他方法。我们将在以下部分中研究其中一些方法。

#### 暂停执行与睡眠

`Thread.sleep`导致当前线程暂停执行指定的时间段。这是使处理器时间可用于应用程序的其他线程或可能在计算机系统上运行的其他应用程序的有效方法。`sleep`方法也可用于调度，如下面的示例所示，并等待具有被理解为具有时间要求的职责的另一个线程，如稍后部分中的`SimpleThreads`示例。

存在两个重载版本的`sleep`：一个指定睡眠时间为毫秒，另一个指定睡眠时间为纳秒。但是，这些睡眠时间并不能保证精确，因为它们受到底层操作系统提供的基础设施的限制。此外，睡眠周期可以通过中断终止，我们将在后面的部分中看到。在任何情况下，您都不能假设调用`sleep`会在指定的时间段内暂停该线程。

 [`SleepMessages`](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/SleepMessages.java) 示例使用`sleep`以四秒为间隔打印消息：

```java
public class SleepMessages {
    public static void main(String args[])
        throws InterruptedException {
        String importantInfo[] = {
            "Mares eat oats",
            "Does eat oats",
            "Little lambs eat ivy",
            "A kid will eat ivy too"
        };

        for (int i = 0;
             i < importantInfo.length;
             i++) {
            //Pause for 4 seconds
            Thread.sleep(4000);
            //Print a message
            System.out.println(importantInfo[i]);
        }
    }
}
```

请注意，`main`声明它会抛出`InterruptedException`。这是一个异常，当当前线程处于`sleep`状态时，另一个线程在中断当前线程时抛出。由于此应用程序尚未定义另一个导致中断的线程，因此无需捕获`InterruptedException`。

#### 中断

*中断*是一个给线程的指示，告诉它应该停止正在做的事情并做其他事情。由程序员决定线程如何响应中断，但线程终止是很常见的。这是本课程中强调的用法。

线程通过调用`Thread`对象上的 [`interrupt`](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--) 来发送中断，以便线程被中断。为使中断机制正常工作，被中断的线程必须支持自己的中断。

**支持中断**

线程如何支持自己的中断？这取决于它目前正在做什么。如果线程经常调用抛出`InterruptedException`的方法，它只会在捕获该异常后从`run`方法返回。例如，假设`SleepMessages`示例中的核心消息循环位于线程的`Runnable`对象的`run`方法中。然后可以按如下方式修改它以支持中断：

```java
for (int i = 0; i < importantInfo.length; i++) {
    // Pause for 4 seconds
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        // We've been interrupted: no more messages.
        return;
    }
    // Print a message
    System.out.println(importantInfo[i]);
}
```

许多抛出`InterruptedException`的方法（例如`sleep`）被设计为取消当前操作并在收到中断时立即返回。

如果一个线程长时间没有调用抛出`InterruptedException`的方法怎么办？它必须定期调用`Thread.interrupted`，如果收到中断，则返回`true`。 例如：

```java
for (int i = 0; i < inputs.length; i++) {
    heavyCrunch(inputs[i]);
    if (Thread.interrupted()) {
        // We've been interrupted: no more crunching.
        return;
    }
}
```

在这个简单的例子中，代码只是测试中断并退出线程（如果已收到）。在更复杂的应用程序中，抛出`InterruptedException`可能更有意义：

```java
if (Thread.interrupted()) {
    throw new InterruptedException();
}
```

这允许中断处理代码集中在`catch`子句中。

**中断状态标识**

中断机制使用称为*中断状态*的内部标志来实现。调用`Thread.interrupt`设置此标志。当线程通过调用静态方法`Thread.interrupted`来检查中断时，将清除中断状态。非静态`isInterrupted`方法，由一个线程用于查询另一个线程的中断状态，不会更改中断状态标志。

按照惯例，任何通过抛出`InterruptedException`退出的方法都会在执行此操作时清除中断状态。但是，通过另一个线程调用`interrupt`，总是可以立即再次设置中断状态。

#### `Joins`

`join`方法允许一个线程等待另一个线程的完成。如果`t`是其线程当前正在执行的`Thread`对象，

```java
t.join();
```

导致当前线程暂停执行，直到`t`的线程终止。`join`过载允许程序员指定等待时长。但是，与`sleep`一样，`join`依赖于操作系统进行计时，因此您不应该假设`join`将等待您指定的时间。

与`sleep`一样，`join`通过响应`InterruptedException`退出的方式来响应中断。

#### 线程的简单示例

以下示例汇总了本节的一些概念。`SimpleThreads`由两个线程组成。第一个是每个Java应用程序都有的主线程。主线程从`Runnable`对象`MessageLoop`创建一个新线程，并等待它完成。如果`MessageLoop`线程需要很长时间才能完成，主线程会中断它。

`MessageLoop`线程打印出一系列消息。如果在打印完所有消息之前中断，`MessageLoop`线程将打印一条消息并退出。

```java
public class SimpleThreads {

    // Display a message, preceded by
    // the name of the current thread
    static void threadMessage(String message) {
        String threadName =
            Thread.currentThread().getName();
        System.out.format("%s: %s%n",
                          threadName,
                          message);
    }

    private static class MessageLoop
        implements Runnable {
        public void run() {
            String importantInfo[] = {
                "Mares eat oats",
                "Does eat oats",
                "Little lambs eat ivy",
                "A kid will eat ivy too"
            };
            try {
                for (int i = 0;
                     i < importantInfo.length;
                     i++) {
                    // Pause for 4 seconds
                    Thread.sleep(4000);
                    // Print a message
                    threadMessage(importantInfo[i]);
                }
            } catch (InterruptedException e) {
                threadMessage("I wasn't done!");
            }
        }
    }

    public static void main(String args[])
        throws InterruptedException {

        // Delay, in milliseconds before
        // we interrupt MessageLoop
        // thread (default one hour).
        long patience = 1000 * 60 * 60;

        // If command line argument
        // present, gives patience
        // in seconds.
        if (args.length > 0) {
            try {
                patience = Long.parseLong(args[0]) * 1000;
            } catch (NumberFormatException e) {
                System.err.println("Argument must be an integer.");
                System.exit(1);
            }
        }

        threadMessage("Starting MessageLoop thread");
        long startTime = System.currentTimeMillis();
        Thread t = new Thread(new MessageLoop());
        t.start();

        threadMessage("Waiting for MessageLoop thread to finish");
        // loop until MessageLoop
        // thread exits
        while (t.isAlive()) {
            threadMessage("Still waiting...");
            // Wait maximum of 1 second
            // for MessageLoop thread
            // to finish.
            t.join(1000);
            if (((System.currentTimeMillis() - startTime) > patience)
                  && t.isAlive()) {
                threadMessage("Tired of waiting!");
                t.interrupt();
                // Shouldn't be long now
                // -- wait indefinitely
                t.join();
            }
        }
        threadMessage("Finally!");
    }
}
```

### 同步

线程主要通过共享对字段的访问和字段表示的对象引用进行通信。这种通信形式非常有效，但可能会出现两种错误：*线程干扰*和*内存一致性错误*。防止这些错误所需的工具是*同步*。

但是，同步可能会引入*线程争用*，当两个或多个线程同时尝试访问同一资源，并导致Java运行时更慢地执行一个或多个线程，甚至暂停执行时，就会发生这种情况。[饥饿和活锁](https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html) 是线程争用的形式。有关更多信息，请参阅 [Liveness](https://docs.oracle.com/javase/tutorial/essential/concurrency/liveness.html) 部分。

本章节包含以下主题：

- [线程干扰](https://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html) 描述了当多个线程访问共享数据时错误如何产生。
- [内存一致性错误](https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html) 描述由共享内存的不一致视图导致的错误。
- [同步方法](https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html) 描述了一个简单的惯用方法，可以有效解决线程干扰和内存一致性错误。
- [隐式锁和同步](https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html) 描述了更通用的同步习惯用法，并描述了基于隐式锁的同步方式。
- [原子访问](https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html) 讨论了不会被其它线程干扰的操作的一般概念。

#### 线程干扰

考虑下面的简单的类 [`Counter`](https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Counter.java)

```java
class Counter {
    private int c = 0;

    public void increment() {
        c++;
    }

    public void decrement() {
        c--;
    }

    public int value() {
        return c;
    }

}
```

`Counter` 的设计使得每次调用`increment` 都会将`c`加1，每次调用`decrement` 都会从`c`中减去1。但是，如果从多个线程引用`Counter`对象，则线程之间的干扰可能会阻止这种情况按预期发生。

当两个操作在不同的线程中运行但作用于相同的数据时，会发生干扰。这意味着这两个操作由多个步骤组成，并且步骤序列重叠。

对于`Counter`实例的操作似乎不可能发生交错，因为对`c`的两个操作都是单个简单的语句。但是，即使是简单的语句也可以由虚拟机转换为多个步骤。我们不会检查虚拟机采取的具体步骤 - 足以知道单个表达式`c++`可以分解为三个步骤：

1. 获取 `c`的当前值。
2. 将获取的值加1。
3. 将增加之后的值存储到变量 `c` 中。

表达式`c--`可以以相同的方式分解，除了第二步是减少而不是增量。

假设线程A在大约同一时间调用 `increment` ，线程B调用 `decrement`。如果`c`的初始值为0，则它们的交错操作可能遵循以下顺序：

1. 线程A：检索`c`。
2. 线程B：检索`c`。
3. 线程A：增加检索值；结果是1。
4. 线程B：减少检索值；结果是-1。
5. 线程A：将结果存储在`c`中；`c`现在是1。
6. 线程B：将结果存储在`c`中；`c`现在是-1。

线程A的结果丢失，被线程B覆盖。这种特殊的交错只是一种可能性。在不同情况下，可能是线程B的结果丢失，或者根本没有错误。因为它们是不可预测的，所以难以检测和修复线程干扰错误。

#### 内存一致性错误

当不同的线程具有应该是相同数据的不一致视图时，会发生内存一致性错误。内存一致性错误的原因很复杂，超出了本教程的范围。幸运的是，程序员不需要详细了解这些原因。所需要的只是避免它们的策略。

避免内存一致性错误的关键是理解 *happens-before* 关系。这种关系只是简单地保证一个特定语句的内存写入对另一个特定语句可见。要查看此内容，请考虑以下示例。假设定义并初始化了一个简单的`int`字段：

```
int counter = 0;
```

 `counter` 字段在两个线程A和B之间共享。假设线程A递增 `counter` ：

```
counter++;
```

然后，不久之后，线程B打印出 `counter`：

```
System.out.println(counter);
```

如果两个语句已在同一个线程中执行，则可以安全地假设打印出的值为“1”。但是如果这两个语句是在不同的线程中执行的，那么打印出的值可能是“0”，因为不能保证线程A对计数器的更改对于线程B是可见的 - 除非程序员已经在这两个语句之间建立了*happens-before*关系。

有几种行为可以建立*happens-before*关系。其中之一是同步，我们将在以下部分中看到。

我们已经看到了两种建立*happens-before*关系的行为。

- 当一个语句调用`Thread.start`时，与该语句具有*happens-before*关系的每个语句也与新线程执行的每个语句都有一个*happens-before*关系。 新线程可以看到导致创建新线程的代码的影响。
- 当一个线程终止并导致另一个线程中的`Thread.join`返回时，终止线程执行的所有语句与成功`join`后的所有语句都有一个*happens-before*关系。现在，执行`join`的线程可以看到线程中代码的效果。

可以创建*happens-before*关系的行为列表，参考 [ `java.util.concurrent` 包的摘要页面。](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility)