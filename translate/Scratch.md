## 共享预期的修改

线程能够共享它对共享数据结构的预期修改，而不需要拷贝并修改整个共享数据结构。这样的话，想要修改共享数据结构的线程的操作过程就变成：

1. 检查是否有其他线程已经提交对共享数据结构的预期修改。
2. 如果没有其他线程已经提交预期修改，就创建一个预期修改（由一个对象表示）并将该预期修改提交给共享数据结构（使用比较并交换操作）。
3. 执行对共享数据结构的修改。
4. 删除指向预期修改的引用，以通知其他线程该预期修改已经被执行。

如你所见，第二步可能会阻塞其他线程提交预期修改。因此，第二步可以作为共享数据结构的锁。如果一个线程成功提交了一个预期修改，则其他线程必须等到这个线程的预期修改执行完成之后才能提交预期修改。

如果一个线程提交了一个预期修改，随后的操作被阻塞，则共享数据结构就被锁定了。共享数据结构不会直接阻塞其他线程。其他线程能够探测到它们无法提交预期修改并决定执行其他操作。显然，我们需要解决这个问题。

### 可完成的预期修改

为了避免一个提交了的预期修改锁定共享数据结构，一个提交的预期修改对象必须包含足够的信息提供给其他线程以完成该修改。因此，如果提交预期修改的线程始终没有完成该修改，其他线程也可以按照自己的方式完成它，从而使得共享数据结构对其他线程可用。

下图是上面描述的非阻塞算法的流程图：

![](http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-5.png)

该修改必须作为一个或者多个比较并交换操作被完成。因此，如果两个线程尝试完成该预期修改，只有一个线程可以执行任意的比较并交换操作，一旦一个比较并交换操作完成，完成该比较和交换操作的进一步尝试将失败。

