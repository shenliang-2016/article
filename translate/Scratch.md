## A-B-A 问题

上述算法可能会遇到A-B-A问题。A-B-A问题是指变量从A更改为B，然后再次变回A的情况。因此，对于另一个线程，不可能检测到该变量确实已更改。

如果线程A检查正在进行的更新，复制数据并被线程调度程序挂起，则线程B可能同时能够访问共享数据结构。如果线程B对数据结构进行了完全更新，并删除了其预期的修改，则线程A将看起来就像自从它复制了数据结构以来未进行任何修改。但是，确实进行了修改。当线程A根据其现在已过期的数据结构副本继续执行其更新时，该数据结构将撤消线程B的修改。

下图从上述情况说明了A-B-A问题：

![](http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-6.png)

### A-B-A 解决方案

A-B-A问题的常见解决方案是不仅交换指向预期修改对象的指针，而且将指针与计数器组合在一起，并使用单个比较和交换操作更新指针+计数器。在支持 C 和 C++ 之类的指针的语言中，这是可能的。因此，即使当前修改指针被设置回指向“无正在进行的修改”，指针+计数器的计数器部分也将被递增，从而使更新对其他线程可见。

在 Java 中，您不能将引用和计数器合并到一个变量中。取而代之的是，Java 提供了一个 [`AtomicStampedReference`](http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.html) 类，该类可以使用比较和交换操作原子地更新引用和标记。

