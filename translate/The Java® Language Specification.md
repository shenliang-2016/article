# The Java® Language Specification

## Java SE 8 Edition

### James Gosling

### Bill Joy

### Guy Steele

### Gilad Bracha

### Alex Buckley

##### 2015-02-13

----

# 目录

----

* 前言
* 1 介绍
  * 1.1 本规范的组织结构
  * 1.2 例子程序
  * 1.3 记号
  * 1.4 与预定义类和接口的关系
  * 1.5 反馈
  * 1.6 参考
* 2 语法
  * 2.1 上下文无关语法
  * 2.2 词汇语法
  * 2.3 句法语法
  * 2.4 语法记号
* 3 词汇结构
  * 3.1 统一编码
  * 3.2 词汇翻译
  * 3.3 统一编码转义
  * 3.4 换行符
  * 3.5 输入元素和令牌
  * 3.6 空格
  * 3.7 注释
  * 3.8 标识符
  * 3.9 关键词
  * 3.10 字面值
    * 3.10.1 整数字面值
    * 3.10.2 浮点数字面值
    * 3.10.3 逻辑字面值
    * 3.10.4 字符字面值
    * 3.10.5 字符串字面值
    * 3.10.6 字符字面值和字符串字面值的转义序列
    * 3.10.7 Null 字面值
  * 3.11 分隔符
  * 3.12 操作符
* 4 类型、值和变量
  * 4.1 类型和值的分类
  * 4.2 基本类型和值
    * 4.2.1 整数类型和值
    * 4.2.2 整数操作符
    * 4.2.3 浮点数类型、格式和值
    * 4.2.4 浮点数操作符
    * 4.2.5 逻辑类型和逻辑值
  * 4.3 引用类型和值
    * 4.3.1 对象
    * 4.3.2 ````Object````类
    * 4.3.3 ````String````类
    * 4.3.4 引用类型何时相等
  * 4.4 类型变量
  * 4.5 参数化类型
    * 4.5.1 参数化类型的类型参数
    * 4.5.2 参数化类型的成员和构造器
  * 4.6 类型擦除
  * 4.7 可实例化类型
  * 4.8 原始类型
  * 4.9 相交类型
  * 4.10 子类型化
    * 4.10.1 基本类型中的子类型化
    * 4.10.2 类和接口类型中的子类型化
    * 4.10.3 数组类型中的子类型化
    * 4.10.4 最小上界
  * 4.11 类型在何处使用
  * 4.12 变量
    * 4.12.1 基本类型变量
    * 4.12.2 引用类型变量
    * 4.12.3 变量分类
    * 4.12.4 ````final````变量
    * 4.12.5 变量的初始值
    * 4.12.6 类型、类和接口
* 5 转换和上下文
  * 5.1 转换的分类
    * 5.1.1 同一性转换
    * 5.1.2 基本类型拓宽转换
    * 5.1.3 基本类型缩窄转换
    * 5.1.4 基本类型拓宽和缩窄转换
    * 5.1.5 引用类型拓宽转换
    * 5.1.6 引用类型缩窄转换
    * 5.1.7 装箱转换
    * 5.1.8 拆箱转换
    * 5.1.9 不受检查的转换
    * 5.1.10 捕获转换
    * 5.1.11 字符串转换
    * 5.1.12 禁止转换
    * 5.1.13 值集合转换
  * 5.2 分配上下文
  * 5.3 宣誓上下文
  * 5.4 字符串上下文
  * 5.5 转化上下文
    * 5.5.1 引用类型转化
    * 5.5.2 受检查的转化和不受检查的转化
    * 5.5.3 运行时受检查的转化
  * 5.6 数字上下文
    * 5.6.1 单目数字提升
    * 5.6.2 双目数字提升
* 6 名称
  * 6.1 声明
  * 6.2 名称和标识符
  * 6.3 声明的作用域
  * 6.4 隐蔽和遮盖
    * 6.4.1 隐蔽
    * 6.4.2 遮盖
  * 6.5 决定名称的含义
    * 6.5.1 根据上下文的名称句法分类
    * 6.5.2 上下文混淆命名的重新分类
    * 6.5.3 包名的含义
      * 6.5.3.1 简单包名
      * 6.5.3.2 包限定名
    * 6.5.4 包或者类型名的含义
      * 6.5.4.1 简单包或者类型名
      * 6.5.4.2 包或者类型限定名
    * 6.5.5 类型名的含义
      * 6.5.5.1 简单类型名
      * 6.5.5.2 类型限定名
    * 6.5.6 表达式名含义
      * 6.5.6.1 简单表达式名
      * 6.5.6.2 表达式限定名
    * 6.5.7 方法名含义
      * 6.5.7.1 简单方法名
  * 6.6 访问控制
    * 6.6.1 确定可访问性
    * 6.6.2 ````protected````访问细节
      * 6.6.2.1 访问````protected````成员
      * 6.6.2.2 限定访问````protected````构造器
  * 6.7 全限定名和常规名称
* 7 包
  * 7.1 包成员
  * 7.2 主机对包的支持
  * 7.3 编译单元
  * 7.4 包声明
    * 7.4.1 命名包
    * 7.4.2 未命名包
    * 7.4.3 包的可见性
  * 7.5 引入声明
    * 7.5.1 单类型引入声明
    * 7.5.2 类型按需引入声明
    * 7.5.3 单静态引入声明
    * 7.5.4 静态按需引入声明
  * 7.6 顶层类型声明
* 8 类
  * 8.1 类声明
    * 8.1.1 类修饰词
      * 8.1.1.1 ````abstract````类
      * 8.1.1.2 ````final````类
      * 8.1.1.3 ````strictfp````类
    * 8.1.2 范型和类型参数
    * 8.1.3 内部类和封闭实例
    * 8.1.4 超类和子类
    * 8.1.5 超接口
    * 8.1.6 类体和成员成名
  * 8.2 类成员
  * 8.3 字段声明
    * 8.3.1 字段修饰词
      * 8.3.1.1 ````static````字段
      * 8.3.1.2 ````final````字段
      * 8.3.1.3 ````transient````字段
      * 8.3.1.4 ````volatile````字段
    * 8.3.2 字段初始化
    * 8.3.3 字段初始化过程中的向前引用
  * 8.4 方法声明
    * 8.4.1 形式参数
    * 8.4.2 方法签名
    * 8.4.3 方法修饰词
      * 8.4.3.1 ````abstract````方法
      * 8.4.3.2 ````static````方法
      * 8.4.3.3 ````final````方法
      * 8.4.3.4 ````native````方法
      * 8.4.3.5 ````strictfp````方法
      * 8.4.3.6 ````synchronized````方法
    * 8.4.4 范型方法
    * 8.4.5 方法结果
    * 8.4.6 方法抛出
    * 8.4.7 方法体
    * 8.4.8 继承、覆盖和隐藏
      * 8.4.8.1 覆盖（被实例方法）
      * 8.4.8.2 隐藏（被类方法）
      * 8.4.8.3 覆盖和隐藏的前提条件
      * 8.4.8.4 覆盖相同签名的继承方法
    * 8.4.9 重载
  * 8.5 成员类型声明
    * 8.5.1 静态成员类型声明
  * 8.6 实例初始化器
  * 8.7 静态初始化器
  * 8.8 构造器声明
    * 8.8.1 形式参数
    * 8.8.2 构造器签名
    * 8.8.3 构造器修饰词
    * 8.8.4 范型构造器
    * 8.8.5 构造器抛出
    * 8.8.6 构造器类型
    * 8.8.7 构造器方法体
      * 8.8.7.1 显式构造器调用
    * 8.8.8 构造器重载
    * 8.8.9 默认构造器
    * 8.8.10 阻止类实例化
  * 8.9 枚举类型
    * 8.9.1 枚举常量
    * 8.9.2 枚举体声明
    * 8.9.3 枚举成员
* 9 接口
  * 9.1 接口声明
    * 9.1.1 接口修饰词
      * 9.1.1.1 ````abstract````接口
      * 9.1.1.2 ````strictfp````接口
    * 9.1.2 范型接口和类型参数
    * 9.1.3 超接口和子接口
    * 9.1.4 接口体和成员声明
  * 9.2 接口成员
  * 9.3 字段（静态）声明
    * 9.3.1 接口中字段初始化
  * 9.4 方法声明
    * 9.4.1 继承和覆盖
      * 9.4.1.1 覆盖（被实例方法）
      * 9.4.1.2 覆盖的前提
      * 9.4.1.3 覆盖相同签名的继承方法
    * 9.4.2 重载
    * 9.4.3 接口方法体
  * 9.5 成员类型声明
  * 9.6 注解类型
    * 9.6.1 注解类型元素
    * 9.6.2 默认注解类型元素
    * 9.6.3 可重复注解类型
    * 9.6.4 预定义注解类型
      * 9.6.4.1 ````@Target````
      * 9.6.4.2 ````@Retention````
      * 9.6.4.3 ````@Inherited````
      * 9.6.4.4 ````@Override````
      * 9.6.4.5 ````@SuppressWarnings````
      * 9.6.4.6 ````@Deprecated````
      * 9.6.4.7 ````@SafeVarargs````
      * 9.6.4.8 ````@Repeatable````
      * 9.6.4.9 ````@FunctionalInterface````
  * 9.7 注解
    * 9.7.1 普通注解
    * 9.7.2 标记注解
    * 9.7.3 单元素注解
    * 9.7.4 注解可以出现的位置
    * 9.7.5 相同类型的多个注解
  * 9.8 函数式接口
  * 9.9 函数类型
* 10 数组
  * 10.1 数组类型
  * 10.2 数组变量
  * 10.3 数组创建
  * 10.4 数组访问
  * 10.5 数组存储异常
  * 10.6 数组初始化器
  * 10.7 数组成员
  * 10.8 数组的````Class````对象
  * 10.9 字符数组并不是````String````
* 11 异常
  * 11.1 异常原因的种类
    * 11.1.1 异常的种类
    * 11.1.2 异常的原因
    * 11.1.3 异步异常
  * 11.2 编译器异常检查
    * 11.2.1 表达式异常分析
    * 11.2.2 语句异常分析
    * 11.2.3 异常检查
  * 11.3 运行时异常处理
* 12 执行
  * 12.1 Java 虚拟机启动
    * 12.1.1 加载````Test````类
    * 12.1.2 链接````Test````：验证，准备以及可选的解析
    * 12.1.3 初始化````Test````：执行初始化器
    * 12.1.4 调用````Test.main````
  * 12.2 类和接口的加载
    * 12.2.1 加载过程
  * 12.3 类和接口的链接
    * 12.3.1 二进制形式的验证
    * 12.3.2 类或者接口类型的准备
    * 12.3.3 符号引用解析
  * 12.4 类和接口的初始化
    * 12.4.1 初始化何时发生
    * 12.4.2 初始化过程细节
  * 12.5 新的类实例的创建
  * 12.6 类实例的终结
    * 12.6.1 终结实现
    * 12.6.2 与内存模型的交互
  * 12.7 类和接口的卸载
  * 12.8 程序退出
* 13 二进制通用性
  * 13.1 二进制文件形式
  * 13.2 二进制通用型是什么
  * 13.3 包演化
  * 13.4 类演化
    * 13.4.1 ````abstract````类
    * 13.4.2 ````final````类
    * 13.4.3 ````public````类
    * 13.4.4 超类和超接口
    * 13.4.5 类类型参数
    * 13.4.6 类主体和成员声明
    * 13.4.7 访问成员和构造器
    * 13.4.8 字段声明
    * 13.4.9 ````final````字段和````static````静态变量
    * 13.4.10 ````static````字段
    * 13.4.11 ````transient````字段
    * 13.4.12 方法和构造器声明
    * 13.4.13 方法和构造器类型参数
    * 13.4.14 方法和构造器形式参数
    * 13.4.15 方法返回值类型
    * 13.4.16 ````abstract````方法
    * 13.4.17 ````final````方法
    * 13.4.18 ````native````方法
    * 13.4.19 ````static````方法
    * 13.4.20 ````synchronized````方法
    * 13.4.21 方法和构造器抛出
    * 13.4.22 方法和构造器主体
    * 13.4.23 方法和构造器重载
    * 13.4.24 方法重写
    * 13.4.25 静态初始化器
    * 13.4.26 枚举演化
  * 13.5 接口演化
    * 13.5.1 ````public````接口
    * 13.5.2 超接口
    * 13.5.3 接口成员
    * 13.5.4 接口类型参数
    * 13.5.5 字段声明
    * 13.5.6 接口方法声明
    * 13.5.7 注解类型演化
* 14 块和语句
  * 14.1 语句的正常完成和意外结束
  * 14.2 块
  * 14.3 局部类声明
  * 14.4 局部变量声明语句
    * 14.4.1 局部变量声明和类型
    * 14.4.2 局部变量声明的执行
  * 14.5 语句
  * 14.6 空语句
  * 14.7 标记的语句
  * 14.8 表达式语句
  * 14.9 ````if````语句
    * 14.9.1 ````if-then````语句
    * 14.9.2 ````if-then-else````语句
  * 14.10 ````assert````语句
  * 14.11 ````switch````语句
  * 14.12 ````while````语句
    * 14.12.1 ````while````语句的意外结束
  * 14.13 ````do````语句
    * 14.13.1 ````do````语句的意外结束
  * 14.14 ````for````语句
    * 14.14.1 基本的````for````语句
      * 14.14.1.1 ````for````语句的初始化
      * 14.14.1.2 ````for````语句的迭代器
      * 14.14.1.3 ````for````语句的意外结束
    * 14.14.2 增强型````for````语句
  * 14.15 ````break````语句
  * 14.16 ````continue````语句
  * 14.17 ````return````语句
  * 14.18 ````throw````语句
  * 14.19 ````synchronized````语句
  * 14.20 ````try````语句
    * 14.20.1 ````try-catch````语句的执行
    * 14.20.2 ````try-finally````和````try-catch-finally````语句的执行
    * 14.20.3 关于资源的````try````
      * 14.20.3.1 基本的关于资源的````try````
      * 14.20.3.2 扩展的关于资源的````try````
  * 14.21 不可达语句
* 15 表达式
  * 15.1 赋值，意指和返回值
  * 15.2 表达式形式
  * 15.3 表达式类型
  * 15.4 FP-strict 表达式
  * 15.5 表达式和运行时检查
  * 15.6 赋值的正常完成和意外结束
  * 15.7 赋值顺序
    * 15.7.1 首先对左手操作数赋值
    * 15.7.2 操作符之前对操作数赋值
    * 15.7.3 遵循括号和优先级赋值
    * 15.7.4 参数列表从左到右赋值
    * 15.7.5 其它表达式赋值顺序
  * 15.8 主要表达式
    * 15.8.1 词汇字面值
    * 15.8.2 类字面值
    * 15.8.3 ````this````
    * 15.8.4 限定的````this````
    * 15.8.5 括号表达式
  * 15.9 类实例创建表达式
    * 15.9.1 确定需要实例化的类
    * 15.9.2 确定包装实例
    * 15.9.3 选择构造器和它的参数
    * 15.9.4 运行时类实例创建表达式赋值
    * 15.9.5 匿名类声明
      * 15.9.5.1 匿名构造器
  * 15.10 数组创建和访问表达式
    * 15.10.1 数组创建表达式
    * 15.10.2 运行时数组创建表达式赋值
    * 15.10.3 数组访问表达式
    * 15.10.4 运行时数组访问表达式
  * 15.11 字段访问表达式
    * 15.11.1 使用基本类型访问字段
    * 15.11.2 使用````super````访问父类成员
  * 15.12 方法调用表达式
    * 15.12.1 编译期步骤1: 确定要搜索的类或者接口
    * 15.12.2 编译期步骤2: 确定方法签名
      * 15.12.2.1 确定潜在的可适用方法
      * 15.12.2.2 阶段1: 确定严格调用适用的匹配到的方法
      * 15.12.2.3 阶段2: 确定宽松调用适用的匹配到的方法
      * 15.12.2.4 阶段3: 确定参数化调用适用的方法
      * 15.12.2.5 选择最精确的方法
      * 15.12.2.6 方法调用类型
    * 15.12.3 编译期步骤3: 选中的方法是否合适
    * 15.12.4 运行期方法调用赋值
      * 15.12.4.1 计算目标引用（如果需要）
      * 15.12.4.2 参数赋值
      * 15.12.4.3 检查类型和方法的可访问性
      * 15.12.4.4 定位调用方法
      * 15.12.4.5 创建框架，同步，转换控制
  * 15.13 方法引用表达式
    * 15.13.1 编译期方法引用声明
    * 15.13.2 方法引用类型
    * 15.13.3 运行期方法引用赋值
  * 15.14 后缀表达式
    * 15.14.1 表达式名称
    * 15.14.2 后缀自增操作符++
    * 15.14.3 后缀自减操作符--
  * 15.15 单目操作符
    * 15.15.1 前缀自增操作符++
    * 15.15.2 前缀自减操作符--
    * 15.15.3 单目加操作符+
    * 15.15.4 单目减操作符-
    * 15.15.5 按位求补码操作符~
    * 15.15.6 逻辑求反操作符 !
  * 15.16 转型表达式
  * 15.17 乘法运算符
    * 15.17.1 乘法操作符 *
    * 15.17.2 除法操作符 /
    * 15.17.3 求余操作符 ％
  * 15.18 加法操作符
    * 15.18.1 字符串连接操作符 ＋
    * 15.18.2 数值类型加减操作符＋－
  * 15.19 移位操作符
  * 15.20 关系操作符
    * 15.20.1 数值比较操作符 <, <=, > 以及 >=
    * 15.20.2 类型比较操作符````instanceof````
  * 15.21 等于操作符
    * 15.21.1 数值相等操作符 == 和 !=
    * 15.21.2 逻辑相等操作符 == 和 !=
    * 15.21.3 引用相等操作符 == 和 !=
  * 15.22 位和逻辑操作符
    * 15.22.1 整型位操作符 &, ^ 和 |
    * 15.22.2 逻辑操作符 &, ^ 和 |
  * 15.23 条件与操作符 &&
  * 15.24 条件或操作符 ||
  * 15.25 条件操作符 ? : 
    * 15.25.1 逻辑条件表达式
    * 15.25.2 数值条件表达式
    * 15.25.3 引用条件表达式
  * 15.26 赋值操作符
    * 15.26.1 简单赋值操作符 =
    * 15.26.2 复合赋值操作符
  * 15.27 Lambda 表达式
    * 15.27.1 Lambda 参数
    * 15.17.2 Lambda 体
    * 15.17.3 Lambda 表达式类型
    * 15.17.4 运行时 Lambda 表达式赋值
  * 15.28 常量表达式
* 16 定义赋值
  * 16.1 定义赋值和表达式
    * 16.1.1 逻辑常量表达式
    * 16.1.2 条件与操作符 &&
    * 16.1.3 条件或表达式 ||
    * 16.1.4 逻辑求反操作符 !
    * 16.1.5 条件操作符 ? : 
    * 16.1.6 条件操作符 ? : 
    * 16.1.7 ````boolean````类型的其它表达式
    * 16.1.8 赋值表达式
    * 16.1.9 操作符++和--
    * 16.1.10 其它表达式
  * 16.2 定义赋值和表达式
    * 16.2.1 空语句
    * 16.2.2 块
    * 16.2.3 局部类声明语句
    * 16.2.4 局部变量声明语句
    * 16.2.5 标记语句
    * 16.2.6 表达式语句
    * 16.2.7 ````if````语句
    * 16.2.8 ````assert````语句
    * 16.2.9 ````switch````语句
    * 16.2.10 ````while````语句
    * 16.2.11 ````do````语句
    * 16.2.12 ````for````语句
      * 16.2.12.1 ````for````语句的初始化部分
      * 16.2.12.2 ````for````语句的自增部分
    * 16.2.13 ````break````,````continue````,````return````和````throw````语句
    * 16.2.14 ````synchronized````语句
    * 16.2.15 ````try````语句
  * 16.3 定义赋值和参数
  * 16.4 定义赋值和数组初始化器
  * 16.5 定义赋值和枚举常量
  * 16.6 定义赋值和匿名类
  * 16.7 定义赋值和成员类型
  * 16.8 定义赋值和静态初始化器
  * 16.9 定义赋值，构造器以及实例初始化器
* 17 线程和锁
  * 17.1 同步
  * 17.2 等待集和通知
    * 17.2.1 等待
    * 17.2.2 通知
    * 17.2.3 打断
    * 17.2.4 等待交互，通知以及打断
  * 17.3 睡眠和弃权
  * 17.4 内存模型
    * 17.4.1 共享变量
    * 17.4.2 动作
    * 17.4.3 程序和程序序
    * 17.4.4 同步顺序
    * 17.4.5 先发生顺序
    * 17.4.6 执行
    * 17.4.7 形式良好的执行
    * 17.4.8 执行和因果性需求
    * 17.4.9 可观测行为和无终止执行
  * 17.5 ````final````字段语义
    * 17.5.1 ````final````字段语义
    * 17.5.2 构造过程中读取````final````字段
    * 17.5.3 ````final````字段的后续修改
    * 17.5.4 写保护字段
  * 17.6 单词撕裂
  * 17.7 ````double````和````long````的非原子处理
* 18 类型推断
  * 18.1 概念和记号
    * 18.1.1 推断变量
    * 18.1.2 约束公式
    * 18.1.3 边界
  * 18.2 约减
    * 18.2.1 表达式互换性约束
    * 18.2.2 类型互换性约束
    * 18.2.3 子类型化约束
    * 18.2.4 类型等价约束
    * 18.2.5 受检查异常约束
  * 18.3 合并
    * 18.3.1 互补对边界
    * 18.3.2 涉及捕获转换的边界
  * 18.4 分辨率
  * 18.5 推断使用
    * 18.5.1 调用适用性推断
    * 18.5.2 调用类型推断
    * 18.5.3 函数式接口参数化推断
    * 18.5.4 更明确的方法推断
* 19 语法

----

# 序言

## Alex Buckley

----

1996年，James Gosling，Bill Joy 和 Guy Steele 编写了 Java 语言规范的首个版本。

“我们相信 Java 编程语言是一种成熟的、应用广泛的语言。不过，我们希望它可以在将来不断演进。同时，我们希望可以管理这些演进，以保证它们与现有的应用完全兼容。”

 Java SE 8 是 Java 语言历史上最大的一次单次演进。通过添加相对较少的新特性－ Lambda 表达式、方法引用和函数式接口－相结合，提供了融合面向对象和函数式编程的新的编程模型。在 Brian Goetz 领导下，这种融合模型已经以推荐的最佳实践－不变性、无状态、组合性－的方式实现，同时还保留了传统 Java 的感觉－可读性、简单性和普遍性。

关键的是，Java SE 平台的类库与 Java 语言本身同步发展。这就意味着使用 Lambda 表达式和方法引用来表示行为－比如，一种应用于列表中每个元素的操作符－是更高性能和更具生产性的“开箱即用”的。与此类似，Java 虚拟机也是与 Java 语言本身共同演进，以保证默认方法在编译器和运行时都可以一致性地支持类库的演进，同时考虑到单独编译的限制。

自从 20 世纪 90 年代以来，为 Java 语言添加一等功能的举措从未停止。2007 年前后 BGGA 和 CICE 的提案为此话题加入了新的关键内容。而 2009 OpenJDK 中 Lambda 项目的创建吸引了前所未有的关注度。Java SE 7 在 JVM 中增加方法处理，打开了一扇通向新的实现技术的大门，同时还能保持“一次编写，到处运行”。最后，语言这个方面的变化由 JSR 335: Lambda Expressions for the Java Programming Language，其专家组由如下专家组成：Joshua Bloch, Kevin Bourrillion, Andrey Breslav, Remi Forax, Dan Heidinga, Doug Lea, Bob Lee, David Lloyd, Sam Pullara, Srikanth Sankaran 和 Vladimir Zakharov。

典型的编程语言设计都会涉及到对语言的使用者彻底隐藏语言内部的复杂性。（这种复杂性经常被比喻为冰山一角，90%都是用户不可见的）在 JSR 335 中，最大的复杂性隐藏在显式类型的 lambda 表达式和重载解析机制的交互过程中。在与此类似的很多其它部分中，Oracle 的 Dan Smith 作出了卓越的贡献，定义了所有预期行为。他的工作出现在本规范的各个部分，包括关于类型推断的全新章节。

Java SE 8 的另一个举措是增强了注解的作用，注解是 Java 语言中应用最广泛的特性之一。首先，Java 语法已经被扩展来允许在许多语言结构中用注解修饰类型，这也形成了诸如 Checker Framework 等静态分析工具的基本原理。该特性由 JSR 308: Annotations on Java Types 指定，该文件由 Michael Ernst 领导的专家组制定，该专家组由我自己、Doug Lea和 Srikanth Sankaran 组成。本规范涉及到的变化范围甚广，Michael Ernst 和 Werner Dietl 的多年来的不懈工作得到了热烈的认可。其次，注解可以在语言结构上重复，这就为关于领域相关模型的注解类型配置的 APIs 提供了很大便利。Michael Keith 和 Bill Shannon 在 Java EE 平台中发起并领导了此特性。

来自 Oracle 的 Java Platform Group 的很多同事为本规范提供了很多有价值的支持：Leonid Arbouzov, Mandy Chung, Joe Darcy, Robert Field, Joel Borggren-Franck, Sonali Goel, Jon Gibbons, Jeannette Hung, Stuart Marks, Eric McCorkle, Matherey Nunez, Mark Reinhold, Vicente Romero, John Rose, Georges Saab, Steve Sides, Bernard Traversat 和 Michel Trudeau。

可能最应该感谢的是将此规范变成真实软件的编译器工程师。Oracle 的 Maurizio Cimadamore 从 lambda 表达式设计的早期开始直到实现都在英勇地进行````javac````开发工作。Eclipse 对 Java SE 8 新特性的支持的贡献者有：Jayaprakash Arthanareeswaran, Shankha Banerjee, Anirban Chakraborty, Andrew Clement, Stephan Herrmann, Markus Keller, Jesper Moller, Manoj Palat, Srikanth Sankaran 和 Olivier Thomann。IntelliJ 对 Java SE 8 新特性的支持的贡献者有：Anna Kozlova, Alexey Kudravtsev 和 Roman Shevchenko。他们值得整个 Java 社区的感谢。

Java SE 8 是 Java 语言的一次复兴。尽管很多人一直在寻找所谓的下一代编程语言，我们仍然相信使用 Java 编程会比以往更加高效和令人兴奋。我们希望 Java 可以继续很好地为你服务。

----

# 1 介绍

----

Java 编程语言是一种通用的、并发的、基于类的和面向对象的语言。它被设计的足够简单以便于开发者流畅使用。Java 语言与 C 和 C++ 有关系，不过组织并不相同，包含了大量 C 和 C++ 中遗漏的元素，还有一些来自其它语言的特性。它试图成为一种生产力语言，而不是一种科研语言，因此，就像 C.A.R.Hoare 在他的语言设计经典论文中建议的那样，Java 语言的设计并未包含一些新的和未测试的特性。

Java 语言是强类型和静态类型语言。本规范清楚地区分了必须在编译期被检测到的编译期错误和在运行时发生的错误。编译期包括将程序转化成对应具体机器的字节码表示形式。运行时活动包含执行程序所需的类的加载和链接，程序的可选机器码生成和动态优化，以及实际的程序执行。

Java 是一种相对高级的语言，因为所有机器相关细节再语言中都不可用。它包含自动存储管理，典型地是使用垃圾收集器，来避免显式内存回收（就像 C 语言中的````free````或者 C++中的````delete````）存在的安全问题。高性能的垃圾收集实现可以保证有限的耗时，因而可以支持系统编程和实时应用。Java 语言不包含任何不安全的结构，比如没有下标检查的数组访问，因为这些不安全的结构可能会导致程序以未定义的方式运行。

Java 编程语言通常会被编译成为字节码指令集和二进制格式，定义在 The Java Virtual Machine Specification, Java SE 8 Edition 中。

## 1.1 本规范的组织

第二章描述了语法和记号，用来表示语言的词汇和词法语法等要素。

第三章描述了 Java 编程语言的词汇结构，基本上是基于 C 和 C++ 的。该语言是以 Unicode 字符集编写而成。它支持在只支持 ASCII 码的系统中写入 Unicode 字符。

第四章描述了类型、值以及变量。类型被分为基本类型和引用类型。

基本数据类型被定义为在所有机器和所有实现中都是相同的，两种实现长度的整型，单精度和双精度 IEEE 754 标准浮点数，````boolean````类型，以及一个 Unicode 字符````char````类型。基本数据类型的值并不共享状态。

引用类型包括类类型，接口类型，以及数组类型。引用类型通过动态创建类实例对象或者数据对象的方式实现。多个引用可以指向同一个对象。所有的对象（包括数组）都支持````Object````类的方法，该类是类层级结构的单根。一个预定义的````String````类支持 Unicode 字符集字符串。类的作用是将基本数据类型的值包装在其实例中。很多情况下，包装和拆包由编译器自动执行。类和接口声明可以使用泛型，也就是说，它们可以通过其它引用类型被参数化。这种声明随后可以在被调用时接收传入的特定类型参数。

变量是类型化的存储位置。一个基本类型的变量持有一个该基本类型的值。一个类类型的变量可以持有一个````null````引用或者该类的对象的引用，或者是该类的子类的实例对象的引用。一个接口类型的变量可以持有一个````null````引用或者任何实现了该接口的类实例的引用。一个数组类型变量可以持有一个````null````引用或者一个数组的引用。一个````Object````类型变量可以持有一个````null````引用，或者一个任何对象的引用，类实例或者数组都行。

第五章描述了类型转换和数值类型提升。类型转换在编译期改变数据类型，有时候，也改变表达式的值。这种类型转换包含在基本类型和引用类型之间的类型包装和拆包转换。数值类型提升用于将数值操作符的操作数转换为该操作符可以执行的通用数值类型。语言中的类型转换没有漏洞，运行时的引用类型转换将会被检查以保证类型安全。

第六章描述了声明和命名，以及如何确定命名的含义（指代）。Java 并不强制类型或者它们的成员在使用之前必须声明。声明的顺序只对局部变量、局部类有显著影响，同时决定了类或者接口内部的字段的初始化顺序。

Java 语言提供了命名作用域控制机制，支持包、类以及接口成员的外部访问限制。该特性在大型程序的编写中帮助开发者区分某个类型的实现是它的用户还是扩展者。这里同时还描述了有助于提高程序可读性的命名传统。

第七章描述了程序的结构，程序将被组织成类似于语言中的模块的形式。包的成员可以是类、接口或者子包。包被划分为编译单元。编译单元包含类型声明，可以从其它包引入类型并给与其名称缩写。在层级结构的命名空间中包拥有自己的名字，同时，内部的领域命名系统通常可以用于生成唯一的包名。

第八章描述类。类的成员可以是类、接口或者字段（变量）和方法。类变量在每个类中出现一次。类方法不会操作特定对象的引用。实例变量在类实例对象中被动态创建，实例方法在类实例上被调用，执行过程中这些实例变成当前对象````this````，支持面向对象编程范式。

类支持单继承实现，每个类的实现都是来自单个超类，最终都是来自````Object````类。类类型的变量可以指向一个该类或者它的任何子类的实例，允许在现有方法中使用新的类型，就是所谓的多态。

类通过````synchronized````方法来支持并发编程。方法声明它们执行过程中可能产生的相应的受检查异常，这就允许编译期检查来保证异常条件都被处理。对象可以声明一个````finalize````方法，在垃圾收集器丢弃对象之前该方法将会被调用，允许对象清理其状态。

为了简单，Java 语言既没有声明所谓的````headers````区别于类的实现，也没有区别于类层级结构的类型。

一种特殊形式的类，枚举，支持以类型安全的方式定义一个小集合的值以及它们的操作。不像其它语言中的枚举，Java 中的枚举是对象，也可以拥有它们自己的方法。

第九章描述了接口类型，其中声明一系列抽象方法、成员类型以及常量。相互之间没有关系的类可以实现同一个接口类型。一个接口类型变量可以包含任何实现了该接口的类的实例对象。同时继承多个接口是可以的。

注解类型是特殊的接口，用于注解声明。这种注解不被允许以任何方式影响 Java 程序的语义。然而，它们为多种工具提供了很有用的输入数据。

第十章描述了数组。数组访问包含边界检查。数组是动态创建的对象而且可以被分配以各种不同类型的````Object````。Java 语言支持数组的数组，不仅仅是多维数组。

第十一章描述了异常，表示无法恢复的情况，它与语言语义和并发机制完整集成在一起。异常分为三种：受检查的异常，运行时异常，以及错误。编译器确保受检查的异常可以被恰当地处理，通过强制一个方法或者构造器只能在声明可能产生异常的前提下才能产生一个受检查的异常。这就保证了异常处理器的存在会在编译期被检查，这对编程有很大帮助。大多数用户定义的异常应该是受检查的异常。被 Java 虚拟机检测到的程序中的非法操作导致运行时异常，比如````NullPointException````。错误来自 Java 虚拟机检测到的失败，比如````OutOfMemoryError````。大多数程序都不会试图处理错误。

第十二章描述了程序执行过程中发生的活动。程序通常是存储为二进制文件表示的编译后的类和接口。这些二进制文件可以被加载进入 Java 虚拟机，与其它类和接口链接起来，并初始化。

初始化之后，类方法和类变量可以被使用。一些类可以被实例化来创建新的类类型的对象。类实例对象同时包含该类的每个超类的实例，该实例对象的创建就包含这些超类实例的递归创建。

When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded.

当一个对象不再被引用，它就可以被垃圾收集器回收。如果一个对象声明了一个````finalizer````，则该方法在对象被回收之前会被执行，以给对象最后一个清理和释放它拥有的资源的机会。当一个类不再需要，它可以被卸载。

第十三章描述了二进制兼容性，指定了一个类型的改变对使用该类型的、而尚未重新编译的其它类型的影响。那些将被广泛发布和应用的类型的开发者会非常关注这个问题，那些类型会持续不断发布一系列版本，通常通过互联网传播。一个良好的开发环境在类型发生变化时会自动重新编译依赖代码，因而大多数开发者不需要关心这些细节。

第十四章描述了块和语句，基于 C 和 C++。Java 语言没有````goto````语句，但是包含标记的````break````和````continue````语句。与 C 语言中不同，Java 语言强制````boolean````(或者````Boolean````) 表达式出现在控制流语句中，而且不会显式酱类型转换为````boolean````（除了通过拆包），期望可以在编译期捕获更多错误。````synchronized````语句提供了基本的对象级别的监控锁定。````try````语句能够包含````catch````和````finally````从句来阻止非本地的控制转移。

第十五章描述表达式。此文档完整指定了（显而易见的）表达式解析顺序，为了增加确定性和便携性。重载方法和构造器在编译期解析，通过在所有可用的候选中选择最精确匹配的方法或者构造器。

第十六章准确描述了Java 语言如何确保局部变量在使用前肯定会被明确地设定。尽管所有其它变量会被自动初始化为一个默认值，Java 不会自动初始化局部变量以避免掩盖程序错误。

第十七章描述了线程和锁语义，这是最初由 Mesa 语言引入的基于监视器的并发机制。Java 语言为共享内存的多处理器环境指定了一个内存模型来支持高性能实现。

第十八章描述一系列类型推断算法，用于测试范型方法的适用性，以及在一个范型方法调用中推测类型。

第十九章展示了 Java 语言的语法和句法。

## 1.2 例子程序

大多数例子程序以文本形式给出，可以直接执行，类似于这样：

````java
class Test {
    public static void main(String[] args) {
        for(int i = 0; i < args.length; i++)
            System.out.print(i == 0 ? args[i] : " " + args[i]);
        System.out.println();
    }
}
````

在安装了 Oracle JDK 的机器上，这个类，存储在````Test.java````文件中，可以通过下面的命令编译和执行：

````java
javac Test.java
java Test Hello, world.
````

产生输出：

````
Hello, world.
````

## 1.3 记号

贯穿本规范，我们涉及到的都是来自 Java SE 平台的 API 。无论何时，我们提到一个类或者接口（不同于在例子程序中声明的类）使用一个单独的标识符 N，指的是位于````java.lang````包中的名为 N 的类或者接口。我们使用规范名称来指代````java.lang````包之外的类和接口。

非规范性的信息，规范中的特别说明，通过小号的斜体字给出。

*This is non-normative information. It provides intuition, rationale, advice, examples, etc.*

Java 语言的类型系统有时候依赖于替换的概念。记号````[F1:=T1, ..., Fn:=Tn]````表示对````1<=i<=n````的````Fi````由````Ti````替换。

## 1.4 与预定义类和接口的关系

如上所述，本规范经常提到 Java SE 平台 API 中的类。特别地，某些类与 Java 语言存在某种特殊关系。比如包含诸如````Object````,````Class````,````ClassLoader````,````String````,````Thread````以及在````java.lang.reflect````包下的类和接口。本规范限制了这些类和接口的行为，但是并没有给出完整的规范。读者可以参考 Java SE 平台 API 文档。

因此，此文档并没有描述有关反射的任何细节。很多语言结构中涉及到核心反射 API (````java.lang.reflect````) 和语言模型 API (````javax.lang.model````)，但是此文档中并没有讨论这些。比如，当我们列出对象创建的所有方法时，我们通常不会包含反射方式。读者们应该注意这些附加机制，尽管此规范中并没有提到这些。

## 1.5 反馈

欢迎读者报告本规范中的技术性错误和含混不清之处，发送邮件到````jls-jvms-spec-comments@openjdk.java.net````。

有关````javac````（Java 语言的参考编译器）行为，特别是与本规范的一致性的问题，请发送邮件到````compiler-dev@openjdk.java.net````。

----

# 2 语法

----

本章描述了本规范中使用的上下文无关语法，来定义程序的词法和句法结构。

## 2.1 上下文无关语法

上下文无关语法包含一系列产品。每种产品都由一个称为非终结符的抽象语法符号作为左值，一个或者多个非终结符序列以及一个终结符作为右值。对每种语法，终结符都来自一个特定的字母表。

由单个独特的非终结符开头和构成的句子，该非终结符称为目标符号，上下文无关语法指定了一种语言，也就是说，可能的终结符序列可以产生于用作为右值的非终结符重复替换作为左值的非终结符。

## 2.2 词法

Java 语言的词法在第三章中介绍。该词法拥有自己的终结符，是一个 Unicode 字符集中的字符。它定义了一系列的产品，以目标符号开始的输入，它描述了 Unicode 字符串序列时如何被转换成为输入元素的序列的。

这些输入元素，其中的空格和注释被丢弃，作为终结符的形式形成了 Java 语言的语法，被称为 *tokens*。Java 语言中这些 token 是标识符、关键字、常量、分隔符以及操作符。

## 2.3 句法

Java 语言的句法在 4.6—10、14 以及 15 章节中给出。这种语法拥有词法中定义的 tokens 作为它的终结符。它定义了一系列产品，以目标符号编译单元开始，它描述了 tokens 序列如何形成语法正确的程序。

方便起见，所有的语法元素都汇总在第 19 章中。

## 2.4 语法记号

终结符在展示词法和句法的产品中以固定宽度的字体显示，贯穿整篇规范文档，这些文字都是此类终结符的直接饮用。这些将完全以书面形式出现在程序中。

非终结符以 *italic* 字体显示。非终结符通过定义非终结符的名称而被定义，随后是一个冒号。一个或者多个不同的非终结符定义在随后的行中。

````xml
比如，句法生成：

IfThenStatement:
	if ( Expression ) Statement

声明非终结符 IfThenStatement 表示记号 if，后跟左括号记号，后跟表达式，后跟右括号记号，后跟 Statement。
````



