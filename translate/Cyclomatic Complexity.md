# 认知复杂度

### 一种衡量可理解性的新方法

作者 - G. Ann Campbell,
产品所有者 - SonarSource SA

------

## 摘要

圈复杂度最初是作为软件模块控制流的“可测试性和可维护性”的度量标准。尽管它可以很准确地计算前者，它的内在数学模型对精确衡量后者却不能令人满意。本白皮书描述了一种新的衡量标准来弥补圈复杂度采用的数学模型的缺陷，从而可以产生更加精确地反映代码真实理解难度，以及维护方法、类以及应用的难度。

### 术语

因为认知复杂度是一个语言中立的指标，可以等效应用于文件和类，以及方法、过程、函数等等。为了方便，我们使用面向对象术语“类”和“方法”。

------

## 目录

介绍

例子程序

基本约束和方法论

忽略规则

线性流中断的增量

* Catches
* Switches
* 逻辑操作符序列
* 递归
* 跳转到标签

嵌套流终端结构增量

影响

结论

------

## 介绍

Thomas J. McCabe的Cyclomatic Complexity 圈复杂度理论长期以来一直是衡量方法控制流程复杂性的事实标准。它最初的目的是“识别难以测试或维护的软件模块”，但是虽然它准确地计算了完全覆盖方法所需的最小测试用例数，但它并不是一个令人满意的可理解性度量。这是因为具有相同的圈复杂度的方法不一定会给维护者带来同样的困难，从而导致一种感觉，即通过过度估价某些结构来衡量“哭狼”，同时低估其他结构。

与此同时，圈复杂度不再全面。该理论是1976年在Fortran环境中制定，它不包括现代语言结构，如`try/catch`和`lambdas`。

最后，因为每个方法的最小圈复杂度得分为1，所以不可能知道具有高聚合圈复杂度的任何给定类是一个大的，易于维护的域类，还是具有复杂控制流的小类。在类层面之上，人们普遍认为，圈复杂度得分与应用程序代码行总数相关。换句话说，圈复杂度在方法级别之上几乎没有用处。

作为这些问题的补救措施，认知复杂性理论已经制定，以解决现代语言结构，并产生在类和应用程序级别有意义的值。更重要的是，它不同于基于数学模型评估代码的实践，因此它可以产生对应于程序员对理解这些流所需的心理或认知努力的直觉的控制流的评估。

## 例子程序

以旨在解决圈复杂度理论问题的一个例子开始讨论认知复杂性是很有用的。以下两种方法具有相同的圈复杂度，但是在可理解性方面有惊人的不同。

````
int sumOfPrimes(int max) { // +1
 	int total = 0;
 	OUT: for (int i = 1; i <= max; ++i) { // +1
 		for (int j = 2; j < i; ++j) { // +1
 			if (i % j == 0) { // +1
 				continue OUT;
 			}
 		}
 		total += i;
 	}
 	return total;
} // Cyclomatic Complexity 4
````

````
String getWords(int number) { // +1
 	switch (number) {
 		case 1: // +1
 			return "one";
 		case 2: // +1
 			return "a couple";
 		case 3: // +1
 			return “a few”;
 		default:
 			return "lots";
 	}
} // Cyclomatic Complexity 4
````

圈复杂度的数学模型使这两种方法评分相等，但直观显而易见的是，`sumOfPrimes`的控制流程更难以理解。这就是认知复杂性放弃使用用于评估控制流程的数学模型的原因，认知复杂度理论采用了一组简单的规则将程序员直觉转化成数字。

## 基本约束和方法论

认知复杂性评分根据三个基本规则评估：

1. 忽略允许多个语句可以简单地缩写为一个的结构
2. 为代码的线性流中的每个中断递增（加1）
3. 控制流结构嵌套时递增

此外，复杂性分数由四种不同类型的增量组成：

1. 嵌套 - 评估彼此内部的嵌套控制流结构
2. 结构 - 评估受嵌套影响的控制流结构增量，并增加嵌套计数
3. 基本 - 对不受嵌套增量限制的语句进行评估
4. 混合 - 评估不受嵌套影响的控制流结构增量，同时增加了嵌套计数

虽然增量的类型在数学上没有区别 - 每个增量都会增加一个最终得分 - 区分被计算的特征类别使得更容易理解嵌套增量的作用和不适用的位置。

以下各节将进一步详细介绍这些规则及其背后的原理。

## 忽略规则

认知复杂性的评估中的一个指导原则是它应该支持良好的编码实践。也就是说，它应该忽略或刻意低估有助于提高代码的可读性的写法。

方法结构本身就是一个很好的例子。将代码分解为方法可以实现将多个语句压缩成一个显而易见的命名调用，即“简写”它。因此，认知复杂性不会为方法增加评分。

认知复杂性也忽略了许多语言中的null-coalescing（空合并）操作符，再次，因为他们允许将多行代码短接到一行。例如，以下代码示例执行相同的操作：

````java
MyObj myObj = null;
if (a != null) {
	myObj = a.myObj;
}
````

````
MyObj myObj = a?.myObj;
````

前者需要花一些时间来理解，而当你熟悉所谓的空合并操作，立即就能理解后者。因此，认知复杂度评估会自动忽略空合并操作。

## 线性流中断增量

认知复杂性的另一个指导原则是：中断代码从上到下、从左到右的正常线性流的结构，会导致维护者更难理解代码，因此认知复杂性评估结果会包含结构增量：

* 循环结构：for，while，do while，...
* 条件：三元运算符，if，＃if，＃ifdef，...

它评估混合增量：

* else if，elif，else，......

不需要评估这些结构的嵌套增量，因为在阅读if时已经付出了心理成本。

对于习惯于圈复杂度理论的人来说，这些增量目标似乎很熟悉。此外，认知复杂性也会随着以下结构增加：

### Caches

catch表示控制流中的一种分支，与if一样多。因此，每个catch子句都会导致认知复杂性的结构性增加。注意一个catch只会在Cognitive Complexity得分上增加一点，无论捕获多少异常类型。try和finally语句块被完全忽略。

### Switches

一个switch及其所有case都会产生单一的结构增量。

在圈复杂度理论下，switch被视为if-else if链的模拟。也就是说，switch中的每个case都会导致增量，因为它会导致分支
控制流的数学模型。

但是从维护者的角度来看，一个switch - 将一个变量与一个明确命名的文字值集进行比较 - 比if-else if更容易理解
因为后者可以使用任意数量变量和值进行任意数量的比较。

简而言之，必须仔细阅读if-else if链，而通常采用switch会一目了然。

