# 认知复杂度

### 一种衡量可理解性的新方法

作者 - G. Ann Campbell,
产品所有者 - SonarSource SA

------

## 摘要

圈复杂度最初是作为软件模块控制流的“可测试性和可维护性”的度量标准。尽管它可以很准确地计算前者，它的内在数学模型对精确衡量后者却不能令人满意。本白皮书描述了一种新的衡量标准来弥补圈复杂度采用的数学模型的缺陷，从而可以产生更加精确地反映代码真实理解难度，以及维护方法、类以及应用的难度。

### 术语

因为认知复杂度是一个语言中立的指标，可以等效应用于文件和类，以及方法、过程、函数等等。为了方便，我们使用面向对象术语“类”和“方法”。

------

## 目录

介绍

例子程序

基本约束和方法论

忽略规则

线性流中断的增量

* Catches
* Switches
* 逻辑操作符序列
* 递归
* 跳转到标签

嵌套流中断结构增量

影响

结论

------

## 介绍

Thomas J. McCabe的Cyclomatic Complexity 圈复杂度理论长期以来一直是衡量方法控制流程复杂性的事实标准。它最初的目的是“识别难以测试或维护的软件模块”，但是虽然它准确地计算了完全覆盖方法所需的最小测试用例数，但它并不是一个令人满意的可理解性度量。这是因为具有相同的圈复杂度的方法不一定会给维护者带来同样的困难，从而导致一种感觉，即通过过度估价某些结构来衡量“哭狼”，同时低估其他结构。

与此同时，圈复杂度不再全面。该理论是1976年在Fortran环境中制定，它不包括现代语言结构，如`try/catch`和`lambdas`。

最后，因为每个方法的最小圈复杂度得分为1，所以不可能知道具有高聚合圈复杂度的任何给定类是一个大的，易于维护的域类，还是具有复杂控制流的小类。在类层面之上，人们普遍认为，圈复杂度得分与应用程序代码行总数相关。换句话说，圈复杂度在方法级别之上几乎没有用处。

作为这些问题的补救措施，认知复杂性理论已经制定，以解决现代语言结构，并产生在类和应用程序级别有意义的值。更重要的是，它不同于基于数学模型评估代码的实践，因此它可以产生对应于程序员对理解这些流所需的心理或认知努力的直觉的控制流的评估。

## 例子程序

以旨在解决圈复杂度理论问题的一个例子开始讨论认知复杂性是很有用的。以下两种方法具有相同的圈复杂度，但是在可理解性方面有惊人的不同。

````
int sumOfPrimes(int max) { // +1
 	int total = 0;
 	OUT: for (int i = 1; i <= max; ++i) { // +1
 		for (int j = 2; j < i; ++j) { // +1
 			if (i % j == 0) { // +1
 				continue OUT;
 			}
 		}
 		total += i;
 	}
 	return total;
} // Cyclomatic Complexity 4
````

````
String getWords(int number) { // +1
 	switch (number) {
 		case 1: // +1
 			return "one";
 		case 2: // +1
 			return "a couple";
 		case 3: // +1
 			return “a few”;
 		default:
 			return "lots";
 	}
} // Cyclomatic Complexity 4
````

圈复杂度的数学模型使这两种方法评分相等，但直观显而易见的是，`sumOfPrimes`的控制流程更难以理解。这就是认知复杂性放弃使用用于评估控制流程的数学模型的原因，认知复杂度理论采用了一组简单的规则将程序员直觉转化成数字。

## 基本约束和方法论

认知复杂性评分根据三个基本规则评估：

1. 忽略允许多个语句可以简单地缩写为一个的结构
2. 为代码的线性流中的每个中断递增（加1）
3. 控制流结构嵌套时递增

此外，复杂性分数由四种不同类型的增量组成：

1. 嵌套 - 评估彼此内部的嵌套控制流结构
2. 结构 - 评估受嵌套影响的控制流结构增量，并增加嵌套计数
3. 基本 - 对不受嵌套增量限制的语句进行评估
4. 混合 - 评估不受嵌套影响的控制流结构增量，同时增加了嵌套计数

虽然增量的类型在数学上没有区别 - 每个增量都会增加一个最终得分 - 区分被计算的特征类别使得更容易理解嵌套增量的作用和不适用的位置。

以下各节将进一步详细介绍这些规则及其背后的原理。

## 忽略规则

认知复杂性的评估中的一个指导原则是它应该支持良好的编码实践。也就是说，它应该忽略或刻意低估有助于提高代码的可读性的写法。

方法结构本身就是一个很好的例子。将代码分解为方法可以实现将多个语句压缩成一个显而易见的命名调用，即“简写”它。因此，认知复杂性不会为方法增加评分。

认知复杂性也忽略了许多语言中的null-coalescing（空合并）操作符，再次，因为他们允许将多行代码短接到一行。例如，以下代码示例执行相同的操作：

````java
MyObj myObj = null;
if (a != null) {
	myObj = a.myObj;
}
````

````
MyObj myObj = a?.myObj;
````

前者需要花一些时间来理解，而当你熟悉所谓的空合并操作，立即就能理解后者。因此，认知复杂度评估会自动忽略空合并操作。

## 线性流中断增量

认知复杂性的另一个指导原则是：中断代码从上到下、从左到右的正常线性流的结构，会导致维护者更难理解代码，因此认知复杂性评估结果会包含结构增量：

* 循环结构：for，while，do while，...
* 条件：三元运算符，if，＃if，＃ifdef，...

它评估混合增量：

* else if，elif，else，......

不需要评估这些结构的嵌套增量，因为在阅读if时已经付出了心理成本。

对于习惯于圈复杂度理论的人来说，这些增量目标似乎很熟悉。此外，认知复杂性也会随着以下结构增加：

### Caches

catch表示控制流中的一种分支，与if一样多。因此，每个catch子句都会导致认知复杂性的结构性增加。注意一个catch只会在Cognitive Complexity得分上增加一点，无论捕获多少异常类型。try和finally语句块被完全忽略。

### Switches

一个switch及其所有case都会产生单一的结构增量。

在圈复杂度理论下，switch被视为if-else if链的模拟。也就是说，switch中的每个case都会导致增量，因为它会导致分支
控制流的数学模型。

但是从维护者的角度来看，一个switch - 将一个变量与一个明确命名的文字值集进行比较 - 比if-else if更容易理解
因为后者可以使用任意数量变量和值进行任意数量的比较。

简而言之，必须仔细阅读if-else if链，而通常采用switch会一目了然。

### 逻辑操作序列

类似的原因，圈复杂度不会为每个二元逻辑操作符加分。相反，它为每个二元逻辑操作序列加分。例如，考虑下面的代码片段：

````
a && b
a && b && c && d
````

````
a || b
a || b || c || d
````

每个例子中的第二行理解起来并不会比第一行更困难。另一方面，下面的例子中的两行理解起来就存在一个显著的不同：

````
a && b && c && d
a || b && c || d
````

因为逻辑表达式中混合了多种逻辑操作符时就会非常难以理解。认知复杂度会为逻辑操作符序列中每个新的操作符加分。如下：

````
if (a 			// +1 for `if`
 	&& b && c 	// +1
 	|| d || e 	// +1
 	&& f) 		// +1
if (a 			// +1 for `if`
 	&& 			// +1
 	!(b && c)) 	// +1

````

尽管认知复杂度为逻辑操作符评分提供了类似于圈复杂度评分的“折扣”机制，它并不为所有逻辑操作符加分。比如在变量赋值、方法调用以及返回语句中的逻辑操作序列。

### 递归

与圈复杂度不同，认知复杂性为每个递归循环中的直接还是间接方法复杂性增加了一个基本的增量。这有两个决策动机。 首先，递归代表一种“元循环”和认知复杂性循环增量。其次，认知复杂性是关于估计了解方法的控制流程相对难度的指标，即使是一些经验丰富的程序员也会发现递归很难理解。

### 跳转到标签

认知复杂度理论为 goto, break, continue 到一个标签添加了一类基本增量。但是由于及早的 return 经常能够是代码更加整洁，因此这种及早退出或者返回不会增加认知复杂度评分。

## 嵌套流中断结构增量

无论具体的执行路径如何，相同数量的线性 if 序列或者 for 结构理解起来都会比产生嵌套时容易太多。因为这种嵌套会显著提升理解代码的心里成本。认知复杂度评分为此添加了增量。

具体而言，每次将导致结构或混合增量的结构嵌套在另一个这样的结构中，认知复杂度评分就会为每个嵌套级别添加嵌套增量。例如，在以下示例中，认知复杂度评分并没有为方法本身或 try 增加嵌套增量，因为两种结构都不会导致结构增量或混合增量：

````
void myMethod () {
 	try {
 		if (condition1) { // +1
 			for (int i = 0; i < 10; i++) { // +2 (nesting=1)
 				while (condition2) { … } // +3 (nesting=2)
 			}
 		}
 	} catch (ExcepType1 | ExcepType2 e) { // +1
 		if (condition2) { … } // +2 (nesting=1)
 	}
} // Cognitive Complexity 9
````

然而，其中的 if, for, whlie 和 catch 结构都是结构增量和嵌套增量的目标。

另外，尽管顶层的方法被忽略，从而不存在关于 lambdas、嵌套方法以及类似特征的结构增量，当此类方法被嵌套进入其它类似方法的结构中时，仍然会产生嵌套层次增量：

````
void myMethod2 () {
 Runnable r = () -> { // +0 (but nesting level is now 1)
 if (condition1) { … } // +2 (nesting=1)
 };
} // Cognitive Complexity 2
#if DEBUG // +1 for if
void myMethod2 () { // +0 (nesting level is still 0)
 Runnable r = () -> { // +0 (but nesting level is now 1)
 if (condition1) { … } // +3 (nesting=2)
 };
} // Cognitive Complexity 4
#endif
````

## 影响

认知复杂性的主要目标是计算更准确地反映方法的相对可理解性的得分，次要目标解决现代语言结构并在方法层面产生有价值的指标。显而易见，解决现代语言结构的目标已经实现。另外两个目标在下面进行了检查。

### 直观的“正确的”复杂性评分

本白皮书从一对具有相同的圈复杂度而可理解性显著不同的方法开始。现在是时候重新审视这些方法并计算它们的认知复杂度分数：

````
int sumOfPrimes(int max) {
 	int total = 0;
 	OUT: for (int i = 1; i <= max; ++i) { // +1
 		for (int j = 2; j < i; ++j) { // +2
 			if (i % j == 0) { // +3
 				continue OUT; // +1
 			}
 		}
 		total += i;
 	}
 	return total;
} // Cognitive Complexity 7
````

````
String getWords(int number) {
 	switch (number) { // +1
 		case 1:
 			return "one";
 		case 2:
 			return "a couple";
 		case 3:
 			return “a few”;
 		default:
 			return "lots";
 	}
 } // Cognitive Complexity 1
````

认知复杂度算法给这两个方法计算出了相差悬殊的分数，相对于圈复杂度，显然更加能够反映它们的相对可理解性差异。

### 方法层面更有价值的指标

此外，因为认知复杂性不会为方法结构加分，总分就变得有用。现在，您可以区分域类 - 一个有大量简单的getter和setter  - 一个包含一个复杂的通过简单地比较其度量值来控制的流程。认知复杂性因此成为一种用于测量类和应用程序的相对可理解性的工具。

## 总结

编写和维护代码的过程是人为过程。程序的输出必须遵循数学模型，但它们本身并不适合数学模型。
这就是为什么数学模型不足以评估理解它们所需要的脑力。

认知复杂度理论打破了使用数学模型进行软件可维护性评估的实践。它从圈复杂度设置的先例开始，但是使用人类的判断来评估结构应该如何计数，并决定什么应该作为一个整体添加到模型中。结果，它产生方法复杂性分数，这使得程序员对可理解性的相对评估相对于以前的模型更加公平。此外，因为认知复杂性没有设置方法的“进入成本”，它产生了更公平的相对评估，不仅仅是在方法级别，在类和应用程序级别也是如此。

